
RNDISEthernet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000f8  00800100  00002f60  00002ff4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002f60  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001225  008001f8  008001f8  000030ec  2**0
                  ALLOC
  3 .debug_aranges 00000650  00000000  00000000  000030ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00001064  00000000  00000000  0000373c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000aea8  00000000  00000000  000047a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000031ee  00000000  00000000  0000f648  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00007fb5  00000000  00000000  00012836  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000920  00000000  00000000  0001a7ec  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00003c1b  00000000  00000000  0001b10c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000043d4  00000000  00000000  0001ed27  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000720  00000000  00000000  000230fb  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
	return true;
#endif
}

void Endpoint_ClearEndpoints(void)
{
       0:	10 c2       	rjmp	.+1056   	; 0x422 <__ctors_end>
	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
}
       2:	00 00       	nop
uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
       4:	2c c2       	rjmp	.+1112   	; 0x45e <__bad_interrupt>

	return Serial_ReceiveByte();
}

int Serial_getchar_Blocking(FILE *Stream)
{
       6:	00 00       	nop
       8:	2a c2       	rjmp	.+1108   	; 0x45e <__bad_interrupt>
       a:	00 00       	nop
       c:	28 c2       	rjmp	.+1104   	; 0x45e <__bad_interrupt>
       e:	00 00       	nop
      10:	26 c2       	rjmp	.+1100   	; 0x45e <__bad_interrupt>
      12:	00 00       	nop
      14:	24 c2       	rjmp	.+1096   	; 0x45e <__bad_interrupt>
      16:	00 00       	nop
      18:	22 c2       	rjmp	.+1092   	; 0x45e <__bad_interrupt>
      1a:	00 00       	nop
      1c:	20 c2       	rjmp	.+1088   	; 0x45e <__bad_interrupt>
      1e:	00 00       	nop
      20:	1e c2       	rjmp	.+1084   	; 0x45e <__bad_interrupt>
      22:	00 00       	nop
      24:	1c c2       	rjmp	.+1080   	; 0x45e <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 e6 0e 	jmp	0x1dcc	; 0x1dcc <__vector_10>
      2c:	18 c2       	rjmp	.+1072   	; 0x45e <__bad_interrupt>
      2e:	00 00       	nop
      30:	16 c2       	rjmp	.+1068   	; 0x45e <__bad_interrupt>
      32:	00 00       	nop
      34:	14 c2       	rjmp	.+1064   	; 0x45e <__bad_interrupt>
      36:	00 00       	nop
      38:	12 c2       	rjmp	.+1060   	; 0x45e <__bad_interrupt>
      3a:	00 00       	nop
      3c:	10 c2       	rjmp	.+1056   	; 0x45e <__bad_interrupt>
      3e:	00 00       	nop
      40:	0e c2       	rjmp	.+1052   	; 0x45e <__bad_interrupt>
      42:	00 00       	nop
      44:	0c c2       	rjmp	.+1048   	; 0x45e <__bad_interrupt>
      46:	00 00       	nop
      48:	0a c2       	rjmp	.+1044   	; 0x45e <__bad_interrupt>
      4a:	00 00       	nop
      4c:	08 c2       	rjmp	.+1040   	; 0x45e <__bad_interrupt>
      4e:	00 00       	nop
      50:	06 c2       	rjmp	.+1036   	; 0x45e <__bad_interrupt>
      52:	00 00       	nop
      54:	04 c2       	rjmp	.+1032   	; 0x45e <__bad_interrupt>
      56:	00 00       	nop
      58:	02 c2       	rjmp	.+1028   	; 0x45e <__bad_interrupt>
      5a:	00 00       	nop
      5c:	00 c2       	rjmp	.+1024   	; 0x45e <__bad_interrupt>
      5e:	00 00       	nop
      60:	fe c1       	rjmp	.+1020   	; 0x45e <__bad_interrupt>
      62:	00 00       	nop
      64:	fc c1       	rjmp	.+1016   	; 0x45e <__bad_interrupt>
      66:	00 00       	nop
      68:	fa c1       	rjmp	.+1012   	; 0x45e <__bad_interrupt>
      6a:	00 00       	nop
      6c:	f8 c1       	rjmp	.+1008   	; 0x45e <__bad_interrupt>
      6e:	00 00       	nop
      70:	f6 c1       	rjmp	.+1004   	; 0x45e <__bad_interrupt>
      72:	00 00       	nop
      74:	f4 c1       	rjmp	.+1000   	; 0x45e <__bad_interrupt>
      76:	00 00       	nop
      78:	f2 c1       	rjmp	.+996    	; 0x45e <__bad_interrupt>
      7a:	00 00       	nop
      7c:	f0 c1       	rjmp	.+992    	; 0x45e <__bad_interrupt>
      7e:	00 00       	nop
      80:	ee c1       	rjmp	.+988    	; 0x45e <__bad_interrupt>
      82:	00 00       	nop
      84:	ec c1       	rjmp	.+984    	; 0x45e <__bad_interrupt>
      86:	00 00       	nop
      88:	ea c1       	rjmp	.+980    	; 0x45e <__bad_interrupt>
      8a:	00 00       	nop
      8c:	e8 c1       	rjmp	.+976    	; 0x45e <__bad_interrupt>
      8e:	00 00       	nop
      90:	e6 c1       	rjmp	.+972    	; 0x45e <__bad_interrupt>
      92:	00 00       	nop
      94:	e4 c1       	rjmp	.+968    	; 0x45e <__bad_interrupt>
      96:	00 00       	nop

00000098 <DeviceDescriptor>:
      98:	12 01 10 01 02 00 00 08 eb 03 4c 20 01 00 01 02     ..........L ....
      a8:	00 01                                               ..

000000aa <ConfigurationDescriptor>:
      aa:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
      ba:	ff 00 05 24 00 10 01 04 24 02 00 05 24 06 00 01     ...$....$...$...
      ca:	07 05 83 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
      da:	07 05 02 02 40 00 01 07 05 81 02 40 00 01           ....@......@..

000000e8 <LanguageString>:
      e8:	04 03 09 04                                         ....

000000ec <ManufacturerString>:
      ec:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
      fc:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

00000106 <ProductString>:
     106:	28 03 4c 00 55 00 46 00 41 00 20 00 52 00 4e 00     (.L.U.F.A. .R.N.
     116:	44 00 49 00 53 00 20 00 43 00 44 00 43 00 20 00     D.I.S. .C.D.C. .
     126:	44 00 65 00 6d 00 6f 00 00 00                       D.e.m.o...

00000130 <HTTP200Header>:
     130:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     140:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 52 4e     .Server: LUFA RN
     150:	44 49 53 0d 0a 43 6f 6e 74 65 6e 74 2d 74 79 70     DIS..Content-typ
     160:	65 3a 20 74 65 78 74 2f 68 74 6d 6c 0d 0a 43 6f     e: text/html..Co
     170:	6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d     nnection: close.
     180:	0a 0d 0a 00                                         ....

00000184 <HTTP404Header>:
     184:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
     194:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
     1a4:	4c 55 46 41 20 52 4e 44 49 53 0d 0a 43 6f 6e 6e     LUFA RNDIS..Conn
     1b4:	65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a 0d     ection: close...
     1c4:	0a 00                                               ..

000001c6 <HTTPPage>:
     1c6:	3c 68 74 6d 6c 3e 09 3c 68 65 61 64 3e 09 09 3c     <html>.<head>..<
     1d6:	74 69 74 6c 65 3e 09 09 09 4c 55 46 41 20 57 65     title>...LUFA We
     1e6:	62 73 65 72 76 65 72 20 44 65 6d 6f 09 09 3c 2f     bserver Demo..</
     1f6:	74 69 74 6c 65 3e 09 3c 2f 68 65 61 64 3e 09 3c     title>.</head>.<
     206:	62 6f 64 79 3e 09 09 3c 68 31 3e 48 65 6c 6c 6f     body>..<h1>Hello
     216:	20 66 72 6f 6d 20 79 6f 75 72 20 55 53 42 20 41      from your USB A
     226:	56 52 21 3c 2f 68 31 3e 09 09 3c 70 3e 09 09 09     VR!</h1>..<p>...
     236:	48 65 6c 6c 6f 21 20 57 65 6c 63 6f 6d 65 20 74     Hello! Welcome t
     246:	6f 20 74 68 65 20 4c 55 46 41 20 52 4e 44 49 53     o the LUFA RNDIS
     256:	20 44 65 6d 6f 20 57 65 62 73 65 72 76 65 72 20      Demo Webserver 
     266:	74 65 73 74 20 70 61 67 65 2c 20 72 75 6e 6e 69     test page, runni
     276:	6e 67 20 6f 6e 20 79 6f 75 72 20 55 53 42 20 41     ng on your USB A
     286:	56 52 20 76 69 61 20 74 68 65 20 4c 55 46 41 20     VR via the LUFA 
     296:	6c 69 62 72 61 72 79 2e 20 54 68 69 73 20 64 65     library. This de
     2a6:	6d 6f 6e 73 74 72 61 74 65 73 20 74 68 65 20 48     monstrates the H
     2b6:	54 54 50 20 77 65 62 73 65 72 76 65 72 2c 20 54     TTP webserver, T
     2c6:	43 50 2f 49 50 20 73 74 61 63 6b 20 61 6e 64 20     CP/IP stack and 
     2d6:	52 4e 44 49 53 20 64 65 6d 6f 20 61 6c 6c 20 72     RNDIS demo all r
     2e6:	75 6e 6e 69 6e 67 20 61 74 6f 70 20 74 68 65 20     unning atop the 
     2f6:	4c 55 46 41 20 55 53 42 20 73 74 61 63 6b 2e 09     LUFA USB stack..
     306:	09 09 3c 62 72 20 2f 3e 3c 62 72 20 2f 3e 09 09     ..<br /><br />..
     316:	09 3c 73 6d 61 6c 6c 3e 50 72 6f 6a 65 63 74 20     .<small>Project 
     326:	49 6e 66 6f 72 6d 61 74 69 6f 6e 3a 20 3c 61 20     Information: <a 
     336:	68 72 65 66 3d 22 68 74 74 70 3a 2f 2f 77 77 77     href="http://www
     346:	2e 6c 75 66 61 2d 6c 69 62 2e 6f 72 67 22 3e 68     .lufa-lib.org">h
     356:	74 74 70 3a 2f 2f 77 77 77 2e 6c 75 66 61 2d 6c     ttp://www.lufa-l
     366:	69 62 2e 6f 72 67 3c 2f 61 3e 2e 3c 2f 73 6d 61     ib.org</a>.</sma
     376:	6c 6c 3e 09 09 09 3c 68 72 20 2f 3e 09 09 09 3c     ll>...<hr />...<
     386:	69 3e 4c 55 46 41 20 56 65 72 73 69 6f 6e 3a 20     i>LUFA Version: 
     396:	3c 2f 69 3e 31 31 30 35 32 38 09 09 3c 2f 70 3e     </i>110528..</p>
     3a6:	09 3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c 3e 00     .</body></html>.

000003b6 <AdapterSupportedOIDList>:
     3b6:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
     3c6:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
     3d6:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
     3e6:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................
     3f6:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
     406:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
     416:	01 01 02 01 02 01 02 01 03 01 02 01                 ............

00000422 <__ctors_end>:
     422:	11 24       	eor	r1, r1
     424:	1f be       	out	0x3f, r1	; 63
     426:	cf ef       	ldi	r28, 0xFF	; 255
     428:	d0 e2       	ldi	r29, 0x20	; 32
     42a:	de bf       	out	0x3e, r29	; 62
     42c:	cd bf       	out	0x3d, r28	; 61

0000042e <__do_copy_data>:
     42e:	11 e0       	ldi	r17, 0x01	; 1
     430:	a0 e0       	ldi	r26, 0x00	; 0
     432:	b1 e0       	ldi	r27, 0x01	; 1
     434:	e0 e6       	ldi	r30, 0x60	; 96
     436:	ff e2       	ldi	r31, 0x2F	; 47
     438:	00 e0       	ldi	r16, 0x00	; 0
     43a:	0b bf       	out	0x3b, r16	; 59
     43c:	02 c0       	rjmp	.+4      	; 0x442 <__do_copy_data+0x14>
     43e:	07 90       	elpm	r0, Z+
     440:	0d 92       	st	X+, r0
     442:	a8 3f       	cpi	r26, 0xF8	; 248
     444:	b1 07       	cpc	r27, r17
     446:	d9 f7       	brne	.-10     	; 0x43e <__do_copy_data+0x10>

00000448 <__do_clear_bss>:
     448:	14 e1       	ldi	r17, 0x14	; 20
     44a:	a8 ef       	ldi	r26, 0xF8	; 248
     44c:	b1 e0       	ldi	r27, 0x01	; 1
     44e:	01 c0       	rjmp	.+2      	; 0x452 <.do_clear_bss_start>

00000450 <.do_clear_bss_loop>:
     450:	1d 92       	st	X+, r1

00000452 <.do_clear_bss_start>:
     452:	ad 31       	cpi	r26, 0x1D	; 29
     454:	b1 07       	cpc	r27, r17
     456:	e1 f7       	brne	.-8      	; 0x450 <.do_clear_bss_loop>
     458:	6a d0       	rcall	.+212    	; 0x52e <main>
     45a:	0c 94 ae 17 	jmp	0x2f5c	; 0x2f5c <_exit>

0000045e <__bad_interrupt>:
     45e:	d0 cd       	rjmp	.-1120   	; 0x0 <__vectors>

00000460 <EVENT_USB_Device_Connect>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     460:	8b b1       	in	r24, 0x0b	; 11
     462:	8f 70       	andi	r24, 0x0F	; 15
     464:	80 6a       	ori	r24, 0xA0	; 160
     466:	8b b9       	out	0x0b, r24	; 11

/** Event handler for the library USB Connection event. */
void EVENT_USB_Device_Connect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
}
     468:	08 95       	ret

0000046a <EVENT_USB_Device_Disconnect>:
     46a:	8b b1       	in	r24, 0x0b	; 11
     46c:	8f 70       	andi	r24, 0x0F	; 15
     46e:	80 61       	ori	r24, 0x10	; 16
     470:	8b b9       	out	0x0b, r24	; 11

/** Event handler for the library USB Disconnection event. */
void EVENT_USB_Device_Disconnect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
}
     472:	08 95       	ret

00000474 <EVENT_USB_Device_ControlRequest>:
}

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	RNDIS_Device_ProcessControlRequest(&Ethernet_RNDIS_Interface);
     474:	88 e1       	ldi	r24, 0x18	; 24
     476:	91 e0       	ldi	r25, 0x01	; 1
     478:	0c 94 68 14 	jmp	0x28d0	; 0x28d0 <RNDIS_Device_ProcessControlRequest>

0000047c <EVENT_USB_Device_ConfigurationChanged>:
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= RNDIS_Device_ConfigureEndpoints(&Ethernet_RNDIS_Interface);
     47c:	88 e1       	ldi	r24, 0x18	; 24
     47e:	91 e0       	ldi	r25, 0x01	; 1
     480:	0e 94 1f 14 	call	0x283e	; 0x283e <RNDIS_Device_ConfigureEndpoints>

	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     484:	80 fd       	sbrc	r24, 0
     486:	02 c0       	rjmp	.+4      	; 0x48c <EVENT_USB_Device_ConfigurationChanged+0x10>
     488:	90 e9       	ldi	r25, 0x90	; 144
     48a:	01 c0       	rjmp	.+2      	; 0x48e <EVENT_USB_Device_ConfigurationChanged+0x12>
     48c:	90 e6       	ldi	r25, 0x60	; 96
     48e:	8b b1       	in	r24, 0x0b	; 11
     490:	8f 70       	andi	r24, 0x0F	; 15
     492:	98 2b       	or	r25, r24
     494:	9b b9       	out	0x0b, r25	; 11
}
     496:	08 95       	ret

00000498 <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
     498:	84 b7       	in	r24, 0x34	; 52
     49a:	87 7f       	andi	r24, 0xF7	; 247
     49c:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
     49e:	38 e1       	ldi	r19, 0x18	; 24
     4a0:	0f b6       	in	r0, 0x3f	; 63
     4a2:	f8 94       	cli
     4a4:	30 93 60 00 	sts	0x0060, r19
     4a8:	10 92 60 00 	sts	0x0060, r1
     4ac:	0f be       	out	0x3f, r0	; 63

	/* Disable clock division */
	clock_prescale_set(clock_div_1);
     4ae:	80 e0       	ldi	r24, 0x00	; 0
     4b0:	90 e0       	ldi	r25, 0x00	; 0
     4b2:	20 e8       	ldi	r18, 0x80	; 128
     4b4:	0f b6       	in	r0, 0x3f	; 63
     4b6:	f8 94       	cli
     4b8:	20 93 61 00 	sts	0x0061, r18
     4bc:	80 93 61 00 	sts	0x0061, r24
     4c0:	0f be       	out	0x3f, r0	; 63

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
     4c2:	8a b1       	in	r24, 0x0a	; 10
     4c4:	80 6f       	ori	r24, 0xF0	; 240
     4c6:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
     4c8:	8b b1       	in	r24, 0x0b	; 11
     4ca:	8f 70       	andi	r24, 0x0F	; 15
     4cc:	8b b9       	out	0x0b, r24	; 11
			 *  \param[in] DoubleSpeed  Enables double speed mode when set, halving the sample time to double the baud rate.
			 */
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed)
			{
				UBRR1  = (DoubleSpeed ? SERIAL_2X_UBBRVAL(BaudRate) : SERIAL_UBBRVAL(BaudRate));
     4ce:	83 e3       	ldi	r24, 0x33	; 51
     4d0:	90 e0       	ldi	r25, 0x00	; 0
     4d2:	90 93 cd 00 	sts	0x00CD, r25
     4d6:	80 93 cc 00 	sts	0x00CC, r24

				UCSR1C = ((1 << UCSZ11) | (1 << UCSZ10));
     4da:	86 e0       	ldi	r24, 0x06	; 6
     4dc:	80 93 ca 00 	sts	0x00CA, r24
				UCSR1A = (DoubleSpeed ? (1 << U2X1) : 0);
     4e0:	10 92 c8 00 	sts	0x00C8, r1
				UCSR1B = ((1 << TXEN1)  | (1 << RXEN1));
     4e4:	30 93 c9 00 	sts	0x00C9, r19

				DDRD  |= (1 << 3);
     4e8:	53 9a       	sbi	0x0a, 3	; 10
				PORTD |= (1 << 2);
     4ea:	5a 9a       	sbi	0x0b, 2	; 11

	/* Hardware Initialization */
	LEDs_Init();
	Serial_Init(9600, false);
	USB_Init();
     4ec:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <USB_Init>
			static inline void Serial_CreateStream(FILE* Stream)
			{
				if (!(Stream))
				{
					Stream = &USARTSerialStream;
					stdin  = Stream;
     4f0:	e9 e0       	ldi	r30, 0x09	; 9
     4f2:	f4 e1       	ldi	r31, 0x14	; 20
     4f4:	f0 93 18 14 	sts	0x1418, r31
     4f8:	e0 93 17 14 	sts	0x1417, r30
					stdout = Stream;
     4fc:	f0 93 1a 14 	sts	0x141A, r31
     500:	e0 93 19 14 	sts	0x1419, r30
				}
			
				*Stream = (FILE)FDEV_SETUP_STREAM(Serial_putchar, Serial_getchar, _FDEV_SETUP_RW);
     504:	8e e0       	ldi	r24, 0x0E	; 14
     506:	df 01       	movw	r26, r30
     508:	1d 92       	st	X+, r1
     50a:	8a 95       	dec	r24
     50c:	e9 f7       	brne	.-6      	; 0x508 <SetupHardware+0x70>
     50e:	83 e0       	ldi	r24, 0x03	; 3
     510:	80 93 0c 14 	sts	0x140C, r24
     514:	83 e3       	ldi	r24, 0x33	; 51
     516:	97 e1       	ldi	r25, 0x17	; 23
     518:	90 93 12 14 	sts	0x1412, r25
     51c:	80 93 11 14 	sts	0x1411, r24
     520:	8d e3       	ldi	r24, 0x3D	; 61
     522:	97 e1       	ldi	r25, 0x17	; 23
     524:	90 93 14 14 	sts	0x1414, r25
     528:	80 93 13 14 	sts	0x1413, r24

	/* Create a stdio stream for the serial port for stdin and stdout */
	Serial_CreateStream(NULL);
}
     52c:	08 95       	ret

0000052e <main>:
/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{
	SetupHardware();
     52e:	b4 df       	rcall	.-152    	; 0x498 <SetupHardware>

	TCP_Init();
     530:	5e d1       	rcall	.+700    	; 0x7ee <TCP_Init>
	Webserver_Init();
     532:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <Webserver_Init>
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     536:	8b b1       	in	r24, 0x0b	; 11
     538:	8f 70       	andi	r24, 0x0F	; 15
     53a:	80 61       	ori	r24, 0x10	; 16
     53c:	8b b9       	out	0x0b, r24	; 11

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
	sei();
     53e:	78 94       	sei

	for (;;)
	{
		if (RNDIS_Device_IsPacketReceived(&Ethernet_RNDIS_Interface))
     540:	88 e1       	ldi	r24, 0x18	; 24
     542:	91 e0       	ldi	r25, 0x01	; 1
     544:	0e 94 f1 12 	call	0x25e2	; 0x25e2 <RNDIS_Device_IsPacketReceived>
     548:	88 23       	and	r24, r24
     54a:	31 f1       	breq	.+76     	; 0x598 <main+0x6a>
     54c:	8b b1       	in	r24, 0x0b	; 11
     54e:	8f 70       	andi	r24, 0x0F	; 15
     550:	80 62       	ori	r24, 0x20	; 32
     552:	8b b9       	out	0x0b, r24	; 11
		{
			LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
			
			RNDIS_Device_ReadPacket(&Ethernet_RNDIS_Interface, &FrameIN.FrameData, &FrameIN.FrameLength);
     554:	88 e1       	ldi	r24, 0x18	; 24
     556:	91 e0       	ldi	r25, 0x01	; 1
     558:	68 ef       	ldi	r22, 0xF8	; 248
     55a:	71 e0       	ldi	r23, 0x01	; 1
     55c:	44 ed       	ldi	r20, 0xD4	; 212
     55e:	57 e0       	ldi	r21, 0x07	; 7
     560:	0e 94 c1 13 	call	0x2782	; 0x2782 <RNDIS_Device_ReadPacket>
			Ethernet_ProcessPacket(&FrameIN, &FrameOUT);
     564:	88 ef       	ldi	r24, 0xF8	; 248
     566:	91 e0       	ldi	r25, 0x01	; 1
     568:	66 ed       	ldi	r22, 0xD6	; 214
     56a:	77 e0       	ldi	r23, 0x07	; 7
     56c:	81 d0       	rcall	.+258    	; 0x670 <Ethernet_ProcessPacket>
			
			if (FrameOUT.FrameLength)
     56e:	40 91 b2 0d 	lds	r20, 0x0DB2
     572:	50 91 b3 0d 	lds	r21, 0x0DB3
     576:	41 15       	cp	r20, r1
     578:	51 05       	cpc	r21, r1
     57a:	51 f0       	breq	.+20     	; 0x590 <main+0x62>
			{
				RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface, &FrameOUT.FrameData, FrameOUT.FrameLength);				
     57c:	88 e1       	ldi	r24, 0x18	; 24
     57e:	91 e0       	ldi	r25, 0x01	; 1
     580:	66 ed       	ldi	r22, 0xD6	; 214
     582:	77 e0       	ldi	r23, 0x07	; 7
     584:	0e 94 0b 13 	call	0x2616	; 0x2616 <RNDIS_Device_SendPacket>
				FrameOUT.FrameLength = 0;
     588:	10 92 b3 0d 	sts	0x0DB3, r1
     58c:	10 92 b2 0d 	sts	0x0DB2, r1
     590:	8b b1       	in	r24, 0x0b	; 11
     592:	8f 70       	andi	r24, 0x0F	; 15
     594:	80 66       	ori	r24, 0x60	; 96
     596:	8b b9       	out	0x0b, r24	; 11
			}
			
			LEDs_SetAllLEDs(LEDMASK_USB_READY);
		}

		TCP_TCPTask(&Ethernet_RNDIS_Interface, &FrameOUT);
     598:	88 e1       	ldi	r24, 0x18	; 24
     59a:	91 e0       	ldi	r25, 0x01	; 1
     59c:	66 ed       	ldi	r22, 0xD6	; 214
     59e:	77 e0       	ldi	r23, 0x07	; 7
     5a0:	a0 d6       	rcall	.+3392   	; 0x12e2 <TCP_TCPTask>

		RNDIS_Device_USBTask(&Ethernet_RNDIS_Interface);
     5a2:	88 e1       	ldi	r24, 0x18	; 24
     5a4:	91 e0       	ldi	r25, 0x01	; 1
     5a6:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <RNDIS_Device_USBTask>
		USB_USBTask();
     5aa:	0e 94 de 12 	call	0x25bc	; 0x25bc <USB_USBTask>
     5ae:	c8 cf       	rjmp	.-112    	; 0x540 <main+0x12>

000005b0 <CALLBACK_USB_GetDescriptor>:
 *  USB host.
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
     5b0:	da 01       	movw	r26, r20
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     5b2:	92 30       	cpi	r25, 0x02	; 2
     5b4:	49 f0       	breq	.+18     	; 0x5c8 <CALLBACK_USB_GetDescriptor+0x18>
     5b6:	93 30       	cpi	r25, 0x03	; 3
     5b8:	61 f0       	breq	.+24     	; 0x5d2 <CALLBACK_USB_GetDescriptor+0x22>
     5ba:	91 30       	cpi	r25, 0x01	; 1
     5bc:	f9 f4       	brne	.+62     	; 0x5fc <CALLBACK_USB_GetDescriptor+0x4c>
     5be:	e8 e9       	ldi	r30, 0x98	; 152
     5c0:	f0 e0       	ldi	r31, 0x00	; 0
     5c2:	22 e1       	ldi	r18, 0x12	; 18
     5c4:	30 e0       	ldi	r19, 0x00	; 0
     5c6:	1e c0       	rjmp	.+60     	; 0x604 <CALLBACK_USB_GetDescriptor+0x54>
     5c8:	ea ea       	ldi	r30, 0xAA	; 170
     5ca:	f0 e0       	ldi	r31, 0x00	; 0
     5cc:	2e e3       	ldi	r18, 0x3E	; 62
     5ce:	30 e0       	ldi	r19, 0x00	; 0
     5d0:	19 c0       	rjmp	.+50     	; 0x604 <CALLBACK_USB_GetDescriptor+0x54>
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
		case DTYPE_String:
			switch (DescriptorNumber)
     5d2:	81 30       	cpi	r24, 0x01	; 1
     5d4:	49 f0       	breq	.+18     	; 0x5e8 <CALLBACK_USB_GetDescriptor+0x38>
     5d6:	81 30       	cpi	r24, 0x01	; 1
     5d8:	18 f0       	brcs	.+6      	; 0x5e0 <CALLBACK_USB_GetDescriptor+0x30>
     5da:	82 30       	cpi	r24, 0x02	; 2
     5dc:	79 f4       	brne	.+30     	; 0x5fc <CALLBACK_USB_GetDescriptor+0x4c>
     5de:	08 c0       	rjmp	.+16     	; 0x5f0 <CALLBACK_USB_GetDescriptor+0x40>
			{
				case 0x00:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     5e0:	e8 ee       	ldi	r30, 0xE8	; 232
     5e2:	f0 e0       	ldi	r31, 0x00	; 0
     5e4:	84 91       	lpm	r24, Z+
     5e6:	07 c0       	rjmp	.+14     	; 0x5f6 <CALLBACK_USB_GetDescriptor+0x46>
					break;
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     5e8:	ec ee       	ldi	r30, 0xEC	; 236
     5ea:	f0 e0       	ldi	r31, 0x00	; 0
     5ec:	84 91       	lpm	r24, Z+
     5ee:	03 c0       	rjmp	.+6      	; 0x5f6 <CALLBACK_USB_GetDescriptor+0x46>
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     5f0:	e6 e0       	ldi	r30, 0x06	; 6
     5f2:	f1 e0       	ldi	r31, 0x01	; 1
     5f4:	84 91       	lpm	r24, Z+
     5f6:	28 2f       	mov	r18, r24
     5f8:	30 e0       	ldi	r19, 0x00	; 0
     5fa:	04 c0       	rjmp	.+8      	; 0x604 <CALLBACK_USB_GetDescriptor+0x54>
     5fc:	e0 e0       	ldi	r30, 0x00	; 0
     5fe:	f0 e0       	ldi	r31, 0x00	; 0
     600:	20 e0       	ldi	r18, 0x00	; 0
     602:	30 e0       	ldi	r19, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     604:	ed 93       	st	X+, r30
     606:	fc 93       	st	X, r31
	return Size;
}
     608:	c9 01       	movw	r24, r18
     60a:	08 95       	ret

0000060c <Ethernet_Checksum16>:
 *
 *  \return A 16-bit Ethernet checksum value
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
     60c:	cf 93       	push	r28
     60e:	df 93       	push	r29
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     610:	76 95       	lsr	r23
     612:	67 95       	ror	r22
     614:	ec 01       	movw	r28, r24
     616:	20 e0       	ldi	r18, 0x00	; 0
     618:	30 e0       	ldi	r19, 0x00	; 0
     61a:	40 e0       	ldi	r20, 0x00	; 0
     61c:	50 e0       	ldi	r21, 0x00	; 0
     61e:	e0 e0       	ldi	r30, 0x00	; 0
     620:	f0 e0       	ldi	r31, 0x00	; 0
     622:	09 c0       	rjmp	.+18     	; 0x636 <Ethernet_Checksum16+0x2a>
	  Checksum += Words[CurrWord];
     624:	89 91       	ld	r24, Y+
     626:	99 91       	ld	r25, Y+
     628:	a0 e0       	ldi	r26, 0x00	; 0
     62a:	b0 e0       	ldi	r27, 0x00	; 0
     62c:	28 0f       	add	r18, r24
     62e:	39 1f       	adc	r19, r25
     630:	4a 1f       	adc	r20, r26
     632:	5b 1f       	adc	r21, r27
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     634:	31 96       	adiw	r30, 0x01	; 1
     636:	e6 17       	cp	r30, r22
     638:	f7 07       	cpc	r31, r23
     63a:	a0 f3       	brcs	.-24     	; 0x624 <Ethernet_Checksum16+0x18>
     63c:	0b c0       	rjmp	.+22     	; 0x654 <Ethernet_Checksum16+0x48>
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     63e:	da 01       	movw	r26, r20
     640:	c9 01       	movw	r24, r18
     642:	a0 70       	andi	r26, 0x00	; 0
     644:	b0 70       	andi	r27, 0x00	; 0
     646:	9a 01       	movw	r18, r20
     648:	44 27       	eor	r20, r20
     64a:	55 27       	eor	r21, r21
     64c:	28 0f       	add	r18, r24
     64e:	39 1f       	adc	r19, r25
     650:	4a 1f       	adc	r20, r26
     652:	5b 1f       	adc	r21, r27
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
     654:	da 01       	movw	r26, r20
     656:	c9 01       	movw	r24, r18
     658:	80 70       	andi	r24, 0x00	; 0
     65a:	90 70       	andi	r25, 0x00	; 0
     65c:	00 97       	sbiw	r24, 0x00	; 0
     65e:	a1 05       	cpc	r26, r1
     660:	b1 05       	cpc	r27, r1
     662:	69 f7       	brne	.-38     	; 0x63e <Ethernet_Checksum16+0x32>
     664:	20 95       	com	r18
     666:	30 95       	com	r19
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
}
     668:	c9 01       	movw	r24, r18
     66a:	df 91       	pop	r29
     66c:	cf 91       	pop	r28
     66e:	08 95       	ret

00000670 <Ethernet_ProcessPacket>:
/** Processes an incoming Ethernet frame, and writes the appropriate response to the output Ethernet
 *  frame buffer if the sub protocol handlers create a valid response.
 */
void Ethernet_ProcessPacket(Ethernet_Frame_Info_t* const FrameIN,
                            Ethernet_Frame_Info_t* const FrameOUT)
{
     670:	0f 93       	push	r16
     672:	1f 93       	push	r17
     674:	cf 93       	push	r28
     676:	df 93       	push	r29
     678:	ec 01       	movw	r28, r24
     67a:	8b 01       	movw	r16, r22
	DecodeEthernetFrameHeader(FrameIN);
     67c:	6c d0       	rcall	.+216    	; 0x756 <DecodeEthernetFrameHeader>
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     67e:	ce 01       	movw	r24, r28
     680:	63 eb       	ldi	r22, 0xB3	; 179
     682:	71 e0       	ldi	r23, 0x01	; 1
     684:	46 e0       	ldi	r20, 0x06	; 6
     686:	50 e0       	ldi	r21, 0x00	; 0
     688:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <memcmp>
     68c:	00 97       	sbiw	r24, 0x00	; 0
     68e:	51 f0       	breq	.+20     	; 0x6a4 <Ethernet_ProcessPacket+0x34>
     690:	ce 01       	movw	r24, r28
     692:	6d eb       	ldi	r22, 0xBD	; 189
     694:	71 e0       	ldi	r23, 0x01	; 1
     696:	46 e0       	ldi	r20, 0x06	; 6
     698:	50 e0       	ldi	r21, 0x00	; 0
     69a:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <memcmp>
     69e:	00 97       	sbiw	r24, 0x00	; 0
     6a0:	09 f0       	breq	.+2      	; 0x6a4 <Ethernet_ProcessPacket+0x34>
     6a2:	50 c0       	rjmp	.+160    	; 0x744 <Ethernet_ProcessPacket+0xd4>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     6a4:	c4 52       	subi	r28, 0x24	; 36
     6a6:	da 4f       	sbci	r29, 0xFA	; 250
     6a8:	88 81       	ld	r24, Y
     6aa:	99 81       	ldd	r25, Y+1	; 0x01
     6ac:	cc 5d       	subi	r28, 0xDC	; 220
     6ae:	d5 40       	sbci	r29, 0x05	; 5

				Temp = Data.Bytes[0];
     6b0:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
     6b2:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
     6b4:	92 2f       	mov	r25, r18
     6b6:	81 50       	subi	r24, 0x01	; 1
     6b8:	96 40       	sbci	r25, 0x06	; 6
     6ba:	08 f4       	brcc	.+2      	; 0x6be <Ethernet_ProcessPacket+0x4e>
     6bc:	43 c0       	rjmp	.+134    	; 0x744 <Ethernet_ProcessPacket+0xd4>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     6be:	2c 85       	ldd	r18, Y+12	; 0x0c
     6c0:	3d 85       	ldd	r19, Y+13	; 0x0d

				Temp = Data.Bytes[0];
     6c2:	82 2f       	mov	r24, r18
				Data.Bytes[0] = Data.Bytes[1];
     6c4:	23 2f       	mov	r18, r19
				Data.Bytes[1] = Temp;
     6c6:	38 2f       	mov	r19, r24
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
		 (SwapEndian_16(FrameIN->FrameLength) > ETHERNET_VER2_MINSIZE))
	{
		/* Process the packet depending on its protocol */
		switch (SwapEndian_16(FrameINHeader->EtherType))
     6c8:	88 e0       	ldi	r24, 0x08	; 8
     6ca:	20 30       	cpi	r18, 0x00	; 0
     6cc:	38 07       	cpc	r19, r24
     6ce:	59 f0       	breq	.+22     	; 0x6e6 <Ethernet_ProcessPacket+0x76>
     6d0:	26 50       	subi	r18, 0x06	; 6
     6d2:	38 40       	sbci	r19, 0x08	; 8
     6d4:	b9 f5       	brne	.+110    	; 0x744 <Ethernet_ProcessPacket+0xd4>
		{
			case ETHERTYPE_ARP:
				RetSize = ARP_ProcessARPPacket(&FrameIN->FrameData[sizeof(Ethernet_Frame_Header_t)],
     6d6:	b8 01       	movw	r22, r16
     6d8:	62 5f       	subi	r22, 0xF2	; 242
     6da:	7f 4f       	sbci	r23, 0xFF	; 255
     6dc:	ce 01       	movw	r24, r28
     6de:	0e 96       	adiw	r24, 0x0e	; 14
     6e0:	0e 94 08 0c 	call	0x1810	; 0x1810 <ARP_ProcessARPPacket>
     6e4:	09 c0       	rjmp	.+18     	; 0x6f8 <Ethernet_ProcessPacket+0x88>
				                               &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
			case ETHERTYPE_IPV4:
				RetSize = IP_ProcessIPPacket(FrameIN,
     6e6:	be 01       	movw	r22, r28
     6e8:	62 5f       	subi	r22, 0xF2	; 242
     6ea:	7f 4f       	sbci	r23, 0xFF	; 255
     6ec:	a8 01       	movw	r20, r16
     6ee:	42 5f       	subi	r20, 0xF2	; 242
     6f0:	5f 4f       	sbci	r21, 0xFF	; 255
     6f2:	ce 01       	movw	r24, r28
     6f4:	0e 94 87 0c 	call	0x190e	; 0x190e <IP_ProcessIPPacket>
     6f8:	9c 01       	movw	r18, r24
				                             &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
		}

		/* Protocol processing routine has filled a response, complete the ethernet frame header */
		if (RetSize > 0)
     6fa:	18 16       	cp	r1, r24
     6fc:	19 06       	cpc	r1, r25
     6fe:	f4 f4       	brge	.+60     	; 0x73c <Ethernet_ProcessPacket+0xcc>
		{
			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     700:	d8 01       	movw	r26, r16
     702:	16 96       	adiw	r26, 0x06	; 6
     704:	e3 eb       	ldi	r30, 0xB3	; 179
     706:	f1 e0       	ldi	r31, 0x01	; 1
     708:	86 e0       	ldi	r24, 0x06	; 6
     70a:	01 90       	ld	r0, Z+
     70c:	0d 92       	st	X+, r0
     70e:	81 50       	subi	r24, 0x01	; 1
     710:	e1 f7       	brne	.-8      	; 0x70a <Ethernet_ProcessPacket+0x9a>
			FrameOUTHeader->Destination     = FrameINHeader->Source;
     712:	d8 01       	movw	r26, r16
     714:	fe 01       	movw	r30, r28
     716:	36 96       	adiw	r30, 0x06	; 6
     718:	86 e0       	ldi	r24, 0x06	; 6
     71a:	01 90       	ld	r0, Z+
     71c:	0d 92       	st	X+, r0
     71e:	81 50       	subi	r24, 0x01	; 1
     720:	e1 f7       	brne	.-8      	; 0x71a <Ethernet_ProcessPacket+0xaa>
			FrameOUTHeader->EtherType       = FrameINHeader->EtherType;
     722:	8c 85       	ldd	r24, Y+12	; 0x0c
     724:	9d 85       	ldd	r25, Y+13	; 0x0d
     726:	f8 01       	movw	r30, r16
     728:	95 87       	std	Z+13, r25	; 0x0d
     72a:	84 87       	std	Z+12, r24	; 0x0c

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT->FrameLength           = (sizeof(Ethernet_Frame_Header_t) + RetSize);
     72c:	04 52       	subi	r16, 0x24	; 36
     72e:	1a 4f       	sbci	r17, 0xFA	; 250
     730:	22 5f       	subi	r18, 0xF2	; 242
     732:	3f 4f       	sbci	r19, 0xFF	; 255
     734:	f8 01       	movw	r30, r16
     736:	31 83       	std	Z+1, r19	; 0x01
     738:	20 83       	st	Z, r18
     73a:	04 c0       	rjmp	.+8      	; 0x744 <Ethernet_ProcessPacket+0xd4>
		}
	}

	/* Check if the packet was processed */
	if (RetSize != NO_PROCESS)
     73c:	ff ef       	ldi	r31, 0xFF	; 255
     73e:	8f 3f       	cpi	r24, 0xFF	; 255
     740:	9f 07       	cpc	r25, r31
     742:	21 f0       	breq	.+8      	; 0x74c <Ethernet_ProcessPacket+0xdc>
	{
		/* Clear the frame buffer */
		FrameIN->FrameLength = 0;
     744:	c4 52       	subi	r28, 0x24	; 36
     746:	da 4f       	sbci	r29, 0xFA	; 250
     748:	19 82       	std	Y+1, r1	; 0x01
     74a:	18 82       	st	Y, r1
	}
}
     74c:	df 91       	pop	r29
     74e:	cf 91       	pop	r28
     750:	1f 91       	pop	r17
     752:	0f 91       	pop	r16
     754:	08 95       	ret

00000756 <DecodeEthernetFrameHeader>:
	if (SwapEndian_16(FrameINData->FrameLength) > ETHERNET_VER2_MINSIZE)
	  printf_P(PSTR("  + Protocol: 0x%04x\r\n"), SwapEndian_16(FrameHeader->EtherType));
	else
	  printf_P(PSTR("  + Protocol: UNKNOWN E1\r\n"));
	#endif
}
     756:	08 95       	ret

00000758 <DecodeARPHeader>:
		                                                ARPHeader->TPA.Octets[1],
		                                                ARPHeader->TPA.Octets[2],
		                                                ARPHeader->TPA.Octets[3]);
	}
	#endif
}
     758:	08 95       	ret

0000075a <DecodeIPHeader>:
	printf_P(PSTR("    + IP Dst: %u.%u.%u.%u\r\n"), IPHeader->DestinationAddress.Octets[0],
	                                                IPHeader->DestinationAddress.Octets[1],
	                                                IPHeader->DestinationAddress.Octets[2],
	                                                IPHeader->DestinationAddress.Octets[3]);
	#endif
}
     75a:	08 95       	ret

0000075c <DecodeICMPHeader>:
	printf_P(PSTR("    \\\r\n     ICMP\r\n"));

	printf_P(PSTR("     + Type: %u\r\n"), ICMPHeader->Type);
	printf_P(PSTR("     + Code: %u\r\n"), ICMPHeader->Code);
	#endif
}
     75c:	08 95       	ret

0000075e <DecodeTCPHeader>:
	printf_P(PSTR("     + Flags: 0x%02X\r\n"), TCPHeader->Flags);

	if (TCP_GetPortState(TCPHeader->DestinationPort) == TCP_Port_Closed)
	  printf_P(PSTR("     + NOT LISTENING ON DESTINATION PORT\r\n"));
	#endif
}
     75e:	08 95       	ret

00000760 <DecodeUDPHeader>:
	printf_P(PSTR("     + Source Port: %u\r\n"), SwapEndian_16(UDPHeader->SourcePort));
	printf_P(PSTR("     + Destination Port: %u\r\n"), SwapEndian_16(UDPHeader->DestinationPort));

	printf_P(PSTR("     + Data Length: %d\r\n"), SwapEndian_16(UDPHeader->Length));
	#endif
}
     760:	08 95       	ret

00000762 <DecodeDHCPHeader>:

		DHCPOptions += ((DHCPOptions[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptions[1] + 2));
	}

	#endif
}
     762:	08 95       	ret

00000764 <ICMP_ProcessICMPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ICMP_ProcessICMPPacket(Ethernet_Frame_Info_t* const FrameIN,
                               void* InDataStart,
                               void* OutDataStart)
{
     764:	ef 92       	push	r14
     766:	ff 92       	push	r15
     768:	0f 93       	push	r16
     76a:	1f 93       	push	r17
     76c:	cf 93       	push	r28
     76e:	df 93       	push	r29
     770:	7c 01       	movw	r14, r24
     772:	8b 01       	movw	r16, r22
     774:	ea 01       	movw	r28, r20
	ICMP_Header_t* ICMPHeaderIN  = (ICMP_Header_t*)InDataStart;
	ICMP_Header_t* ICMPHeaderOUT = (ICMP_Header_t*)OutDataStart;

	DecodeICMPHeader(InDataStart);
     776:	cb 01       	movw	r24, r22
     778:	f1 df       	rcall	.-30     	; 0x75c <DecodeICMPHeader>

	/* Determine if the ICMP packet is an echo request (ping) */
	if (ICMPHeaderIN->Type == ICMP_TYPE_ECHOREQUEST)
     77a:	f8 01       	movw	r30, r16
     77c:	80 81       	ld	r24, Z
     77e:	88 30       	cpi	r24, 0x08	; 8
     780:	19 f0       	breq	.+6      	; 0x788 <ICMP_ProcessICMPPacket+0x24>
     782:	20 e0       	ldi	r18, 0x00	; 0
     784:	30 e0       	ldi	r19, 0x00	; 0
     786:	2b c0       	rjmp	.+86     	; 0x7de <ICMP_ProcessICMPPacket+0x7a>
	{
		/* Fill out the ICMP response packet */
		ICMPHeaderOUT->Type     = ICMP_TYPE_ECHOREPLY;
     788:	18 82       	st	Y, r1
		ICMPHeaderOUT->Code     = 0;
     78a:	19 82       	std	Y+1, r1	; 0x01
		ICMPHeaderOUT->Checksum = 0;
     78c:	1b 82       	std	Y+3, r1	; 0x03
     78e:	1a 82       	std	Y+2, r1	; 0x02
		ICMPHeaderOUT->Id       = ICMPHeaderIN->Id;
     790:	f8 01       	movw	r30, r16
     792:	84 81       	ldd	r24, Z+4	; 0x04
     794:	95 81       	ldd	r25, Z+5	; 0x05
     796:	9d 83       	std	Y+5, r25	; 0x05
     798:	8c 83       	std	Y+4, r24	; 0x04
		ICMPHeaderOUT->Sequence = ICMPHeaderIN->Sequence;
     79a:	86 81       	ldd	r24, Z+6	; 0x06
     79c:	97 81       	ldd	r25, Z+7	; 0x07
     79e:	9f 83       	std	Y+7, r25	; 0x07
     7a0:	8e 83       	std	Y+6, r24	; 0x06

		intptr_t DataSize = FrameIN->FrameLength - ((((intptr_t)InDataStart + sizeof(ICMP_Header_t)) - (intptr_t)FrameIN->FrameData));
     7a2:	b8 01       	movw	r22, r16
     7a4:	68 5f       	subi	r22, 0xF8	; 248
     7a6:	7f 4f       	sbci	r23, 0xFF	; 255
     7a8:	8c ed       	ldi	r24, 0xDC	; 220
     7aa:	95 e0       	ldi	r25, 0x05	; 5
     7ac:	e8 0e       	add	r14, r24
     7ae:	f9 1e       	adc	r15, r25
     7b0:	f7 01       	movw	r30, r14
     7b2:	80 81       	ld	r24, Z
     7b4:	91 81       	ldd	r25, Z+1	; 0x01
     7b6:	87 01       	movw	r16, r14
     7b8:	0c 5d       	subi	r16, 0xDC	; 220
     7ba:	15 40       	sbci	r17, 0x05	; 5
     7bc:	08 0f       	add	r16, r24
     7be:	19 1f       	adc	r17, r25
     7c0:	06 1b       	sub	r16, r22
     7c2:	17 0b       	sbc	r17, r23

		/* Copy the remaining payload to the response - echo requests should echo back any sent data */
		memmove(&((uint8_t*)OutDataStart)[sizeof(ICMP_Header_t)],
     7c4:	ce 01       	movw	r24, r28
     7c6:	08 96       	adiw	r24, 0x08	; 8
     7c8:	a8 01       	movw	r20, r16
     7ca:	0e 94 8f 17 	call	0x2f1e	; 0x2f1e <memmove>
		        &((uint8_t*)InDataStart)[sizeof(ICMP_Header_t)],
			    DataSize);

		ICMPHeaderOUT->Checksum = Ethernet_Checksum16(ICMPHeaderOUT, (DataSize + sizeof(ICMP_Header_t)));
     7ce:	08 5f       	subi	r16, 0xF8	; 248
     7d0:	1f 4f       	sbci	r17, 0xFF	; 255
     7d2:	ce 01       	movw	r24, r28
     7d4:	b8 01       	movw	r22, r16
     7d6:	1a df       	rcall	.-460    	; 0x60c <Ethernet_Checksum16>
     7d8:	9b 83       	std	Y+3, r25	; 0x03
     7da:	8a 83       	std	Y+2, r24	; 0x02

		/* Return the size of the response so far */
		return (DataSize + sizeof(ICMP_Header_t));
     7dc:	98 01       	movw	r18, r16
	}

	return NO_RESPONSE;
}
     7de:	c9 01       	movw	r24, r18
     7e0:	df 91       	pop	r29
     7e2:	cf 91       	pop	r28
     7e4:	1f 91       	pop	r17
     7e6:	0f 91       	pop	r16
     7e8:	ff 90       	pop	r15
     7ea:	ef 90       	pop	r14
     7ec:	08 95       	ret

000007ee <TCP_Init>:
 */
void TCP_Init(void)
{
	/* Initialize the port state table with all CLOSED entries */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	  PortStateTable[PTableEntry].State = TCP_Port_Closed;
     7ee:	10 92 f9 13 	sts	0x13F9, r1

	/* Initialize the connection table with all CLOSED entries */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	  ConnectionStateTable[CSTableEntry].State = TCP_Connection_Closed;
     7f2:	8a e0       	ldi	r24, 0x0A	; 10
     7f4:	80 93 ca 0f 	sts	0x0FCA, r24
     7f8:	80 93 e0 11 	sts	0x11E0, r24
     7fc:	80 93 f6 13 	sts	0x13F6, r24
}
     800:	08 95       	ret

00000802 <TCP_SetPortState>:
 *  \return Boolean true if the port state was set, false otherwise (no more space in the port state table)
 */
bool TCP_SetPortState(const uint16_t Port,
                      const uint8_t State,
                      void (*Handler)(TCP_ConnectionState_t*, TCP_ConnectionBuffer_t*))
{
     802:	9c 01       	movw	r18, r24

	/* Check to see if the port entry is already in the port state table */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_TCP_CONNECTIONS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, update it if found */
		if (PortStateTable[PTableEntry].Port == Port)
     804:	80 91 f7 13 	lds	r24, 0x13F7
     808:	90 91 f8 13 	lds	r25, 0x13F8
     80c:	82 17       	cp	r24, r18
     80e:	93 07       	cpc	r25, r19
     810:	19 f4       	brne	.+6      	; 0x818 <TCP_SetPortState+0x16>
     812:	80 e0       	ldi	r24, 0x00	; 0
     814:	90 e0       	ldi	r25, 0x00	; 0
     816:	13 c0       	rjmp	.+38     	; 0x83e <TCP_SetPortState+0x3c>
     818:	80 91 fc 13 	lds	r24, 0x13FC
     81c:	90 91 fd 13 	lds	r25, 0x13FD
     820:	82 17       	cp	r24, r18
     822:	93 07       	cpc	r25, r19
     824:	19 f4       	brne	.+6      	; 0x82c <TCP_SetPortState+0x2a>
     826:	81 e0       	ldi	r24, 0x01	; 1
     828:	90 e0       	ldi	r25, 0x00	; 0
     82a:	09 c0       	rjmp	.+18     	; 0x83e <TCP_SetPortState+0x3c>
     82c:	80 91 01 14 	lds	r24, 0x1401
     830:	90 91 02 14 	lds	r25, 0x1402
     834:	82 17       	cp	r24, r18
     836:	93 07       	cpc	r25, r19
     838:	79 f4       	brne	.+30     	; 0x858 <TCP_SetPortState+0x56>
     83a:	82 e0       	ldi	r24, 0x02	; 2
     83c:	90 e0       	ldi	r25, 0x00	; 0
		{
			PortStateTable[PTableEntry].State = State;
     83e:	fc 01       	movw	r30, r24
     840:	ee 0f       	add	r30, r30
     842:	ff 1f       	adc	r31, r31
     844:	ee 0f       	add	r30, r30
     846:	ff 1f       	adc	r31, r31
     848:	e8 0f       	add	r30, r24
     84a:	f9 1f       	adc	r31, r25
     84c:	e9 50       	subi	r30, 0x09	; 9
     84e:	fc 4e       	sbci	r31, 0xEC	; 236
     850:	62 83       	std	Z+2, r22	; 0x02
			PortStateTable[PTableEntry].ApplicationHandler = Handler;
     852:	54 83       	std	Z+4, r21	; 0x04
     854:	43 83       	std	Z+3, r20	; 0x03
     856:	02 c0       	rjmp	.+4      	; 0x85c <TCP_SetPortState+0x5a>
			return true;
		}
	}

	/* Check if trying to open the port -- if so we need to find an unused (closed) entry and replace it */
	if (State == TCP_Port_Open)
     858:	61 30       	cpi	r22, 0x01	; 1
     85a:	11 f0       	breq	.+4      	; 0x860 <TCP_SetPortState+0x5e>
     85c:	81 e0       	ldi	r24, 0x01	; 1
     85e:	08 95       	ret
	{
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_TCP_CONNECTIONS; PTableEntry++)
		{
			/* Find a closed port entry in the table, change it to the given port and state */
			if (PortStateTable[PTableEntry].State == TCP_Port_Closed)
     860:	80 91 f9 13 	lds	r24, 0x13F9
     864:	88 23       	and	r24, r24
     866:	19 f4       	brne	.+6      	; 0x86e <TCP_SetPortState+0x6c>
     868:	80 e0       	ldi	r24, 0x00	; 0
     86a:	90 e0       	ldi	r25, 0x00	; 0
     86c:	0f c0       	rjmp	.+30     	; 0x88c <TCP_SetPortState+0x8a>
     86e:	80 91 fe 13 	lds	r24, 0x13FE
     872:	88 23       	and	r24, r24
     874:	19 f4       	brne	.+6      	; 0x87c <TCP_SetPortState+0x7a>
     876:	81 e0       	ldi	r24, 0x01	; 1
     878:	90 e0       	ldi	r25, 0x00	; 0
     87a:	08 c0       	rjmp	.+16     	; 0x88c <TCP_SetPortState+0x8a>
     87c:	80 91 03 14 	lds	r24, 0x1403
     880:	88 23       	and	r24, r24
     882:	11 f0       	breq	.+4      	; 0x888 <TCP_SetPortState+0x86>
     884:	80 e0       	ldi	r24, 0x00	; 0
     886:	08 95       	ret
     888:	82 e0       	ldi	r24, 0x02	; 2
     88a:	90 e0       	ldi	r25, 0x00	; 0
			{
				PortStateTable[PTableEntry].Port  = Port;
     88c:	fc 01       	movw	r30, r24
     88e:	ee 0f       	add	r30, r30
     890:	ff 1f       	adc	r31, r31
     892:	ee 0f       	add	r30, r30
     894:	ff 1f       	adc	r31, r31
     896:	e8 0f       	add	r30, r24
     898:	f9 1f       	adc	r31, r25
     89a:	e9 50       	subi	r30, 0x09	; 9
     89c:	fc 4e       	sbci	r31, 0xEC	; 236
     89e:	31 83       	std	Z+1, r19	; 0x01
     8a0:	20 83       	st	Z, r18
				PortStateTable[PTableEntry].State = State;
     8a2:	81 e0       	ldi	r24, 0x01	; 1
     8a4:	82 83       	std	Z+2, r24	; 0x02
				PortStateTable[PTableEntry].ApplicationHandler = Handler;
     8a6:	54 83       	std	Z+4, r21	; 0x04
     8a8:	43 83       	std	Z+3, r20	; 0x03
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
	}
}
     8aa:	08 95       	ret

000008ac <TCP_GetPortState>:
 *  \param[in] Port  TCP port whose state is to be retrieved, given in big-endian
 *
 *  \return A value from the TCP_PortStates_t enum
 */
uint8_t TCP_GetPortState(const uint16_t Port)
{
     8ac:	9c 01       	movw	r18, r24
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t PTableEntry = 0; PTableEntry < MAX_TCP_CONNECTIONS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, return the port status if found */
		if (PortStateTable[PTableEntry].Port == Port)
     8ae:	80 91 f7 13 	lds	r24, 0x13F7
     8b2:	90 91 f8 13 	lds	r25, 0x13F8
     8b6:	82 17       	cp	r24, r18
     8b8:	93 07       	cpc	r25, r19
     8ba:	19 f4       	brne	.+6      	; 0x8c2 <TCP_GetPortState+0x16>
     8bc:	80 e0       	ldi	r24, 0x00	; 0
     8be:	90 e0       	ldi	r25, 0x00	; 0
     8c0:	15 c0       	rjmp	.+42     	; 0x8ec <TCP_GetPortState+0x40>
     8c2:	80 91 fc 13 	lds	r24, 0x13FC
     8c6:	90 91 fd 13 	lds	r25, 0x13FD
     8ca:	82 17       	cp	r24, r18
     8cc:	93 07       	cpc	r25, r19
     8ce:	19 f4       	brne	.+6      	; 0x8d6 <TCP_GetPortState+0x2a>
     8d0:	81 e0       	ldi	r24, 0x01	; 1
     8d2:	90 e0       	ldi	r25, 0x00	; 0
     8d4:	0b c0       	rjmp	.+22     	; 0x8ec <TCP_GetPortState+0x40>
     8d6:	80 91 01 14 	lds	r24, 0x1401
     8da:	90 91 02 14 	lds	r25, 0x1402
     8de:	82 17       	cp	r24, r18
     8e0:	93 07       	cpc	r25, r19
     8e2:	11 f0       	breq	.+4      	; 0x8e8 <TCP_GetPortState+0x3c>
     8e4:	80 e0       	ldi	r24, 0x00	; 0
     8e6:	08 95       	ret
     8e8:	82 e0       	ldi	r24, 0x02	; 2
     8ea:	90 e0       	ldi	r25, 0x00	; 0
		  return PortStateTable[PTableEntry].State;
     8ec:	fc 01       	movw	r30, r24
     8ee:	ee 0f       	add	r30, r30
     8f0:	ff 1f       	adc	r31, r31
     8f2:	ee 0f       	add	r30, r30
     8f4:	ff 1f       	adc	r31, r31
     8f6:	e8 0f       	add	r30, r24
     8f8:	f9 1f       	adc	r31, r25
     8fa:	e9 50       	subi	r30, 0x09	; 9
     8fc:	fc 4e       	sbci	r31, 0xEC	; 236
     8fe:	82 81       	ldd	r24, Z+2	; 0x02
	}

	/* Port not in table, assume closed */
	return TCP_Port_Closed;
}
     900:	08 95       	ret

00000902 <TCP_Checksum16>:
 */
static uint16_t TCP_Checksum16(void* TCPHeaderOutStart,
                               const IP_Address_t SourceAddress,
                               const IP_Address_t DestinationAddress,
                               const uint16_t TCPOutSize)
{
     902:	2f 92       	push	r2
     904:	3f 92       	push	r3
     906:	4f 92       	push	r4
     908:	5f 92       	push	r5
     90a:	6f 92       	push	r6
     90c:	7f 92       	push	r7
     90e:	8f 92       	push	r8
     910:	9f 92       	push	r9
     912:	af 92       	push	r10
     914:	bf 92       	push	r11
     916:	cf 92       	push	r12
     918:	df 92       	push	r13
     91a:	ef 92       	push	r14
     91c:	ff 92       	push	r15
     91e:	0f 93       	push	r16
     920:	1f 93       	push	r17
     922:	df 93       	push	r29
     924:	cf 93       	push	r28
     926:	cd b7       	in	r28, 0x3d	; 61
     928:	de b7       	in	r29, 0x3e	; 62
     92a:	2a 97       	sbiw	r28, 0x0a	; 10
     92c:	0f b6       	in	r0, 0x3f	; 63
     92e:	f8 94       	cli
     930:	de bf       	out	0x3e, r29	; 62
     932:	0f be       	out	0x3f, r0	; 63
     934:	cd bf       	out	0x3d, r28	; 61
     936:	9a 87       	std	Y+10, r25	; 0x0a
     938:	89 87       	std	Y+9, r24	; 0x09
     93a:	3a 01       	movw	r6, r20
     93c:	49 83       	std	Y+1, r20	; 0x01
     93e:	5a 83       	std	Y+2, r21	; 0x02
     940:	6b 83       	std	Y+3, r22	; 0x03
     942:	7c 83       	std	Y+4, r23	; 0x04
     944:	58 01       	movw	r10, r16
     946:	0d 83       	std	Y+5, r16	; 0x05
     948:	1e 83       	std	Y+6, r17	; 0x06
     94a:	2f 83       	std	Y+7, r18	; 0x07
     94c:	38 87       	std	Y+8, r19	; 0x08
     94e:	b7 01       	movw	r22, r14
	uint32_t Checksum = 0;

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)&SourceAddress)[0];
     950:	88 24       	eor	r8, r8
     952:	99 24       	eor	r9, r9
	Checksum += ((uint16_t*)&SourceAddress)[1];
     954:	eb 80       	ldd	r14, Y+3	; 0x03
     956:	fc 80       	ldd	r15, Y+4	; 0x04
     958:	00 e0       	ldi	r16, 0x00	; 0
     95a:	10 e0       	ldi	r17, 0x00	; 0
	Checksum += ((uint16_t*)&DestinationAddress)[0];
     95c:	cc 24       	eor	r12, r12
     95e:	dd 24       	eor	r13, r13
	Checksum += ((uint16_t*)&DestinationAddress)[1];
     960:	2f 81       	ldd	r18, Y+7	; 0x07
     962:	38 85       	ldd	r19, Y+8	; 0x08
     964:	40 e0       	ldi	r20, 0x00	; 0
     966:	50 e0       	ldi	r21, 0x00	; 0
				} Data;

				Data.Word = Word;

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
     968:	87 2f       	mov	r24, r23
				Data.Bytes[1] = Temp;
     96a:	96 2f       	mov	r25, r22

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)&SourceAddress)[0];
	Checksum += ((uint16_t*)&SourceAddress)[1];
     96c:	1c 01       	movw	r2, r24
     96e:	44 24       	eor	r4, r4
     970:	55 24       	eor	r5, r5
     972:	80 e0       	ldi	r24, 0x00	; 0
     974:	96 e0       	ldi	r25, 0x06	; 6
     976:	a0 e0       	ldi	r26, 0x00	; 0
     978:	b0 e0       	ldi	r27, 0x00	; 0
     97a:	28 0e       	add	r2, r24
     97c:	39 1e       	adc	r3, r25
     97e:	4a 1e       	adc	r4, r26
     980:	5b 1e       	adc	r5, r27
	Checksum += ((uint16_t*)&DestinationAddress)[0];
     982:	26 0c       	add	r2, r6
     984:	37 1c       	adc	r3, r7
     986:	48 1c       	adc	r4, r8
     988:	59 1c       	adc	r5, r9
	Checksum += ((uint16_t*)&DestinationAddress)[1];
     98a:	2a 0c       	add	r2, r10
     98c:	3b 1c       	adc	r3, r11
     98e:	4c 1c       	adc	r4, r12
     990:	5d 1c       	adc	r5, r13
	Checksum += SwapEndian_16(PROTOCOL_TCP);
     992:	2e 0c       	add	r2, r14
     994:	3f 1c       	adc	r3, r15
     996:	40 1e       	adc	r4, r16
     998:	51 1e       	adc	r5, r17
	Checksum += SwapEndian_16(TCPOutSize);
     99a:	22 0e       	add	r2, r18
     99c:	33 1e       	adc	r3, r19
     99e:	44 1e       	adc	r4, r20
     9a0:	55 1e       	adc	r5, r21

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     9a2:	fb 01       	movw	r30, r22
     9a4:	f6 95       	lsr	r31
     9a6:	e7 95       	ror	r30
     9a8:	49 85       	ldd	r20, Y+9	; 0x09
     9aa:	5a 85       	ldd	r21, Y+10	; 0x0a
     9ac:	20 e0       	ldi	r18, 0x00	; 0
     9ae:	30 e0       	ldi	r19, 0x00	; 0
     9b0:	0c c0       	rjmp	.+24     	; 0x9ca <TCP_Checksum16+0xc8>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];
     9b2:	da 01       	movw	r26, r20
     9b4:	8d 91       	ld	r24, X+
     9b6:	9d 91       	ld	r25, X+
     9b8:	ad 01       	movw	r20, r26
     9ba:	a0 e0       	ldi	r26, 0x00	; 0
     9bc:	b0 e0       	ldi	r27, 0x00	; 0
     9be:	28 0e       	add	r2, r24
     9c0:	39 1e       	adc	r3, r25
     9c2:	4a 1e       	adc	r4, r26
     9c4:	5b 1e       	adc	r5, r27
	Checksum += ((uint16_t*)&DestinationAddress)[0];
	Checksum += ((uint16_t*)&DestinationAddress)[1];
	Checksum += SwapEndian_16(PROTOCOL_TCP);
	Checksum += SwapEndian_16(TCPOutSize);

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     9c6:	2f 5f       	subi	r18, 0xFF	; 255
     9c8:	3f 4f       	sbci	r19, 0xFF	; 255
     9ca:	2e 17       	cp	r18, r30
     9cc:	3f 07       	cpc	r19, r31
     9ce:	88 f3       	brcs	.-30     	; 0x9b2 <TCP_Checksum16+0xb0>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
     9d0:	60 ff       	sbrs	r22, 0
     9d2:	17 c0       	rjmp	.+46     	; 0xa02 <TCP_Checksum16+0x100>
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);
     9d4:	ee 0f       	add	r30, r30
     9d6:	ff 1f       	adc	r31, r31
     9d8:	89 85       	ldd	r24, Y+9	; 0x09
     9da:	9a 85       	ldd	r25, Y+10	; 0x0a
     9dc:	e8 0f       	add	r30, r24
     9de:	f9 1f       	adc	r31, r25
     9e0:	80 81       	ld	r24, Z
     9e2:	28 0e       	add	r2, r24
     9e4:	31 1c       	adc	r3, r1
     9e6:	41 1c       	adc	r4, r1
     9e8:	51 1c       	adc	r5, r1
     9ea:	0b c0       	rjmp	.+22     	; 0xa02 <TCP_Checksum16+0x100>

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     9ec:	d2 01       	movw	r26, r4
     9ee:	c1 01       	movw	r24, r2
     9f0:	a0 70       	andi	r26, 0x00	; 0
     9f2:	b0 70       	andi	r27, 0x00	; 0
     9f4:	12 01       	movw	r2, r4
     9f6:	44 24       	eor	r4, r4
     9f8:	55 24       	eor	r5, r5
     9fa:	28 0e       	add	r2, r24
     9fc:	39 1e       	adc	r3, r25
     9fe:	4a 1e       	adc	r4, r26
     a00:	5b 1e       	adc	r5, r27
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);

	while (Checksum & 0xFFFF0000)
     a02:	d2 01       	movw	r26, r4
     a04:	c1 01       	movw	r24, r2
     a06:	80 70       	andi	r24, 0x00	; 0
     a08:	90 70       	andi	r25, 0x00	; 0
     a0a:	00 97       	sbiw	r24, 0x00	; 0
     a0c:	a1 05       	cpc	r26, r1
     a0e:	b1 05       	cpc	r27, r1
     a10:	69 f7       	brne	.-38     	; 0x9ec <TCP_Checksum16+0xea>
     a12:	91 01       	movw	r18, r2
     a14:	20 95       	com	r18
     a16:	30 95       	com	r19
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
}
     a18:	c9 01       	movw	r24, r18
     a1a:	2a 96       	adiw	r28, 0x0a	; 10
     a1c:	0f b6       	in	r0, 0x3f	; 63
     a1e:	f8 94       	cli
     a20:	de bf       	out	0x3e, r29	; 62
     a22:	0f be       	out	0x3f, r0	; 63
     a24:	cd bf       	out	0x3d, r28	; 61
     a26:	cf 91       	pop	r28
     a28:	df 91       	pop	r29
     a2a:	1f 91       	pop	r17
     a2c:	0f 91       	pop	r16
     a2e:	ff 90       	pop	r15
     a30:	ef 90       	pop	r14
     a32:	df 90       	pop	r13
     a34:	cf 90       	pop	r12
     a36:	bf 90       	pop	r11
     a38:	af 90       	pop	r10
     a3a:	9f 90       	pop	r9
     a3c:	8f 90       	pop	r8
     a3e:	7f 90       	pop	r7
     a40:	6f 90       	pop	r6
     a42:	5f 90       	pop	r5
     a44:	4f 90       	pop	r4
     a46:	3f 90       	pop	r3
     a48:	2f 90       	pop	r2
     a4a:	08 95       	ret

00000a4c <TCP_GetConnectionInfo>:
 *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 */
TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
                                            const IP_Address_t RemoteAddress,
                                            const uint16_t RemotePort)
{
     a4c:	4f 92       	push	r4
     a4e:	5f 92       	push	r5
     a50:	6f 92       	push	r6
     a52:	7f 92       	push	r7
     a54:	8f 92       	push	r8
     a56:	9f 92       	push	r9
     a58:	af 92       	push	r10
     a5a:	bf 92       	push	r11
     a5c:	cf 92       	push	r12
     a5e:	df 92       	push	r13
     a60:	ef 92       	push	r14
     a62:	ff 92       	push	r15
     a64:	0f 93       	push	r16
     a66:	1f 93       	push	r17
     a68:	df 93       	push	r29
     a6a:	cf 93       	push	r28
     a6c:	00 d0       	rcall	.+0      	; 0xa6e <TCP_GetConnectionInfo+0x22>
     a6e:	00 d0       	rcall	.+0      	; 0xa70 <TCP_GetConnectionInfo+0x24>
     a70:	cd b7       	in	r28, 0x3d	; 61
     a72:	de b7       	in	r29, 0x3e	; 62
     a74:	4c 01       	movw	r8, r24
     a76:	49 83       	std	Y+1, r20	; 0x01
     a78:	5a 83       	std	Y+2, r21	; 0x02
     a7a:	6b 83       	std	Y+3, r22	; 0x03
     a7c:	7c 83       	std	Y+4, r23	; 0x04
     a7e:	59 01       	movw	r10, r18
     a80:	25 eb       	ldi	r18, 0xB5	; 181
     a82:	e2 2e       	mov	r14, r18
     a84:	2d e0       	ldi	r18, 0x0D	; 13
     a86:	f2 2e       	mov	r15, r18
     a88:	00 e0       	ldi	r16, 0x00	; 0
     a8a:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     a8c:	96 e1       	ldi	r25, 0x16	; 22
     a8e:	49 2e       	mov	r4, r25
     a90:	92 e0       	ldi	r25, 0x02	; 2
     a92:	59 2e       	mov	r5, r25
     a94:	3e 01       	movw	r6, r28
     a96:	08 94       	sec
     a98:	61 1c       	adc	r6, r1
     a9a:	71 1c       	adc	r7, r1
     a9c:	f7 01       	movw	r30, r14
     a9e:	80 81       	ld	r24, Z
     aa0:	91 81       	ldd	r25, Z+1	; 0x01
     aa2:	88 15       	cp	r24, r8
     aa4:	99 05       	cpc	r25, r9
     aa6:	d9 f4       	brne	.+54     	; 0xade <TCP_GetConnectionInfo+0x92>
     aa8:	04 9d       	mul	r16, r4
     aaa:	60 01       	movw	r12, r0
     aac:	05 9d       	mul	r16, r5
     aae:	d0 0c       	add	r13, r0
     ab0:	14 9d       	mul	r17, r4
     ab2:	d0 0c       	add	r13, r0
     ab4:	11 24       	eor	r1, r1
     ab6:	c6 01       	movw	r24, r12
     ab8:	87 54       	subi	r24, 0x47	; 71
     aba:	92 4f       	sbci	r25, 0xF2	; 242
     abc:	b3 01       	movw	r22, r6
     abe:	44 e0       	ldi	r20, 0x04	; 4
     ac0:	50 e0       	ldi	r21, 0x00	; 0
     ac2:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <memcmp>
     ac6:	00 97       	sbiw	r24, 0x00	; 0
     ac8:	51 f4       	brne	.+20     	; 0xade <TCP_GetConnectionInfo+0x92>
     aca:	f7 01       	movw	r30, r14
     acc:	82 81       	ldd	r24, Z+2	; 0x02
     ace:	93 81       	ldd	r25, Z+3	; 0x03
     ad0:	8a 15       	cp	r24, r10
     ad2:	9b 05       	cpc	r25, r11
     ad4:	21 f4       	brne	.+8      	; 0xade <TCP_GetConnectionInfo+0x92>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			return &ConnectionStateTable[CSTableEntry].Info;
     ad6:	96 01       	movw	r18, r12
     ad8:	23 54       	subi	r18, 0x43	; 67
     ada:	32 4f       	sbci	r19, 0xF2	; 242
     adc:	0b c0       	rjmp	.+22     	; 0xaf4 <TCP_GetConnectionInfo+0xa8>
     ade:	0f 5f       	subi	r16, 0xFF	; 255
     ae0:	1f 4f       	sbci	r17, 0xFF	; 255
     ae2:	86 e1       	ldi	r24, 0x16	; 22
     ae4:	92 e0       	ldi	r25, 0x02	; 2
     ae6:	e8 0e       	add	r14, r24
     ae8:	f9 1e       	adc	r15, r25
                                            const IP_Address_t RemoteAddress,
                                            const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     aea:	03 30       	cpi	r16, 0x03	; 3
     aec:	11 05       	cpc	r17, r1
     aee:	b1 f6       	brne	.-84     	; 0xa9c <TCP_GetConnectionInfo+0x50>
     af0:	20 e0       	ldi	r18, 0x00	; 0
     af2:	30 e0       	ldi	r19, 0x00	; 0
			return &ConnectionStateTable[CSTableEntry].Info;
		}
	}

	return NULL;
}
     af4:	c9 01       	movw	r24, r18
     af6:	0f 90       	pop	r0
     af8:	0f 90       	pop	r0
     afa:	0f 90       	pop	r0
     afc:	0f 90       	pop	r0
     afe:	cf 91       	pop	r28
     b00:	df 91       	pop	r29
     b02:	1f 91       	pop	r17
     b04:	0f 91       	pop	r16
     b06:	ff 90       	pop	r15
     b08:	ef 90       	pop	r14
     b0a:	df 90       	pop	r13
     b0c:	cf 90       	pop	r12
     b0e:	bf 90       	pop	r11
     b10:	af 90       	pop	r10
     b12:	9f 90       	pop	r9
     b14:	8f 90       	pop	r8
     b16:	7f 90       	pop	r7
     b18:	6f 90       	pop	r6
     b1a:	5f 90       	pop	r5
     b1c:	4f 90       	pop	r4
     b1e:	08 95       	ret

00000b20 <TCP_GetConnectionState>:
 *  \return A value from the TCP_ConnectionStates_t enum
 */
uint8_t TCP_GetConnectionState(const uint16_t Port,
                               const IP_Address_t RemoteAddress,
                               const uint16_t RemotePort)
{
     b20:	4f 92       	push	r4
     b22:	5f 92       	push	r5
     b24:	6f 92       	push	r6
     b26:	7f 92       	push	r7
     b28:	8f 92       	push	r8
     b2a:	9f 92       	push	r9
     b2c:	af 92       	push	r10
     b2e:	bf 92       	push	r11
     b30:	cf 92       	push	r12
     b32:	df 92       	push	r13
     b34:	ef 92       	push	r14
     b36:	ff 92       	push	r15
     b38:	0f 93       	push	r16
     b3a:	1f 93       	push	r17
     b3c:	df 93       	push	r29
     b3e:	cf 93       	push	r28
     b40:	00 d0       	rcall	.+0      	; 0xb42 <TCP_GetConnectionState+0x22>
     b42:	00 d0       	rcall	.+0      	; 0xb44 <TCP_GetConnectionState+0x24>
     b44:	cd b7       	in	r28, 0x3d	; 61
     b46:	de b7       	in	r29, 0x3e	; 62
     b48:	4c 01       	movw	r8, r24
     b4a:	49 83       	std	Y+1, r20	; 0x01
     b4c:	5a 83       	std	Y+2, r21	; 0x02
     b4e:	6b 83       	std	Y+3, r22	; 0x03
     b50:	7c 83       	std	Y+4, r23	; 0x04
     b52:	59 01       	movw	r10, r18
     b54:	45 eb       	ldi	r20, 0xB5	; 181
     b56:	e4 2e       	mov	r14, r20
     b58:	4d e0       	ldi	r20, 0x0D	; 13
     b5a:	f4 2e       	mov	r15, r20
     b5c:	00 e0       	ldi	r16, 0x00	; 0
     b5e:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     b60:	36 e1       	ldi	r19, 0x16	; 22
     b62:	43 2e       	mov	r4, r19
     b64:	32 e0       	ldi	r19, 0x02	; 2
     b66:	53 2e       	mov	r5, r19
     b68:	3e 01       	movw	r6, r28
     b6a:	08 94       	sec
     b6c:	61 1c       	adc	r6, r1
     b6e:	71 1c       	adc	r7, r1
     b70:	f7 01       	movw	r30, r14
     b72:	80 81       	ld	r24, Z
     b74:	91 81       	ldd	r25, Z+1	; 0x01
     b76:	88 15       	cp	r24, r8
     b78:	99 05       	cpc	r25, r9
     b7a:	e1 f4       	brne	.+56     	; 0xbb4 <TCP_GetConnectionState+0x94>
     b7c:	04 9d       	mul	r16, r4
     b7e:	60 01       	movw	r12, r0
     b80:	05 9d       	mul	r16, r5
     b82:	d0 0c       	add	r13, r0
     b84:	14 9d       	mul	r17, r4
     b86:	d0 0c       	add	r13, r0
     b88:	11 24       	eor	r1, r1
     b8a:	c6 01       	movw	r24, r12
     b8c:	87 54       	subi	r24, 0x47	; 71
     b8e:	92 4f       	sbci	r25, 0xF2	; 242
     b90:	b3 01       	movw	r22, r6
     b92:	44 e0       	ldi	r20, 0x04	; 4
     b94:	50 e0       	ldi	r21, 0x00	; 0
     b96:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <memcmp>
     b9a:	00 97       	sbiw	r24, 0x00	; 0
     b9c:	59 f4       	brne	.+22     	; 0xbb4 <TCP_GetConnectionState+0x94>
     b9e:	f7 01       	movw	r30, r14
     ba0:	82 81       	ldd	r24, Z+2	; 0x02
     ba2:	93 81       	ldd	r25, Z+3	; 0x03
     ba4:	8a 15       	cp	r24, r10
     ba6:	9b 05       	cpc	r25, r11
     ba8:	29 f4       	brne	.+10     	; 0xbb4 <TCP_GetConnectionState+0x94>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)

		{
			return ConnectionStateTable[CSTableEntry].State;
     baa:	f6 01       	movw	r30, r12
     bac:	e6 53       	subi	r30, 0x36	; 54
     bae:	f0 4f       	sbci	r31, 0xF0	; 240
     bb0:	80 81       	ld	r24, Z
     bb2:	0a c0       	rjmp	.+20     	; 0xbc8 <TCP_GetConnectionState+0xa8>
     bb4:	0f 5f       	subi	r16, 0xFF	; 255
     bb6:	1f 4f       	sbci	r17, 0xFF	; 255
     bb8:	86 e1       	ldi	r24, 0x16	; 22
     bba:	92 e0       	ldi	r25, 0x02	; 2
     bbc:	e8 0e       	add	r14, r24
     bbe:	f9 1e       	adc	r15, r25
                               const IP_Address_t RemoteAddress,
                               const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     bc0:	03 30       	cpi	r16, 0x03	; 3
     bc2:	11 05       	cpc	r17, r1
     bc4:	a9 f6       	brne	.-86     	; 0xb70 <TCP_GetConnectionState+0x50>
     bc6:	8a e0       	ldi	r24, 0x0A	; 10
			return ConnectionStateTable[CSTableEntry].State;
		}
	}

	return TCP_Connection_Closed;
}
     bc8:	0f 90       	pop	r0
     bca:	0f 90       	pop	r0
     bcc:	0f 90       	pop	r0
     bce:	0f 90       	pop	r0
     bd0:	cf 91       	pop	r28
     bd2:	df 91       	pop	r29
     bd4:	1f 91       	pop	r17
     bd6:	0f 91       	pop	r16
     bd8:	ff 90       	pop	r15
     bda:	ef 90       	pop	r14
     bdc:	df 90       	pop	r13
     bde:	cf 90       	pop	r12
     be0:	bf 90       	pop	r11
     be2:	af 90       	pop	r10
     be4:	9f 90       	pop	r9
     be6:	8f 90       	pop	r8
     be8:	7f 90       	pop	r7
     bea:	6f 90       	pop	r6
     bec:	5f 90       	pop	r5
     bee:	4f 90       	pop	r4
     bf0:	08 95       	ret

00000bf2 <TCP_SetConnectionState>:
 */
bool TCP_SetConnectionState(const uint16_t Port,
                            const IP_Address_t RemoteAddress,
                            const uint16_t RemotePort,
                            const uint8_t State)
{
     bf2:	3f 92       	push	r3
     bf4:	4f 92       	push	r4
     bf6:	5f 92       	push	r5
     bf8:	6f 92       	push	r6
     bfa:	7f 92       	push	r7
     bfc:	8f 92       	push	r8
     bfe:	9f 92       	push	r9
     c00:	af 92       	push	r10
     c02:	bf 92       	push	r11
     c04:	cf 92       	push	r12
     c06:	df 92       	push	r13
     c08:	ef 92       	push	r14
     c0a:	ff 92       	push	r15
     c0c:	0f 93       	push	r16
     c0e:	1f 93       	push	r17
     c10:	df 93       	push	r29
     c12:	cf 93       	push	r28
     c14:	00 d0       	rcall	.+0      	; 0xc16 <TCP_SetConnectionState+0x24>
     c16:	00 d0       	rcall	.+0      	; 0xc18 <TCP_SetConnectionState+0x26>
     c18:	cd b7       	in	r28, 0x3d	; 61
     c1a:	de b7       	in	r29, 0x3e	; 62
     c1c:	5c 01       	movw	r10, r24
     c1e:	49 83       	std	Y+1, r20	; 0x01
     c20:	5a 83       	std	Y+2, r21	; 0x02
     c22:	6b 83       	std	Y+3, r22	; 0x03
     c24:	7c 83       	std	Y+4, r23	; 0x04
     c26:	49 01       	movw	r8, r18
     c28:	30 2e       	mov	r3, r16
     c2a:	75 eb       	ldi	r23, 0xB5	; 181
     c2c:	e7 2e       	mov	r14, r23
     c2e:	7d e0       	ldi	r23, 0x0D	; 13
     c30:	f7 2e       	mov	r15, r23
     c32:	00 e0       	ldi	r16, 0x00	; 0
     c34:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     c36:	66 e1       	ldi	r22, 0x16	; 22
     c38:	46 2e       	mov	r4, r22
     c3a:	62 e0       	ldi	r22, 0x02	; 2
     c3c:	56 2e       	mov	r5, r22
     c3e:	3e 01       	movw	r6, r28
     c40:	08 94       	sec
     c42:	61 1c       	adc	r6, r1
     c44:	71 1c       	adc	r7, r1
     c46:	f7 01       	movw	r30, r14
     c48:	80 81       	ld	r24, Z
     c4a:	91 81       	ldd	r25, Z+1	; 0x01
     c4c:	8a 15       	cp	r24, r10
     c4e:	9b 05       	cpc	r25, r11
     c50:	d9 f4       	brne	.+54     	; 0xc88 <TCP_SetConnectionState+0x96>
     c52:	04 9d       	mul	r16, r4
     c54:	60 01       	movw	r12, r0
     c56:	05 9d       	mul	r16, r5
     c58:	d0 0c       	add	r13, r0
     c5a:	14 9d       	mul	r17, r4
     c5c:	d0 0c       	add	r13, r0
     c5e:	11 24       	eor	r1, r1
     c60:	c6 01       	movw	r24, r12
     c62:	87 54       	subi	r24, 0x47	; 71
     c64:	92 4f       	sbci	r25, 0xF2	; 242
     c66:	b3 01       	movw	r22, r6
     c68:	44 e0       	ldi	r20, 0x04	; 4
     c6a:	50 e0       	ldi	r21, 0x00	; 0
     c6c:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <memcmp>
     c70:	00 97       	sbiw	r24, 0x00	; 0
     c72:	51 f4       	brne	.+20     	; 0xc88 <TCP_SetConnectionState+0x96>
     c74:	f7 01       	movw	r30, r14
     c76:	82 81       	ldd	r24, Z+2	; 0x02
     c78:	93 81       	ldd	r25, Z+3	; 0x03
     c7a:	88 15       	cp	r24, r8
     c7c:	99 05       	cpc	r25, r9
     c7e:	21 f4       	brne	.+8      	; 0xc88 <TCP_SetConnectionState+0x96>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			ConnectionStateTable[CSTableEntry].State = State;
     c80:	f6 01       	movw	r30, r12
     c82:	e6 53       	subi	r30, 0x36	; 54
     c84:	f0 4f       	sbci	r31, 0xF0	; 240
     c86:	47 c0       	rjmp	.+142    	; 0xd16 <TCP_SetConnectionState+0x124>
			return true;
     c88:	0f 5f       	subi	r16, 0xFF	; 255
     c8a:	1f 4f       	sbci	r17, 0xFF	; 255
     c8c:	86 e1       	ldi	r24, 0x16	; 22
     c8e:	92 e0       	ldi	r25, 0x02	; 2
     c90:	e8 0e       	add	r14, r24
     c92:	f9 1e       	adc	r15, r25
                            const uint16_t RemotePort,
                            const uint8_t State)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     c94:	03 30       	cpi	r16, 0x03	; 3
     c96:	11 05       	cpc	r17, r1
     c98:	b1 f6       	brne	.-84     	; 0xc46 <TCP_SetConnectionState+0x54>
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
     c9a:	80 91 ca 0f 	lds	r24, 0x0FCA
     c9e:	8a 30       	cpi	r24, 0x0A	; 10
     ca0:	19 f4       	brne	.+6      	; 0xca8 <TCP_SetConnectionState+0xb6>
     ca2:	40 e0       	ldi	r20, 0x00	; 0
     ca4:	50 e0       	ldi	r21, 0x00	; 0
     ca6:	0f c0       	rjmp	.+30     	; 0xcc6 <TCP_SetConnectionState+0xd4>
     ca8:	80 91 e0 11 	lds	r24, 0x11E0
     cac:	8a 30       	cpi	r24, 0x0A	; 10
     cae:	19 f4       	brne	.+6      	; 0xcb6 <TCP_SetConnectionState+0xc4>
     cb0:	41 e0       	ldi	r20, 0x01	; 1
     cb2:	50 e0       	ldi	r21, 0x00	; 0
     cb4:	08 c0       	rjmp	.+16     	; 0xcc6 <TCP_SetConnectionState+0xd4>
     cb6:	80 91 f6 13 	lds	r24, 0x13F6
     cba:	8a 30       	cpi	r24, 0x0A	; 10
     cbc:	11 f0       	breq	.+4      	; 0xcc2 <TCP_SetConnectionState+0xd0>
     cbe:	80 e0       	ldi	r24, 0x00	; 0
     cc0:	2c c0       	rjmp	.+88     	; 0xd1a <TCP_SetConnectionState+0x128>
     cc2:	42 e0       	ldi	r20, 0x02	; 2
     cc4:	50 e0       	ldi	r21, 0x00	; 0
		{
			ConnectionStateTable[CSTableEntry].Port          = Port;
     cc6:	86 e1       	ldi	r24, 0x16	; 22
     cc8:	92 e0       	ldi	r25, 0x02	; 2
     cca:	48 9f       	mul	r20, r24
     ccc:	90 01       	movw	r18, r0
     cce:	49 9f       	mul	r20, r25
     cd0:	30 0d       	add	r19, r0
     cd2:	58 9f       	mul	r21, r24
     cd4:	30 0d       	add	r19, r0
     cd6:	11 24       	eor	r1, r1
     cd8:	2b 54       	subi	r18, 0x4B	; 75
     cda:	32 4f       	sbci	r19, 0xF2	; 242
     cdc:	f9 01       	movw	r30, r18
     cde:	b1 82       	std	Z+1, r11	; 0x01
     ce0:	a0 82       	st	Z, r10
			ConnectionStateTable[CSTableEntry].RemoteAddress = RemoteAddress;
     ce2:	89 81       	ldd	r24, Y+1	; 0x01
     ce4:	9a 81       	ldd	r25, Y+2	; 0x02
     ce6:	ab 81       	ldd	r26, Y+3	; 0x03
     ce8:	bc 81       	ldd	r27, Y+4	; 0x04
     cea:	84 83       	std	Z+4, r24	; 0x04
     cec:	95 83       	std	Z+5, r25	; 0x05
     cee:	a6 83       	std	Z+6, r26	; 0x06
     cf0:	b7 83       	std	Z+7, r27	; 0x07
			ConnectionStateTable[CSTableEntry].RemotePort    = RemotePort;
     cf2:	8b e0       	ldi	r24, 0x0B	; 11
     cf4:	91 e0       	ldi	r25, 0x01	; 1
     cf6:	48 9f       	mul	r20, r24
     cf8:	f0 01       	movw	r30, r0
     cfa:	49 9f       	mul	r20, r25
     cfc:	f0 0d       	add	r31, r0
     cfe:	58 9f       	mul	r21, r24
     d00:	f0 0d       	add	r31, r0
     d02:	11 24       	eor	r1, r1
     d04:	ee 0f       	add	r30, r30
     d06:	ff 1f       	adc	r31, r31
     d08:	e9 54       	subi	r30, 0x49	; 73
     d0a:	f2 4f       	sbci	r31, 0xF2	; 242
     d0c:	91 82       	std	Z+1, r9	; 0x01
     d0e:	80 82       	st	Z, r8
			ConnectionStateTable[CSTableEntry].State         = State;
     d10:	2b 5e       	subi	r18, 0xEB	; 235
     d12:	3d 4f       	sbci	r19, 0xFD	; 253
     d14:	f9 01       	movw	r30, r18
     d16:	30 82       	st	Z, r3
     d18:	81 e0       	ldi	r24, 0x01	; 1
			return true;
		}
	}

	return false;
}
     d1a:	0f 90       	pop	r0
     d1c:	0f 90       	pop	r0
     d1e:	0f 90       	pop	r0
     d20:	0f 90       	pop	r0
     d22:	cf 91       	pop	r28
     d24:	df 91       	pop	r29
     d26:	1f 91       	pop	r17
     d28:	0f 91       	pop	r16
     d2a:	ff 90       	pop	r15
     d2c:	ef 90       	pop	r14
     d2e:	df 90       	pop	r13
     d30:	cf 90       	pop	r12
     d32:	bf 90       	pop	r11
     d34:	af 90       	pop	r10
     d36:	9f 90       	pop	r9
     d38:	8f 90       	pop	r8
     d3a:	7f 90       	pop	r7
     d3c:	6f 90       	pop	r6
     d3e:	5f 90       	pop	r5
     d40:	4f 90       	pop	r4
     d42:	3f 90       	pop	r3
     d44:	08 95       	ret

00000d46 <TCP_ProcessTCPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t TCP_ProcessTCPPacket(void* IPHeaderInStart,
                             void* TCPHeaderInStart,
                             void* TCPHeaderOutStart)
{
     d46:	af 92       	push	r10
     d48:	bf 92       	push	r11
     d4a:	cf 92       	push	r12
     d4c:	df 92       	push	r13
     d4e:	ef 92       	push	r14
     d50:	ff 92       	push	r15
     d52:	0f 93       	push	r16
     d54:	1f 93       	push	r17
     d56:	cf 93       	push	r28
     d58:	df 93       	push	r29
     d5a:	7b 01       	movw	r14, r22
	IP_Header_t*  IPHeaderIN   = (IP_Header_t*)IPHeaderInStart;
     d5c:	5c 01       	movw	r10, r24
	TCP_Header_t* TCPHeaderIN  = (TCP_Header_t*)TCPHeaderInStart;
	TCP_Header_t* TCPHeaderOUT = (TCP_Header_t*)TCPHeaderOutStart;
     d5e:	6a 01       	movw	r12, r20

	TCP_ConnectionInfo_t* ConnectionInfo;

	DecodeTCPHeader(TCPHeaderInStart);
     d60:	cb 01       	movw	r24, r22
     d62:	fd dc       	rcall	.-1542   	; 0x75e <DecodeTCPHeader>

	bool PacketResponse = false;

	/* Check if the destination port is open and allows incoming connections */
	if (TCP_GetPortState(TCPHeaderIN->DestinationPort) == TCP_Port_Open)
     d64:	d7 01       	movw	r26, r14
     d66:	12 96       	adiw	r26, 0x02	; 2
     d68:	8d 91       	ld	r24, X+
     d6a:	9c 91       	ld	r25, X
     d6c:	13 97       	sbiw	r26, 0x03	; 3
     d6e:	9e dd       	rcall	.-1220   	; 0x8ac <TCP_GetPortState>
     d70:	81 30       	cpi	r24, 0x01	; 1
     d72:	09 f0       	breq	.+2      	; 0xd76 <TCP_ProcessTCPPacket+0x30>
     d74:	2a c2       	rjmp	.+1108   	; 0x11ca <TCP_ProcessTCPPacket+0x484>
	{
		/* Detect SYN from host to start a connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_SYN)
     d76:	e7 01       	movw	r28, r14
     d78:	8d 85       	ldd	r24, Y+13	; 0x0d
     d7a:	81 ff       	sbrs	r24, 1
     d7c:	0b c0       	rjmp	.+22     	; 0xd94 <TCP_ProcessTCPPacket+0x4e>
		  TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort, TCP_Connection_Listen);
     d7e:	f5 01       	movw	r30, r10
     d80:	44 85       	ldd	r20, Z+12	; 0x0c
     d82:	55 85       	ldd	r21, Z+13	; 0x0d
     d84:	66 85       	ldd	r22, Z+14	; 0x0e
     d86:	77 85       	ldd	r23, Z+15	; 0x0f
     d88:	28 81       	ld	r18, Y
     d8a:	39 81       	ldd	r19, Y+1	; 0x01
     d8c:	8a 81       	ldd	r24, Y+2	; 0x02
     d8e:	9b 81       	ldd	r25, Y+3	; 0x03
     d90:	00 e0       	ldi	r16, 0x00	; 0
     d92:	2f df       	rcall	.-418    	; 0xbf2 <TCP_SetConnectionState>

		/* Detect RST from host to abort existing connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_RST)
     d94:	d7 01       	movw	r26, r14
     d96:	1d 96       	adiw	r26, 0x0d	; 13
     d98:	8c 91       	ld	r24, X
     d9a:	1d 97       	sbiw	r26, 0x0d	; 13
     d9c:	12 96       	adiw	r26, 0x02	; 2
     d9e:	ed 91       	ld	r30, X+
     da0:	fc 91       	ld	r31, X
     da2:	13 97       	sbiw	r26, 0x03	; 3
     da4:	e5 01       	movw	r28, r10
     da6:	4c 85       	ldd	r20, Y+12	; 0x0c
     da8:	5d 85       	ldd	r21, Y+13	; 0x0d
     daa:	6e 85       	ldd	r22, Y+14	; 0x0e
     dac:	7f 85       	ldd	r23, Y+15	; 0x0f
     dae:	2d 91       	ld	r18, X+
     db0:	3c 91       	ld	r19, X
     db2:	82 ff       	sbrs	r24, 2
     db4:	08 c0       	rjmp	.+16     	; 0xdc6 <TCP_ProcessTCPPacket+0x80>
		{
			if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     db6:	cf 01       	movw	r24, r30
     db8:	0a e0       	ldi	r16, 0x0A	; 10
     dba:	1b df       	rcall	.-458    	; 0xbf2 <TCP_SetConnectionState>
     dbc:	88 23       	and	r24, r24
     dbe:	09 f4       	brne	.+2      	; 0xdc2 <TCP_ProcessTCPPacket+0x7c>
     dc0:	38 c2       	rjmp	.+1136   	; 0x1232 <TCP_ProcessTCPPacket+0x4ec>
			                           TCPHeaderIN->SourcePort, TCP_Connection_Closed))
			{
				TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
     dc2:	84 e1       	ldi	r24, 0x14	; 20
     dc4:	5d c0       	rjmp	.+186    	; 0xe80 <TCP_ProcessTCPPacket+0x13a>
			}
		}
		else
		{
			/* Process the incoming TCP packet based on the current connection state for the sender and port */
			switch (TCP_GetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort))
     dc6:	cf 01       	movw	r24, r30
     dc8:	ab de       	rcall	.-682    	; 0xb20 <TCP_GetConnectionState>
     dca:	84 30       	cpi	r24, 0x04	; 4
     dcc:	09 f4       	brne	.+2      	; 0xdd0 <TCP_ProcessTCPPacket+0x8a>
     dce:	68 c1       	rjmp	.+720    	; 0x10a0 <TCP_ProcessTCPPacket+0x35a>
     dd0:	85 30       	cpi	r24, 0x05	; 5
     dd2:	48 f4       	brcc	.+18     	; 0xde6 <TCP_ProcessTCPPacket+0xa0>
     dd4:	82 30       	cpi	r24, 0x02	; 2
     dd6:	09 f4       	brne	.+2      	; 0xdda <TCP_ProcessTCPPacket+0x94>
     dd8:	56 c0       	rjmp	.+172    	; 0xe86 <TCP_ProcessTCPPacket+0x140>
     dda:	83 30       	cpi	r24, 0x03	; 3
     ddc:	08 f0       	brcs	.+2      	; 0xde0 <TCP_ProcessTCPPacket+0x9a>
     dde:	7f c0       	rjmp	.+254    	; 0xede <TCP_ProcessTCPPacket+0x198>
     de0:	88 23       	and	r24, r24
     de2:	59 f0       	breq	.+22     	; 0xdfa <TCP_ProcessTCPPacket+0xb4>
     de4:	26 c2       	rjmp	.+1100   	; 0x1232 <TCP_ProcessTCPPacket+0x4ec>
     de6:	86 30       	cpi	r24, 0x06	; 6
     de8:	09 f4       	brne	.+2      	; 0xdec <TCP_ProcessTCPPacket+0xa6>
     dea:	dc c1       	rjmp	.+952    	; 0x11a4 <TCP_ProcessTCPPacket+0x45e>
     dec:	86 30       	cpi	r24, 0x06	; 6
     dee:	08 f4       	brcc	.+2      	; 0xdf2 <TCP_ProcessTCPPacket+0xac>
     df0:	9e c1       	rjmp	.+828    	; 0x112e <TCP_ProcessTCPPacket+0x3e8>
     df2:	87 30       	cpi	r24, 0x07	; 7
     df4:	09 f0       	breq	.+2      	; 0xdf8 <TCP_ProcessTCPPacket+0xb2>
     df6:	1d c2       	rjmp	.+1082   	; 0x1232 <TCP_ProcessTCPPacket+0x4ec>
     df8:	35 c1       	rjmp	.+618    	; 0x1064 <TCP_ProcessTCPPacket+0x31e>
			{
				case TCP_Connection_Listen:
					if (TCPHeaderIN->Flags == TCP_FLAG_SYN)
     dfa:	d7 01       	movw	r26, r14
     dfc:	1d 96       	adiw	r26, 0x0d	; 13
     dfe:	8c 91       	ld	r24, X
     e00:	1d 97       	sbiw	r26, 0x0d	; 13
     e02:	82 30       	cpi	r24, 0x02	; 2
     e04:	09 f0       	breq	.+2      	; 0xe08 <TCP_ProcessTCPPacket+0xc2>
     e06:	15 c2       	rjmp	.+1066   	; 0x1232 <TCP_ProcessTCPPacket+0x4ec>
					{
						/* SYN connection starts a connection with a peer */
						if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     e08:	e5 01       	movw	r28, r10
     e0a:	4c 85       	ldd	r20, Y+12	; 0x0c
     e0c:	5d 85       	ldd	r21, Y+13	; 0x0d
     e0e:	6e 85       	ldd	r22, Y+14	; 0x0e
     e10:	7f 85       	ldd	r23, Y+15	; 0x0f
     e12:	2d 91       	ld	r18, X+
     e14:	3c 91       	ld	r19, X
     e16:	11 97       	sbiw	r26, 0x01	; 1
     e18:	12 96       	adiw	r26, 0x02	; 2
     e1a:	8d 91       	ld	r24, X+
     e1c:	9c 91       	ld	r25, X
     e1e:	13 97       	sbiw	r26, 0x03	; 3
     e20:	02 e0       	ldi	r16, 0x02	; 2
     e22:	e7 de       	rcall	.-562    	; 0xbf2 <TCP_SetConnectionState>
     e24:	88 23       	and	r24, r24
     e26:	59 f1       	breq	.+86     	; 0xe7e <TCP_ProcessTCPPacket+0x138>
						                           TCPHeaderIN->SourcePort, TCP_Connection_SYNReceived))
						{
							TCPHeaderOUT->Flags = (TCP_FLAG_SYN | TCP_FLAG_ACK);
     e28:	82 e1       	ldi	r24, 0x12	; 18
     e2a:	f6 01       	movw	r30, r12
     e2c:	85 87       	std	Z+13, r24	; 0x0d

							ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort);
     e2e:	4c 85       	ldd	r20, Y+12	; 0x0c
     e30:	5d 85       	ldd	r21, Y+13	; 0x0d
     e32:	6e 85       	ldd	r22, Y+14	; 0x0e
     e34:	7f 85       	ldd	r23, Y+15	; 0x0f
     e36:	d7 01       	movw	r26, r14
     e38:	2d 91       	ld	r18, X+
     e3a:	3c 91       	ld	r19, X
     e3c:	11 97       	sbiw	r26, 0x01	; 1
     e3e:	12 96       	adiw	r26, 0x02	; 2
     e40:	8d 91       	ld	r24, X+
     e42:	9c 91       	ld	r25, X
     e44:	13 97       	sbiw	r26, 0x03	; 3
     e46:	02 de       	rcall	.-1020   	; 0xa4c <TCP_GetConnectionInfo>
     e48:	fc 01       	movw	r30, r24
				{
					uint32_t DWord;
					uint8_t  Bytes[4];
				} Data;

				Data.DWord = DWord;
     e4a:	e7 01       	movw	r28, r14
     e4c:	8c 81       	ldd	r24, Y+4	; 0x04
     e4e:	9d 81       	ldd	r25, Y+5	; 0x05
     e50:	ae 81       	ldd	r26, Y+6	; 0x06
     e52:	bf 81       	ldd	r27, Y+7	; 0x07

				Temp = Data.Bytes[0];
     e54:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[3];
     e56:	8b 2f       	mov	r24, r27
				Data.Bytes[3] = Temp;
     e58:	b2 2f       	mov	r27, r18

				Temp = Data.Bytes[1];
     e5a:	29 2f       	mov	r18, r25
				Data.Bytes[1] = Data.Bytes[2];
     e5c:	9a 2f       	mov	r25, r26
				Data.Bytes[2] = Temp;
     e5e:	a2 2f       	mov	r26, r18

							ConnectionInfo->SequenceNumberIn  = (SwapEndian_32(TCPHeaderIN->SequenceNumber) + 1);
     e60:	01 96       	adiw	r24, 0x01	; 1
     e62:	a1 1d       	adc	r26, r1
     e64:	b1 1d       	adc	r27, r1
     e66:	80 83       	st	Z, r24
     e68:	91 83       	std	Z+1, r25	; 0x01
     e6a:	a2 83       	std	Z+2, r26	; 0x02
     e6c:	b3 83       	std	Z+3, r27	; 0x03
							ConnectionInfo->SequenceNumberOut = 0;
     e6e:	14 82       	std	Z+4, r1	; 0x04
     e70:	15 82       	std	Z+5, r1	; 0x05
     e72:	16 82       	std	Z+6, r1	; 0x06
     e74:	17 82       	std	Z+7, r1	; 0x07
							ConnectionInfo->Buffer.InUse      = false;
     e76:	e4 5f       	subi	r30, 0xF4	; 244
     e78:	fd 4f       	sbci	r31, 0xFD	; 253
     e7a:	10 82       	st	Z, r1
     e7c:	e8 c1       	rjmp	.+976    	; 0x124e <TCP_ProcessTCPPacket+0x508>
						}
						else
						{
							TCPHeaderOUT->Flags = TCP_FLAG_RST;
     e7e:	84 e0       	ldi	r24, 0x04	; 4
     e80:	f6 01       	movw	r30, r12
     e82:	85 87       	std	Z+13, r24	; 0x0d
     e84:	e4 c1       	rjmp	.+968    	; 0x124e <TCP_ProcessTCPPacket+0x508>
						PacketResponse      = true;
					}

					break;
				case TCP_Connection_SYNReceived:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
     e86:	d7 01       	movw	r26, r14
     e88:	1d 96       	adiw	r26, 0x0d	; 13
     e8a:	8c 91       	ld	r24, X
     e8c:	1d 97       	sbiw	r26, 0x0d	; 13
     e8e:	80 31       	cpi	r24, 0x10	; 16
     e90:	09 f0       	breq	.+2      	; 0xe94 <TCP_ProcessTCPPacket+0x14e>
     e92:	cf c1       	rjmp	.+926    	; 0x1232 <TCP_ProcessTCPPacket+0x4ec>
					{
						/* ACK during the connection process completes the connection to a peer */

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     e94:	e5 01       	movw	r28, r10
     e96:	4c 85       	ldd	r20, Y+12	; 0x0c
     e98:	5d 85       	ldd	r21, Y+13	; 0x0d
     e9a:	6e 85       	ldd	r22, Y+14	; 0x0e
     e9c:	7f 85       	ldd	r23, Y+15	; 0x0f
     e9e:	2d 91       	ld	r18, X+
     ea0:	3c 91       	ld	r19, X
     ea2:	11 97       	sbiw	r26, 0x01	; 1
     ea4:	12 96       	adiw	r26, 0x02	; 2
     ea6:	8d 91       	ld	r24, X+
     ea8:	9c 91       	ld	r25, X
     eaa:	13 97       	sbiw	r26, 0x03	; 3
     eac:	03 e0       	ldi	r16, 0x03	; 3
     eae:	a1 de       	rcall	.-702    	; 0xbf2 <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_Established);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     eb0:	4c 85       	ldd	r20, Y+12	; 0x0c
     eb2:	5d 85       	ldd	r21, Y+13	; 0x0d
     eb4:	6e 85       	ldd	r22, Y+14	; 0x0e
     eb6:	7f 85       	ldd	r23, Y+15	; 0x0f
     eb8:	f7 01       	movw	r30, r14
     eba:	20 81       	ld	r18, Z
     ebc:	31 81       	ldd	r19, Z+1	; 0x01
     ebe:	82 81       	ldd	r24, Z+2	; 0x02
     ec0:	93 81       	ldd	r25, Z+3	; 0x03
     ec2:	c4 dd       	rcall	.-1144   	; 0xa4c <TCP_GetConnectionInfo>
     ec4:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberOut++;
     ec6:	84 81       	ldd	r24, Z+4	; 0x04
     ec8:	95 81       	ldd	r25, Z+5	; 0x05
     eca:	a6 81       	ldd	r26, Z+6	; 0x06
     ecc:	b7 81       	ldd	r27, Z+7	; 0x07
     ece:	01 96       	adiw	r24, 0x01	; 1
     ed0:	a1 1d       	adc	r26, r1
     ed2:	b1 1d       	adc	r27, r1
     ed4:	84 83       	std	Z+4, r24	; 0x04
     ed6:	95 83       	std	Z+5, r25	; 0x05
     ed8:	a6 83       	std	Z+6, r26	; 0x06
     eda:	b7 83       	std	Z+7, r27	; 0x07
     edc:	aa c1       	rjmp	.+852    	; 0x1232 <TCP_ProcessTCPPacket+0x4ec>
					}

					break;
				case TCP_Connection_Established:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
     ede:	d7 01       	movw	r26, r14
     ee0:	1d 96       	adiw	r26, 0x0d	; 13
     ee2:	8c 91       	ld	r24, X
     ee4:	1d 97       	sbiw	r26, 0x0d	; 13
     ee6:	81 31       	cpi	r24, 0x11	; 17
     ee8:	a9 f5       	brne	.+106    	; 0xf54 <TCP_ProcessTCPPacket+0x20e>
					{
						/* FIN ACK when connected to a peer starts the finalization process */

						TCPHeaderOUT->Flags = (TCP_FLAG_FIN | TCP_FLAG_ACK);
     eea:	e6 01       	movw	r28, r12
     eec:	8d 87       	std	Y+13, r24	; 0x0d
						PacketResponse      = true;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     eee:	f5 01       	movw	r30, r10
     ef0:	44 85       	ldd	r20, Z+12	; 0x0c
     ef2:	55 85       	ldd	r21, Z+13	; 0x0d
     ef4:	66 85       	ldd	r22, Z+14	; 0x0e
     ef6:	77 85       	ldd	r23, Z+15	; 0x0f
     ef8:	2d 91       	ld	r18, X+
     efa:	3c 91       	ld	r19, X
     efc:	11 97       	sbiw	r26, 0x01	; 1
     efe:	12 96       	adiw	r26, 0x02	; 2
     f00:	8d 91       	ld	r24, X+
     f02:	9c 91       	ld	r25, X
     f04:	13 97       	sbiw	r26, 0x03	; 3
     f06:	06 e0       	ldi	r16, 0x06	; 6
     f08:	74 de       	rcall	.-792    	; 0xbf2 <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_CloseWait);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     f0a:	d5 01       	movw	r26, r10
     f0c:	1c 96       	adiw	r26, 0x0c	; 12
     f0e:	4d 91       	ld	r20, X+
     f10:	5d 91       	ld	r21, X+
     f12:	6d 91       	ld	r22, X+
     f14:	7c 91       	ld	r23, X
     f16:	1f 97       	sbiw	r26, 0x0f	; 15
     f18:	e7 01       	movw	r28, r14
     f1a:	28 81       	ld	r18, Y
     f1c:	39 81       	ldd	r19, Y+1	; 0x01
     f1e:	8a 81       	ldd	r24, Y+2	; 0x02
     f20:	9b 81       	ldd	r25, Y+3	; 0x03
     f22:	94 dd       	rcall	.-1240   	; 0xa4c <TCP_GetConnectionInfo>
     f24:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberIn++;
     f26:	80 81       	ld	r24, Z
     f28:	91 81       	ldd	r25, Z+1	; 0x01
     f2a:	a2 81       	ldd	r26, Z+2	; 0x02
     f2c:	b3 81       	ldd	r27, Z+3	; 0x03
     f2e:	01 96       	adiw	r24, 0x01	; 1
     f30:	a1 1d       	adc	r26, r1
     f32:	b1 1d       	adc	r27, r1
     f34:	80 83       	st	Z, r24
     f36:	91 83       	std	Z+1, r25	; 0x01
     f38:	a2 83       	std	Z+2, r26	; 0x02
     f3a:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
     f3c:	84 81       	ldd	r24, Z+4	; 0x04
     f3e:	95 81       	ldd	r25, Z+5	; 0x05
     f40:	a6 81       	ldd	r26, Z+6	; 0x06
     f42:	b7 81       	ldd	r27, Z+7	; 0x07
     f44:	01 96       	adiw	r24, 0x01	; 1
     f46:	a1 1d       	adc	r26, r1
     f48:	b1 1d       	adc	r27, r1
     f4a:	84 83       	std	Z+4, r24	; 0x04
     f4c:	95 83       	std	Z+5, r25	; 0x05
     f4e:	a6 83       	std	Z+6, r26	; 0x06
     f50:	b7 83       	std	Z+7, r27	; 0x07
     f52:	7d c1       	rjmp	.+762    	; 0x124e <TCP_ProcessTCPPacket+0x508>
					}
					else if ((TCPHeaderIN->Flags == TCP_FLAG_ACK) || (TCPHeaderIN->Flags == (TCP_FLAG_ACK | TCP_FLAG_PSH)))
     f54:	80 31       	cpi	r24, 0x10	; 16
     f56:	19 f0       	breq	.+6      	; 0xf5e <TCP_ProcessTCPPacket+0x218>
     f58:	88 31       	cpi	r24, 0x18	; 24
     f5a:	09 f0       	breq	.+2      	; 0xf5e <TCP_ProcessTCPPacket+0x218>
     f5c:	6a c1       	rjmp	.+724    	; 0x1232 <TCP_ProcessTCPPacket+0x4ec>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     f5e:	f5 01       	movw	r30, r10
     f60:	44 85       	ldd	r20, Z+12	; 0x0c
     f62:	55 85       	ldd	r21, Z+13	; 0x0d
     f64:	66 85       	ldd	r22, Z+14	; 0x0e
     f66:	77 85       	ldd	r23, Z+15	; 0x0f
     f68:	d7 01       	movw	r26, r14
     f6a:	2d 91       	ld	r18, X+
     f6c:	3c 91       	ld	r19, X
     f6e:	11 97       	sbiw	r26, 0x01	; 1
     f70:	12 96       	adiw	r26, 0x02	; 2
     f72:	8d 91       	ld	r24, X+
     f74:	9c 91       	ld	r25, X
     f76:	13 97       	sbiw	r26, 0x03	; 3
     f78:	69 dd       	rcall	.-1326   	; 0xa4c <TCP_GetConnectionInfo>
     f7a:	ec 01       	movw	r28, r24
															   TCPHeaderIN->SourcePort);

						/* Check if the buffer is currently in use either by a buffered data to send, or receive */
						if ((ConnectionInfo->Buffer.InUse == false) && (ConnectionInfo->Buffer.Ready == false))
     f7c:	fc 01       	movw	r30, r24
     f7e:	e4 5f       	subi	r30, 0xF4	; 244
     f80:	fd 4f       	sbci	r31, 0xFD	; 253
     f82:	80 81       	ld	r24, Z
     f84:	88 23       	and	r24, r24
     f86:	81 f4       	brne	.+32     	; 0xfa8 <TCP_ProcessTCPPacket+0x262>
     f88:	c5 5f       	subi	r28, 0xF5	; 245
     f8a:	dd 4f       	sbci	r29, 0xFD	; 253
     f8c:	88 81       	ld	r24, Y
     f8e:	cb 50       	subi	r28, 0x0B	; 11
     f90:	d2 40       	sbci	r29, 0x02	; 2
     f92:	88 23       	and	r24, r24
     f94:	49 f4       	brne	.+18     	; 0xfa8 <TCP_ProcessTCPPacket+0x262>
						{
							ConnectionInfo->Buffer.Direction = TCP_PACKETDIR_IN;
     f96:	c6 5f       	subi	r28, 0xF6	; 246
     f98:	dd 4f       	sbci	r29, 0xFD	; 253
     f9a:	18 82       	st	Y, r1
     f9c:	ca 50       	subi	r28, 0x0A	; 10
     f9e:	d2 40       	sbci	r29, 0x02	; 2
							ConnectionInfo->Buffer.InUse     = true;
     fa0:	81 e0       	ldi	r24, 0x01	; 1
     fa2:	80 83       	st	Z, r24
							ConnectionInfo->Buffer.Length    = 0;
     fa4:	19 86       	std	Y+9, r1	; 0x09
     fa6:	18 86       	std	Y+8, r1	; 0x08
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
     fa8:	c6 5f       	subi	r28, 0xF6	; 246
     faa:	dd 4f       	sbci	r29, 0xFD	; 253
     fac:	88 81       	ld	r24, Y
     fae:	ca 50       	subi	r28, 0x0A	; 10
     fb0:	d2 40       	sbci	r29, 0x02	; 2
     fb2:	88 23       	and	r24, r24
     fb4:	09 f0       	breq	.+2      	; 0xfb8 <TCP_ProcessTCPPacket+0x272>
     fb6:	3a c1       	rjmp	.+628    	; 0x122c <TCP_ProcessTCPPacket+0x4e6>
     fb8:	68 85       	ldd	r22, Y+8	; 0x08
     fba:	79 85       	ldd	r23, Y+9	; 0x09
     fbc:	b2 e0       	ldi	r27, 0x02	; 2
     fbe:	60 30       	cpi	r22, 0x00	; 0
     fc0:	7b 07       	cpc	r23, r27
     fc2:	09 f4       	brne	.+2      	; 0xfc6 <TCP_ProcessTCPPacket+0x280>
     fc4:	33 c1       	rjmp	.+614    	; 0x122c <TCP_ProcessTCPPacket+0x4e6>
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
						{
							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
     fc6:	f5 01       	movw	r30, r10
     fc8:	20 81       	ld	r18, Z
     fca:	2f 70       	andi	r18, 0x0F	; 15
     fcc:	30 e0       	ldi	r19, 0x00	; 0
     fce:	22 0f       	add	r18, r18
     fd0:	33 1f       	adc	r19, r19
     fd2:	22 0f       	add	r18, r18
     fd4:	33 1f       	adc	r19, r19
							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
     fd6:	d7 01       	movw	r26, r14
     fd8:	1c 96       	adiw	r26, 0x0c	; 12
     fda:	8c 91       	ld	r24, X
     fdc:	82 95       	swap	r24
     fde:	8f 70       	andi	r24, 0x0F	; 15
     fe0:	90 e0       	ldi	r25, 0x00	; 0
     fe2:	88 0f       	add	r24, r24
     fe4:	99 1f       	adc	r25, r25
     fe6:	88 0f       	add	r24, r24
     fe8:	99 1f       	adc	r25, r25
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     fea:	02 81       	ldd	r16, Z+2	; 0x02
     fec:	13 81       	ldd	r17, Z+3	; 0x03

				Temp = Data.Bytes[0];
     fee:	40 2f       	mov	r20, r16
				Data.Bytes[0] = Data.Bytes[1];
     ff0:	01 2f       	mov	r16, r17
				Data.Bytes[1] = Temp;
     ff2:	14 2f       	mov	r17, r20
							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
     ff4:	02 1b       	sub	r16, r18
     ff6:	13 0b       	sbc	r17, r19
     ff8:	08 1b       	sub	r16, r24
     ffa:	19 0b       	sbc	r17, r25

							/* Copy the packet data into the buffer */
							memcpy(&ConnectionInfo->Buffer.Data[ConnectionInfo->Buffer.Length],
     ffc:	9b 01       	movw	r18, r22
     ffe:	26 5f       	subi	r18, 0xF6	; 246
    1000:	3f 4f       	sbci	r19, 0xFF	; 255
    1002:	2c 0f       	add	r18, r28
    1004:	3d 1f       	adc	r19, r29
    1006:	a7 01       	movw	r20, r14
    1008:	48 0f       	add	r20, r24
    100a:	59 1f       	adc	r21, r25
    100c:	c9 01       	movw	r24, r18
    100e:	ba 01       	movw	r22, r20
    1010:	a8 01       	movw	r20, r16
    1012:	0e 94 86 17 	call	0x2f0c	; 0x2f0c <memcpy>
								   &((uint8_t*)TCPHeaderInStart)[TCPOffset],
								   DataLength);

							ConnectionInfo->SequenceNumberIn += DataLength;
    1016:	98 01       	movw	r18, r16
    1018:	40 e0       	ldi	r20, 0x00	; 0
    101a:	50 e0       	ldi	r21, 0x00	; 0
    101c:	88 81       	ld	r24, Y
    101e:	99 81       	ldd	r25, Y+1	; 0x01
    1020:	aa 81       	ldd	r26, Y+2	; 0x02
    1022:	bb 81       	ldd	r27, Y+3	; 0x03
    1024:	82 0f       	add	r24, r18
    1026:	93 1f       	adc	r25, r19
    1028:	a4 1f       	adc	r26, r20
    102a:	b5 1f       	adc	r27, r21
    102c:	88 83       	st	Y, r24
    102e:	99 83       	std	Y+1, r25	; 0x01
    1030:	aa 83       	std	Y+2, r26	; 0x02
    1032:	bb 83       	std	Y+3, r27	; 0x03
							ConnectionInfo->Buffer.Length    += DataLength;
    1034:	88 85       	ldd	r24, Y+8	; 0x08
    1036:	99 85       	ldd	r25, Y+9	; 0x09
    1038:	80 0f       	add	r24, r16
    103a:	91 1f       	adc	r25, r17
    103c:	99 87       	std	Y+9, r25	; 0x09
    103e:	88 87       	std	Y+8, r24	; 0x08

							/* Check if the buffer is full or if the PSH flag is set, if so indicate buffer ready */
							if ((!(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length)) || (TCPHeaderIN->Flags & TCP_FLAG_PSH))
    1040:	80 50       	subi	r24, 0x00	; 0
    1042:	92 40       	sbci	r25, 0x02	; 2
    1044:	21 f0       	breq	.+8      	; 0x104e <TCP_ProcessTCPPacket+0x308>
    1046:	f7 01       	movw	r30, r14
    1048:	85 85       	ldd	r24, Z+13	; 0x0d
    104a:	83 ff       	sbrs	r24, 3
    104c:	f2 c0       	rjmp	.+484    	; 0x1232 <TCP_ProcessTCPPacket+0x4ec>
							{
								ConnectionInfo->Buffer.InUse = false;
    104e:	c4 5f       	subi	r28, 0xF4	; 244
    1050:	dd 4f       	sbci	r29, 0xFD	; 253
    1052:	18 82       	st	Y, r1
								ConnectionInfo->Buffer.Ready = true;
    1054:	fe 01       	movw	r30, r28
    1056:	81 e0       	ldi	r24, 0x01	; 1
    1058:	82 93       	st	-Z, r24

								TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    105a:	80 e1       	ldi	r24, 0x10	; 16
    105c:	d6 01       	movw	r26, r12
    105e:	1d 96       	adiw	r26, 0x0d	; 13
    1060:	8c 93       	st	X, r24
    1062:	f5 c0       	rjmp	.+490    	; 0x124e <TCP_ProcessTCPPacket+0x508>
						}
					}

					break;
				case TCP_Connection_Closing:
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1064:	e5 01       	movw	r28, r10
    1066:	4c 85       	ldd	r20, Y+12	; 0x0c
    1068:	5d 85       	ldd	r21, Y+13	; 0x0d
    106a:	6e 85       	ldd	r22, Y+14	; 0x0e
    106c:	7f 85       	ldd	r23, Y+15	; 0x0f
    106e:	f7 01       	movw	r30, r14
    1070:	20 81       	ld	r18, Z
    1072:	31 81       	ldd	r19, Z+1	; 0x01
    1074:	82 81       	ldd	r24, Z+2	; 0x02
    1076:	93 81       	ldd	r25, Z+3	; 0x03
    1078:	e9 dc       	rcall	.-1582   	; 0xa4c <TCP_GetConnectionInfo>
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = (TCP_FLAG_ACK | TCP_FLAG_FIN);
    107a:	21 e1       	ldi	r18, 0x11	; 17
    107c:	d6 01       	movw	r26, r12
    107e:	1d 96       	adiw	r26, 0x0d	; 13
    1080:	2c 93       	st	X, r18
						PacketResponse      = true;

						ConnectionInfo->Buffer.InUse = false;
    1082:	fc 01       	movw	r30, r24
    1084:	e4 5f       	subi	r30, 0xF4	; 244
    1086:	fd 4f       	sbci	r31, 0xFD	; 253
    1088:	10 82       	st	Z, r1

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    108a:	4c 85       	ldd	r20, Y+12	; 0x0c
    108c:	5d 85       	ldd	r21, Y+13	; 0x0d
    108e:	6e 85       	ldd	r22, Y+14	; 0x0e
    1090:	7f 85       	ldd	r23, Y+15	; 0x0f
    1092:	e7 01       	movw	r28, r14
    1094:	28 81       	ld	r18, Y
    1096:	39 81       	ldd	r19, Y+1	; 0x01
    1098:	8a 81       	ldd	r24, Y+2	; 0x02
    109a:	9b 81       	ldd	r25, Y+3	; 0x03
    109c:	04 e0       	ldi	r16, 0x04	; 4
    109e:	80 c0       	rjmp	.+256    	; 0x11a0 <TCP_ProcessTCPPacket+0x45a>
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait1);

					break;
				case TCP_Connection_FINWait1:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    10a0:	f7 01       	movw	r30, r14
    10a2:	85 85       	ldd	r24, Z+13	; 0x0d
    10a4:	81 31       	cpi	r24, 0x11	; 17
    10a6:	a1 f5       	brne	.+104    	; 0x1110 <TCP_ProcessTCPPacket+0x3ca>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    10a8:	d5 01       	movw	r26, r10
    10aa:	1c 96       	adiw	r26, 0x0c	; 12
    10ac:	4d 91       	ld	r20, X+
    10ae:	5d 91       	ld	r21, X+
    10b0:	6d 91       	ld	r22, X+
    10b2:	7c 91       	ld	r23, X
    10b4:	1f 97       	sbiw	r26, 0x0f	; 15
    10b6:	20 81       	ld	r18, Z
    10b8:	31 81       	ldd	r19, Z+1	; 0x01
    10ba:	82 81       	ldd	r24, Z+2	; 0x02
    10bc:	93 81       	ldd	r25, Z+3	; 0x03
    10be:	c6 dc       	rcall	.-1652   	; 0xa4c <TCP_GetConnectionInfo>
    10c0:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    10c2:	80 e1       	ldi	r24, 0x10	; 16
    10c4:	e6 01       	movw	r28, r12
    10c6:	8d 87       	std	Y+13, r24	; 0x0d
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    10c8:	80 81       	ld	r24, Z
    10ca:	91 81       	ldd	r25, Z+1	; 0x01
    10cc:	a2 81       	ldd	r26, Z+2	; 0x02
    10ce:	b3 81       	ldd	r27, Z+3	; 0x03
    10d0:	01 96       	adiw	r24, 0x01	; 1
    10d2:	a1 1d       	adc	r26, r1
    10d4:	b1 1d       	adc	r27, r1
    10d6:	80 83       	st	Z, r24
    10d8:	91 83       	std	Z+1, r25	; 0x01
    10da:	a2 83       	std	Z+2, r26	; 0x02
    10dc:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    10de:	84 81       	ldd	r24, Z+4	; 0x04
    10e0:	95 81       	ldd	r25, Z+5	; 0x05
    10e2:	a6 81       	ldd	r26, Z+6	; 0x06
    10e4:	b7 81       	ldd	r27, Z+7	; 0x07
    10e6:	01 96       	adiw	r24, 0x01	; 1
    10e8:	a1 1d       	adc	r26, r1
    10ea:	b1 1d       	adc	r27, r1
    10ec:	84 83       	std	Z+4, r24	; 0x04
    10ee:	95 83       	std	Z+5, r25	; 0x05
    10f0:	a6 83       	std	Z+6, r26	; 0x06
    10f2:	b7 83       	std	Z+7, r27	; 0x07

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    10f4:	f5 01       	movw	r30, r10
    10f6:	44 85       	ldd	r20, Z+12	; 0x0c
    10f8:	55 85       	ldd	r21, Z+13	; 0x0d
    10fa:	66 85       	ldd	r22, Z+14	; 0x0e
    10fc:	77 85       	ldd	r23, Z+15	; 0x0f
    10fe:	d7 01       	movw	r26, r14
    1100:	2d 91       	ld	r18, X+
    1102:	3c 91       	ld	r19, X
    1104:	11 97       	sbiw	r26, 0x01	; 1
    1106:	12 96       	adiw	r26, 0x02	; 2
    1108:	8d 91       	ld	r24, X+
    110a:	9c 91       	ld	r25, X
    110c:	13 97       	sbiw	r26, 0x03	; 3
    110e:	47 c0       	rjmp	.+142    	; 0x119e <TCP_ProcessTCPPacket+0x458>
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}
					else if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    1110:	80 31       	cpi	r24, 0x10	; 16
    1112:	09 f0       	breq	.+2      	; 0x1116 <TCP_ProcessTCPPacket+0x3d0>
    1114:	8e c0       	rjmp	.+284    	; 0x1232 <TCP_ProcessTCPPacket+0x4ec>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1116:	e5 01       	movw	r28, r10
    1118:	4c 85       	ldd	r20, Y+12	; 0x0c
    111a:	5d 85       	ldd	r21, Y+13	; 0x0d
    111c:	6e 85       	ldd	r22, Y+14	; 0x0e
    111e:	7f 85       	ldd	r23, Y+15	; 0x0f
    1120:	f7 01       	movw	r30, r14
    1122:	20 81       	ld	r18, Z
    1124:	31 81       	ldd	r19, Z+1	; 0x01
    1126:	82 81       	ldd	r24, Z+2	; 0x02
    1128:	93 81       	ldd	r25, Z+3	; 0x03
    112a:	05 e0       	ldi	r16, 0x05	; 5
    112c:	4c c0       	rjmp	.+152    	; 0x11c6 <TCP_ProcessTCPPacket+0x480>
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait2);
					}

					break;
				case TCP_Connection_FINWait2:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    112e:	d7 01       	movw	r26, r14
    1130:	1d 96       	adiw	r26, 0x0d	; 13
    1132:	8c 91       	ld	r24, X
    1134:	1d 97       	sbiw	r26, 0x0d	; 13
    1136:	81 31       	cpi	r24, 0x11	; 17
    1138:	09 f0       	breq	.+2      	; 0x113c <TCP_ProcessTCPPacket+0x3f6>
    113a:	7b c0       	rjmp	.+246    	; 0x1232 <TCP_ProcessTCPPacket+0x4ec>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    113c:	e5 01       	movw	r28, r10
    113e:	4c 85       	ldd	r20, Y+12	; 0x0c
    1140:	5d 85       	ldd	r21, Y+13	; 0x0d
    1142:	6e 85       	ldd	r22, Y+14	; 0x0e
    1144:	7f 85       	ldd	r23, Y+15	; 0x0f
    1146:	2d 91       	ld	r18, X+
    1148:	3c 91       	ld	r19, X
    114a:	11 97       	sbiw	r26, 0x01	; 1
    114c:	12 96       	adiw	r26, 0x02	; 2
    114e:	8d 91       	ld	r24, X+
    1150:	9c 91       	ld	r25, X
    1152:	13 97       	sbiw	r26, 0x03	; 3
    1154:	7b dc       	rcall	.-1802   	; 0xa4c <TCP_GetConnectionInfo>
    1156:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    1158:	80 e1       	ldi	r24, 0x10	; 16
    115a:	d6 01       	movw	r26, r12
    115c:	1d 96       	adiw	r26, 0x0d	; 13
    115e:	8c 93       	st	X, r24
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    1160:	80 81       	ld	r24, Z
    1162:	91 81       	ldd	r25, Z+1	; 0x01
    1164:	a2 81       	ldd	r26, Z+2	; 0x02
    1166:	b3 81       	ldd	r27, Z+3	; 0x03
    1168:	01 96       	adiw	r24, 0x01	; 1
    116a:	a1 1d       	adc	r26, r1
    116c:	b1 1d       	adc	r27, r1
    116e:	80 83       	st	Z, r24
    1170:	91 83       	std	Z+1, r25	; 0x01
    1172:	a2 83       	std	Z+2, r26	; 0x02
    1174:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    1176:	84 81       	ldd	r24, Z+4	; 0x04
    1178:	95 81       	ldd	r25, Z+5	; 0x05
    117a:	a6 81       	ldd	r26, Z+6	; 0x06
    117c:	b7 81       	ldd	r27, Z+7	; 0x07
    117e:	01 96       	adiw	r24, 0x01	; 1
    1180:	a1 1d       	adc	r26, r1
    1182:	b1 1d       	adc	r27, r1
    1184:	84 83       	std	Z+4, r24	; 0x04
    1186:	95 83       	std	Z+5, r25	; 0x05
    1188:	a6 83       	std	Z+6, r26	; 0x06
    118a:	b7 83       	std	Z+7, r27	; 0x07

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    118c:	4c 85       	ldd	r20, Y+12	; 0x0c
    118e:	5d 85       	ldd	r21, Y+13	; 0x0d
    1190:	6e 85       	ldd	r22, Y+14	; 0x0e
    1192:	7f 85       	ldd	r23, Y+15	; 0x0f
    1194:	e7 01       	movw	r28, r14
    1196:	28 81       	ld	r18, Y
    1198:	39 81       	ldd	r19, Y+1	; 0x01
    119a:	8a 81       	ldd	r24, Y+2	; 0x02
    119c:	9b 81       	ldd	r25, Y+3	; 0x03
    119e:	0a e0       	ldi	r16, 0x0A	; 10
    11a0:	28 dd       	rcall	.-1456   	; 0xbf2 <TCP_SetConnectionState>
    11a2:	55 c0       	rjmp	.+170    	; 0x124e <TCP_ProcessTCPPacket+0x508>
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}

					break;
				case TCP_Connection_CloseWait:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    11a4:	f7 01       	movw	r30, r14
    11a6:	85 85       	ldd	r24, Z+13	; 0x0d
    11a8:	80 31       	cpi	r24, 0x10	; 16
    11aa:	09 f0       	breq	.+2      	; 0x11ae <TCP_ProcessTCPPacket+0x468>
    11ac:	42 c0       	rjmp	.+132    	; 0x1232 <TCP_ProcessTCPPacket+0x4ec>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    11ae:	d5 01       	movw	r26, r10
    11b0:	1c 96       	adiw	r26, 0x0c	; 12
    11b2:	4d 91       	ld	r20, X+
    11b4:	5d 91       	ld	r21, X+
    11b6:	6d 91       	ld	r22, X+
    11b8:	7c 91       	ld	r23, X
    11ba:	1f 97       	sbiw	r26, 0x0f	; 15
    11bc:	20 81       	ld	r18, Z
    11be:	31 81       	ldd	r19, Z+1	; 0x01
    11c0:	82 81       	ldd	r24, Z+2	; 0x02
    11c2:	93 81       	ldd	r25, Z+3	; 0x03
    11c4:	0a e0       	ldi	r16, 0x0A	; 10
    11c6:	15 dd       	rcall	.-1494   	; 0xbf2 <TCP_SetConnectionState>
    11c8:	34 c0       	rjmp	.+104    	; 0x1232 <TCP_ProcessTCPPacket+0x4ec>
		}
	}
	else
	{
		/* Port is not open, indicate via a RST/ACK response to the sender */
		TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
    11ca:	84 e1       	ldi	r24, 0x14	; 20
    11cc:	e6 01       	movw	r28, r12
    11ce:	8d 87       	std	Y+13, r24	; 0x0d
    11d0:	3e c0       	rjmp	.+124    	; 0x124e <TCP_ProcessTCPPacket+0x508>
    11d2:	82 e0       	ldi	r24, 0x02	; 2
    11d4:	90 e0       	ldi	r25, 0x00	; 0
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));

		if (!(ConnectionInfo->Buffer.InUse))
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE);
    11d6:	f6 01       	movw	r30, r12
    11d8:	97 87       	std	Z+15, r25	; 0x0f
    11da:	86 87       	std	Z+14, r24	; 0x0e
    11dc:	0c c0       	rjmp	.+24     	; 0x11f6 <TCP_ProcessTCPPacket+0x4b0>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    11de:	80 e0       	ldi	r24, 0x00	; 0
    11e0:	92 e0       	ldi	r25, 0x02	; 2
    11e2:	20 85       	ldd	r18, Z+8	; 0x08
    11e4:	31 85       	ldd	r19, Z+9	; 0x09
    11e6:	82 1b       	sub	r24, r18
    11e8:	93 0b       	sbc	r25, r19
		else
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length);
    11ea:	d6 01       	movw	r26, r12
    11ec:	1e 96       	adiw	r26, 0x0e	; 14
    11ee:	9c 93       	st	X, r25
    11f0:	1e 97       	sbiw	r26, 0x0e	; 14
    11f2:	1f 96       	adiw	r26, 0x0f	; 15
    11f4:	8c 93       	st	X, r24

		TCPHeaderOUT->UrgentPointer        = 0;
    11f6:	e6 01       	movw	r28, r12
    11f8:	1b 8a       	std	Y+19, r1	; 0x13
    11fa:	1a 8a       	std	Y+18, r1	; 0x12
		TCPHeaderOUT->Checksum             = 0;
    11fc:	19 8a       	std	Y+17, r1	; 0x11
    11fe:	18 8a       	std	Y+16, r1	; 0x10
		TCPHeaderOUT->Reserved             = 0;
    1200:	8c 85       	ldd	r24, Y+12	; 0x0c
    1202:	80 7f       	andi	r24, 0xF0	; 240
    1204:	8c 87       	std	Y+12, r24	; 0x0c

		TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, IPHeaderIN->DestinationAddress,
    1206:	f5 01       	movw	r30, r10
    1208:	40 89       	ldd	r20, Z+16	; 0x10
    120a:	51 89       	ldd	r21, Z+17	; 0x11
    120c:	62 89       	ldd	r22, Z+18	; 0x12
    120e:	73 89       	ldd	r23, Z+19	; 0x13
    1210:	04 85       	ldd	r16, Z+12	; 0x0c
    1212:	15 85       	ldd	r17, Z+13	; 0x0d
    1214:	26 85       	ldd	r18, Z+14	; 0x0e
    1216:	37 85       	ldd	r19, Z+15	; 0x0f
    1218:	c6 01       	movw	r24, r12
    121a:	e4 e1       	ldi	r30, 0x14	; 20
    121c:	ee 2e       	mov	r14, r30
    121e:	f1 2c       	mov	r15, r1
    1220:	70 db       	rcall	.-2336   	; 0x902 <TCP_Checksum16>
    1222:	99 8b       	std	Y+17, r25	; 0x11
    1224:	88 8b       	std	Y+16, r24	; 0x10
    1226:	24 e1       	ldi	r18, 0x14	; 20
    1228:	30 e0       	ldi	r19, 0x00	; 0
    122a:	05 c0       	rjmp	.+10     	; 0x1236 <TCP_ProcessTCPPacket+0x4f0>
		                                                    IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
    122c:	2f ef       	ldi	r18, 0xFF	; 255
    122e:	3f ef       	ldi	r19, 0xFF	; 255
    1230:	02 c0       	rjmp	.+4      	; 0x1236 <TCP_ProcessTCPPacket+0x4f0>
    1232:	20 e0       	ldi	r18, 0x00	; 0
    1234:	30 e0       	ldi	r19, 0x00	; 0
	}

	return NO_RESPONSE;
}
    1236:	c9 01       	movw	r24, r18
    1238:	df 91       	pop	r29
    123a:	cf 91       	pop	r28
    123c:	1f 91       	pop	r17
    123e:	0f 91       	pop	r16
    1240:	ff 90       	pop	r15
    1242:	ef 90       	pop	r14
    1244:	df 90       	pop	r13
    1246:	cf 90       	pop	r12
    1248:	bf 90       	pop	r11
    124a:	af 90       	pop	r10
    124c:	08 95       	ret
	}

	/* Check if we need to respond to the sent packet */
	if (PacketResponse)
	{
		ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    124e:	d5 01       	movw	r26, r10
    1250:	1c 96       	adiw	r26, 0x0c	; 12
    1252:	4d 91       	ld	r20, X+
    1254:	5d 91       	ld	r21, X+
    1256:	6d 91       	ld	r22, X+
    1258:	7c 91       	ld	r23, X
    125a:	1f 97       	sbiw	r26, 0x0f	; 15
    125c:	e7 01       	movw	r28, r14
    125e:	28 81       	ld	r18, Y
    1260:	39 81       	ldd	r19, Y+1	; 0x01
    1262:	8a 81       	ldd	r24, Y+2	; 0x02
    1264:	9b 81       	ldd	r25, Y+3	; 0x03
    1266:	f2 db       	rcall	.-2076   	; 0xa4c <TCP_GetConnectionInfo>
    1268:	fc 01       	movw	r30, r24
		                                       TCPHeaderIN->SourcePort);

		TCPHeaderOUT->SourcePort           = TCPHeaderIN->DestinationPort;
    126a:	8a 81       	ldd	r24, Y+2	; 0x02
    126c:	9b 81       	ldd	r25, Y+3	; 0x03
    126e:	d6 01       	movw	r26, r12
    1270:	11 96       	adiw	r26, 0x01	; 1
    1272:	9c 93       	st	X, r25
    1274:	8e 93       	st	-X, r24
		TCPHeaderOUT->DestinationPort      = TCPHeaderIN->SourcePort;
    1276:	88 81       	ld	r24, Y
    1278:	99 81       	ldd	r25, Y+1	; 0x01
    127a:	13 96       	adiw	r26, 0x03	; 3
    127c:	9c 93       	st	X, r25
    127e:	8e 93       	st	-X, r24
    1280:	12 97       	sbiw	r26, 0x02	; 2
				{
					uint32_t DWord;
					uint8_t  Bytes[4];
				} Data;

				Data.DWord = DWord;
    1282:	34 81       	ldd	r19, Z+4	; 0x04
    1284:	25 81       	ldd	r18, Z+5	; 0x05
    1286:	96 81       	ldd	r25, Z+6	; 0x06
    1288:	87 81       	ldd	r24, Z+7	; 0x07
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
    128a:	14 96       	adiw	r26, 0x04	; 4
    128c:	8c 93       	st	X, r24
    128e:	14 97       	sbiw	r26, 0x04	; 4
    1290:	15 96       	adiw	r26, 0x05	; 5
    1292:	9c 93       	st	X, r25
    1294:	15 97       	sbiw	r26, 0x05	; 5
    1296:	16 96       	adiw	r26, 0x06	; 6
    1298:	2c 93       	st	X, r18
    129a:	16 97       	sbiw	r26, 0x06	; 6
    129c:	17 96       	adiw	r26, 0x07	; 7
    129e:	3c 93       	st	X, r19
    12a0:	17 97       	sbiw	r26, 0x07	; 7
    12a2:	30 81       	ld	r19, Z
    12a4:	21 81       	ldd	r18, Z+1	; 0x01
    12a6:	92 81       	ldd	r25, Z+2	; 0x02
    12a8:	83 81       	ldd	r24, Z+3	; 0x03
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
    12aa:	18 96       	adiw	r26, 0x08	; 8
    12ac:	8c 93       	st	X, r24
    12ae:	18 97       	sbiw	r26, 0x08	; 8
    12b0:	19 96       	adiw	r26, 0x09	; 9
    12b2:	9c 93       	st	X, r25
    12b4:	19 97       	sbiw	r26, 0x09	; 9
    12b6:	1a 96       	adiw	r26, 0x0a	; 10
    12b8:	2c 93       	st	X, r18
    12ba:	1a 97       	sbiw	r26, 0x0a	; 10
    12bc:	1b 96       	adiw	r26, 0x0b	; 11
    12be:	3c 93       	st	X, r19
    12c0:	1b 97       	sbiw	r26, 0x0b	; 11
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
    12c2:	1c 96       	adiw	r26, 0x0c	; 12
    12c4:	8c 91       	ld	r24, X
    12c6:	1c 97       	sbiw	r26, 0x0c	; 12
    12c8:	8f 70       	andi	r24, 0x0F	; 15
    12ca:	80 65       	ori	r24, 0x50	; 80
    12cc:	1c 96       	adiw	r26, 0x0c	; 12
    12ce:	8c 93       	st	X, r24

		if (!(ConnectionInfo->Buffer.InUse))
    12d0:	e4 5f       	subi	r30, 0xF4	; 244
    12d2:	fd 4f       	sbci	r31, 0xFD	; 253
    12d4:	80 81       	ld	r24, Z
    12d6:	ec 50       	subi	r30, 0x0C	; 12
    12d8:	f2 40       	sbci	r31, 0x02	; 2
    12da:	88 23       	and	r24, r24
    12dc:	09 f4       	brne	.+2      	; 0x12e0 <TCP_ProcessTCPPacket+0x59a>
    12de:	79 cf       	rjmp	.-270    	; 0x11d2 <TCP_ProcessTCPPacket+0x48c>
    12e0:	7e cf       	rjmp	.-260    	; 0x11de <TCP_ProcessTCPPacket+0x498>

000012e2 <TCP_TCPTask>:
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
		         Ethernet_Frame_Info_t* const FrameOUT)
{
    12e2:	2f 92       	push	r2
    12e4:	3f 92       	push	r3
    12e6:	4f 92       	push	r4
    12e8:	5f 92       	push	r5
    12ea:	6f 92       	push	r6
    12ec:	7f 92       	push	r7
    12ee:	8f 92       	push	r8
    12f0:	9f 92       	push	r9
    12f2:	af 92       	push	r10
    12f4:	bf 92       	push	r11
    12f6:	cf 92       	push	r12
    12f8:	df 92       	push	r13
    12fa:	ef 92       	push	r14
    12fc:	ff 92       	push	r15
    12fe:	0f 93       	push	r16
    1300:	1f 93       	push	r17
    1302:	df 93       	push	r29
    1304:	cf 93       	push	r28
    1306:	00 d0       	rcall	.+0      	; 0x1308 <TCP_TCPTask+0x26>
    1308:	00 d0       	rcall	.+0      	; 0x130a <TCP_TCPTask+0x28>
    130a:	cd b7       	in	r28, 0x3d	; 61
    130c:	de b7       	in	r29, 0x3e	; 62
    130e:	7c 83       	std	Y+4, r23	; 0x04
    1310:	6b 83       	std	Y+3, r22	; 0x03
    1312:	95 eb       	ldi	r25, 0xB5	; 181
    1314:	c9 2e       	mov	r12, r25
    1316:	9d e0       	ldi	r25, 0x0D	; 13
    1318:	d9 2e       	mov	r13, r25
    131a:	00 e0       	ldi	r16, 0x00	; 0
    131c:	10 e0       	ldi	r17, 0x00	; 0
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
    131e:	86 e1       	ldi	r24, 0x16	; 22
    1320:	e8 2e       	mov	r14, r24
    1322:	82 e0       	ldi	r24, 0x02	; 2
    1324:	f8 2e       	mov	r15, r24
    1326:	1c c0       	rjmp	.+56     	; 0x1360 <TCP_TCPTask+0x7e>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
    1328:	80 91 f9 13 	lds	r24, 0x13F9
    132c:	81 30       	cpi	r24, 0x01	; 1
    132e:	79 f4       	brne	.+30     	; 0x134e <TCP_TCPTask+0x6c>
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
    1330:	0e 9d       	mul	r16, r14
    1332:	b0 01       	movw	r22, r0
    1334:	0f 9d       	mul	r16, r15
    1336:	70 0d       	add	r23, r0
    1338:	1e 9d       	mul	r17, r14
    133a:	70 0d       	add	r23, r0
    133c:	11 24       	eor	r1, r1
    133e:	6b 53       	subi	r22, 0x3B	; 59
    1340:	72 4f       	sbci	r23, 0xF2	; 242
    1342:	e0 91 fa 13 	lds	r30, 0x13FA
    1346:	f0 91 fb 13 	lds	r31, 0x13FB
    134a:	c6 01       	movw	r24, r12
    134c:	09 95       	icall
    134e:	0f 5f       	subi	r16, 0xFF	; 255
    1350:	1f 4f       	sbci	r17, 0xFF	; 255
    1352:	26 e1       	ldi	r18, 0x16	; 22
    1354:	32 e0       	ldi	r19, 0x02	; 2
    1356:	c2 0e       	add	r12, r18
    1358:	d3 1e       	adc	r13, r19
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
		         Ethernet_Frame_Info_t* const FrameOUT)
{
	/* Run each application in sequence, to process incoming and generate outgoing packets */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    135a:	03 30       	cpi	r16, 0x03	; 3
    135c:	11 05       	cpc	r17, r1
    135e:	59 f0       	breq	.+22     	; 0x1376 <TCP_TCPTask+0x94>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
    1360:	20 91 f7 13 	lds	r18, 0x13F7
    1364:	30 91 f8 13 	lds	r19, 0x13F8
    1368:	d6 01       	movw	r26, r12
    136a:	8d 91       	ld	r24, X+
    136c:	9c 91       	ld	r25, X
    136e:	28 17       	cp	r18, r24
    1370:	39 07       	cpc	r19, r25
    1372:	69 f7       	brne	.-38     	; 0x134e <TCP_TCPTask+0x6c>
    1374:	d9 cf       	rjmp	.-78     	; 0x1328 <TCP_TCPTask+0x46>
			}
		}
	}

	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT->FrameLength)
    1376:	eb 81       	ldd	r30, Y+3	; 0x03
    1378:	fc 81       	ldd	r31, Y+4	; 0x04
    137a:	e4 52       	subi	r30, 0x24	; 36
    137c:	fa 4f       	sbci	r31, 0xFA	; 250
    137e:	80 81       	ld	r24, Z
    1380:	91 81       	ldd	r25, Z+1	; 0x01
    1382:	ec 5d       	subi	r30, 0xDC	; 220
    1384:	f5 40       	sbci	r31, 0x05	; 5
    1386:	fc 83       	std	Y+4, r31	; 0x04
    1388:	eb 83       	std	Y+3, r30	; 0x03
    138a:	89 2b       	or	r24, r25
    138c:	09 f0       	breq	.+2      	; 0x1390 <TCP_TCPTask+0xae>
    138e:	17 c1       	rjmp	.+558    	; 0x15be <TCP_TCPTask+0x2dc>

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* For each completely received packet, pass it along to the listening application */
		if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction == TCP_PACKETDIR_OUT) &&
    1390:	80 91 c7 0f 	lds	r24, 0x0FC7
    1394:	88 23       	and	r24, r24
    1396:	39 f0       	breq	.+14     	; 0x13a6 <TCP_TCPTask+0xc4>
    1398:	80 91 c8 0f 	lds	r24, 0x0FC8
    139c:	88 23       	and	r24, r24
    139e:	19 f0       	breq	.+6      	; 0x13a6 <TCP_TCPTask+0xc4>
    13a0:	1a 82       	std	Y+2, r1	; 0x02
    13a2:	19 82       	std	Y+1, r1	; 0x01
    13a4:	1b c0       	rjmp	.+54     	; 0x13dc <TCP_TCPTask+0xfa>
    13a6:	80 91 dd 11 	lds	r24, 0x11DD
    13aa:	88 23       	and	r24, r24
    13ac:	49 f0       	breq	.+18     	; 0x13c0 <TCP_TCPTask+0xde>
    13ae:	80 91 de 11 	lds	r24, 0x11DE
    13b2:	88 23       	and	r24, r24
    13b4:	29 f0       	breq	.+10     	; 0x13c0 <TCP_TCPTask+0xde>
    13b6:	21 e0       	ldi	r18, 0x01	; 1
    13b8:	30 e0       	ldi	r19, 0x00	; 0
    13ba:	3a 83       	std	Y+2, r19	; 0x02
    13bc:	29 83       	std	Y+1, r18	; 0x01
    13be:	0e c0       	rjmp	.+28     	; 0x13dc <TCP_TCPTask+0xfa>
    13c0:	80 91 f3 13 	lds	r24, 0x13F3
    13c4:	88 23       	and	r24, r24
    13c6:	09 f4       	brne	.+2      	; 0x13ca <TCP_TCPTask+0xe8>
    13c8:	fa c0       	rjmp	.+500    	; 0x15be <TCP_TCPTask+0x2dc>
    13ca:	80 91 f4 13 	lds	r24, 0x13F4
    13ce:	88 23       	and	r24, r24
    13d0:	09 f4       	brne	.+2      	; 0x13d4 <TCP_TCPTask+0xf2>
    13d2:	f5 c0       	rjmp	.+490    	; 0x15be <TCP_TCPTask+0x2dc>
    13d4:	82 e0       	ldi	r24, 0x02	; 2
    13d6:	90 e0       	ldi	r25, 0x00	; 0
    13d8:	9a 83       	std	Y+2, r25	; 0x02
    13da:	89 83       	std	Y+1, r24	; 0x01
		    (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready))
		{
			Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;
			IP_Header_t*             IPHeaderOUT    = (IP_Header_t*)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)];
    13dc:	ab 80       	ldd	r10, Y+3	; 0x03
    13de:	bc 80       	ldd	r11, Y+4	; 0x04
    13e0:	ae e0       	ldi	r26, 0x0E	; 14
    13e2:	b0 e0       	ldi	r27, 0x00	; 0
    13e4:	aa 0e       	add	r10, r26
    13e6:	bb 1e       	adc	r11, r27
			TCP_Header_t*            TCPHeaderOUT   = (TCP_Header_t*)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                                              sizeof(IP_Header_t)];
    13e8:	cb 80       	ldd	r12, Y+3	; 0x03
    13ea:	dc 80       	ldd	r13, Y+4	; 0x04
    13ec:	e2 e2       	ldi	r30, 0x22	; 34
    13ee:	f0 e0       	ldi	r31, 0x00	; 0
    13f0:	ce 0e       	add	r12, r30
    13f2:	df 1e       	adc	r13, r31
			void*                    TCPDataOUT     = &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                               sizeof(IP_Header_t) +
			                                                               sizeof(TCP_Header_t)];

			uint16_t PacketSize = ConnectionStateTable[CSTableEntry].Info.Buffer.Length;
    13f4:	86 e1       	ldi	r24, 0x16	; 22
    13f6:	92 e0       	ldi	r25, 0x02	; 2
    13f8:	29 81       	ldd	r18, Y+1	; 0x01
    13fa:	3a 81       	ldd	r19, Y+2	; 0x02
    13fc:	28 9f       	mul	r18, r24
    13fe:	a0 01       	movw	r20, r0
    1400:	29 9f       	mul	r18, r25
    1402:	50 0d       	add	r21, r0
    1404:	38 9f       	mul	r19, r24
    1406:	50 0d       	add	r21, r0
    1408:	11 24       	eor	r1, r1
    140a:	05 eb       	ldi	r16, 0xB5	; 181
    140c:	80 2e       	mov	r8, r16
    140e:	0d e0       	ldi	r16, 0x0D	; 13
    1410:	90 2e       	mov	r9, r16
    1412:	84 0e       	add	r8, r20
    1414:	95 1e       	adc	r9, r21
    1416:	d4 01       	movw	r26, r8
    1418:	50 96       	adiw	r26, 0x10	; 16
    141a:	6d 90       	ld	r6, X+
    141c:	7c 90       	ld	r7, X
    141e:	51 97       	sbiw	r26, 0x11	; 17

			/* Fill out the TCP data */
			TCPHeaderOUT->SourcePort           = ConnectionStateTable[CSTableEntry].Port;
    1420:	8d 91       	ld	r24, X+
    1422:	9c 91       	ld	r25, X
    1424:	eb 81       	ldd	r30, Y+3	; 0x03
    1426:	fc 81       	ldd	r31, Y+4	; 0x04
    1428:	93 a3       	std	Z+35, r25	; 0x23
    142a:	82 a3       	std	Z+34, r24	; 0x22
			TCPHeaderOUT->DestinationPort      = ConnectionStateTable[CSTableEntry].RemotePort;
    142c:	8b e0       	ldi	r24, 0x0B	; 11
    142e:	91 e0       	ldi	r25, 0x01	; 1
    1430:	28 9f       	mul	r18, r24
    1432:	f0 01       	movw	r30, r0
    1434:	29 9f       	mul	r18, r25
    1436:	f0 0d       	add	r31, r0
    1438:	38 9f       	mul	r19, r24
    143a:	f0 0d       	add	r31, r0
    143c:	11 24       	eor	r1, r1
    143e:	ee 0f       	add	r30, r30
    1440:	ff 1f       	adc	r31, r31
    1442:	e9 54       	subi	r30, 0x49	; 73
    1444:	f2 4f       	sbci	r31, 0xF2	; 242
    1446:	80 81       	ld	r24, Z
    1448:	91 81       	ldd	r25, Z+1	; 0x01
    144a:	d6 01       	movw	r26, r12
    144c:	13 96       	adiw	r26, 0x03	; 3
    144e:	9c 93       	st	X, r25
    1450:	8e 93       	st	-X, r24
    1452:	12 97       	sbiw	r26, 0x02	; 2
    1454:	f4 01       	movw	r30, r8
    1456:	3c 96       	adiw	r30, 0x0c	; 12
    1458:	d4 01       	movw	r26, r8
    145a:	1c 96       	adiw	r26, 0x0c	; 12
    145c:	3c 91       	ld	r19, X
    145e:	1c 97       	sbiw	r26, 0x0c	; 12
    1460:	21 81       	ldd	r18, Z+1	; 0x01
    1462:	92 81       	ldd	r25, Z+2	; 0x02
    1464:	83 81       	ldd	r24, Z+3	; 0x03
			TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
    1466:	f6 01       	movw	r30, r12
    1468:	84 83       	std	Z+4, r24	; 0x04
    146a:	95 83       	std	Z+5, r25	; 0x05
    146c:	26 83       	std	Z+6, r18	; 0x06
    146e:	37 83       	std	Z+7, r19	; 0x07
    1470:	f4 01       	movw	r30, r8
    1472:	38 96       	adiw	r30, 0x08	; 8
    1474:	18 96       	adiw	r26, 0x08	; 8
    1476:	3c 91       	ld	r19, X
    1478:	21 81       	ldd	r18, Z+1	; 0x01
    147a:	92 81       	ldd	r25, Z+2	; 0x02
    147c:	83 81       	ldd	r24, Z+3	; 0x03
			TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
    147e:	f6 01       	movw	r30, r12
    1480:	80 87       	std	Z+8, r24	; 0x08
    1482:	91 87       	std	Z+9, r25	; 0x09
    1484:	22 87       	std	Z+10, r18	; 0x0a
    1486:	33 87       	std	Z+11, r19	; 0x0b

				Data.Word = Word;

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;
    1488:	82 e0       	ldi	r24, 0x02	; 2
    148a:	90 e0       	ldi	r25, 0x00	; 0
			TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
			TCPHeaderOUT->WindowSize           = SwapEndian_16(TCP_WINDOW_SIZE);
    148c:	97 87       	std	Z+15, r25	; 0x0f
    148e:	86 87       	std	Z+14, r24	; 0x0e

			TCPHeaderOUT->Flags                = TCP_FLAG_ACK;
    1490:	80 e1       	ldi	r24, 0x10	; 16
    1492:	85 87       	std	Z+13, r24	; 0x0d
			TCPHeaderOUT->UrgentPointer        = 0;
    1494:	13 8a       	std	Z+19, r1	; 0x13
    1496:	12 8a       	std	Z+18, r1	; 0x12
			TCPHeaderOUT->Checksum             = 0;
    1498:	11 8a       	std	Z+17, r1	; 0x11
    149a:	10 8a       	std	Z+16, r1	; 0x10
			TCPHeaderOUT->Reserved             = 0;
    149c:	80 e5       	ldi	r24, 0x50	; 80
    149e:	84 87       	std	Z+12, r24	; 0x0c

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);
    14a0:	2b 81       	ldd	r18, Y+3	; 0x03
    14a2:	3c 81       	ldd	r19, Y+4	; 0x04
    14a4:	2a 5c       	subi	r18, 0xCA	; 202
    14a6:	3f 4f       	sbci	r19, 0xFF	; 255
    14a8:	49 53       	subi	r20, 0x39	; 57
    14aa:	52 4f       	sbci	r21, 0xF2	; 242
    14ac:	c9 01       	movw	r24, r18
    14ae:	ba 01       	movw	r22, r20
    14b0:	a3 01       	movw	r20, r6
    14b2:	0e 94 86 17 	call	0x2f0c	; 0x2f0c <memcpy>

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;
    14b6:	c3 01       	movw	r24, r6
    14b8:	a0 e0       	ldi	r26, 0x00	; 0
    14ba:	b0 e0       	ldi	r27, 0x00	; 0
    14bc:	f4 01       	movw	r30, r8
    14be:	24 85       	ldd	r18, Z+12	; 0x0c
    14c0:	35 85       	ldd	r19, Z+13	; 0x0d
    14c2:	46 85       	ldd	r20, Z+14	; 0x0e
    14c4:	57 85       	ldd	r21, Z+15	; 0x0f
    14c6:	82 0f       	add	r24, r18
    14c8:	93 1f       	adc	r25, r19
    14ca:	a4 1f       	adc	r26, r20
    14cc:	b5 1f       	adc	r27, r21
    14ce:	84 87       	std	Z+12, r24	; 0x0c
    14d0:	95 87       	std	Z+13, r25	; 0x0d
    14d2:	a6 87       	std	Z+14, r26	; 0x0e
    14d4:	b7 87       	std	Z+15, r27	; 0x0f

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, ServerIPAddress,
    14d6:	24 e1       	ldi	r18, 0x14	; 20
    14d8:	30 e0       	ldi	r19, 0x00	; 0
    14da:	62 0e       	add	r6, r18
    14dc:	73 1e       	adc	r7, r19
    14de:	20 90 b9 01 	lds	r2, 0x01B9
    14e2:	30 90 ba 01 	lds	r3, 0x01BA
    14e6:	40 90 bb 01 	lds	r4, 0x01BB
    14ea:	50 90 bc 01 	lds	r5, 0x01BC
    14ee:	04 81       	ldd	r16, Z+4	; 0x04
    14f0:	15 81       	ldd	r17, Z+5	; 0x05
    14f2:	26 81       	ldd	r18, Z+6	; 0x06
    14f4:	37 81       	ldd	r19, Z+7	; 0x07
    14f6:	c6 01       	movw	r24, r12
    14f8:	b2 01       	movw	r22, r4
    14fa:	a1 01       	movw	r20, r2
    14fc:	73 01       	movw	r14, r6
    14fe:	01 da       	rcall	.-3070   	; 0x902 <TCP_Checksum16>
    1500:	d6 01       	movw	r26, r12
    1502:	51 96       	adiw	r26, 0x11	; 17
    1504:	9c 93       	st	X, r25
    1506:	8e 93       	st	-X, r24
    1508:	50 97       	sbiw	r26, 0x10	; 16
			                                                    (sizeof(TCP_Header_t) + PacketSize));

			PacketSize += sizeof(TCP_Header_t);

			/* Fill out the response IP header */
			IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
    150a:	83 01       	movw	r16, r6
    150c:	0c 5e       	subi	r16, 0xEC	; 236
    150e:	1f 4f       	sbci	r17, 0xFF	; 255
    1510:	f5 01       	movw	r30, r10
    1512:	12 83       	std	Z+2, r17	; 0x02
    1514:	03 83       	std	Z+3, r16	; 0x03
			IPHeaderOUT->TypeOfService      = 0;
    1516:	11 82       	std	Z+1, r1	; 0x01
			IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
			IPHeaderOUT->Version            = 4;
    1518:	85 e4       	ldi	r24, 0x45	; 69
    151a:	ab 81       	ldd	r26, Y+3	; 0x03
    151c:	bc 81       	ldd	r27, Y+4	; 0x04
    151e:	1e 96       	adiw	r26, 0x0e	; 14
    1520:	8c 93       	st	X, r24
			IPHeaderOUT->Flags              = 0;
			IPHeaderOUT->FragmentOffset     = 0;
    1522:	16 82       	std	Z+6, r1	; 0x06
    1524:	17 82       	std	Z+7, r1	; 0x07
			IPHeaderOUT->Identification     = 0;
    1526:	15 82       	std	Z+5, r1	; 0x05
    1528:	14 82       	std	Z+4, r1	; 0x04
			IPHeaderOUT->HeaderChecksum     = 0;
    152a:	13 86       	std	Z+11, r1	; 0x0b
    152c:	12 86       	std	Z+10, r1	; 0x0a
			IPHeaderOUT->Protocol           = PROTOCOL_TCP;
    152e:	86 e0       	ldi	r24, 0x06	; 6
    1530:	81 87       	std	Z+9, r24	; 0x09
			IPHeaderOUT->TTL                = DEFAULT_TTL;
    1532:	80 e8       	ldi	r24, 0x80	; 128
    1534:	80 87       	std	Z+8, r24	; 0x08
			IPHeaderOUT->SourceAddress      = ServerIPAddress;
    1536:	24 86       	std	Z+12, r2	; 0x0c
    1538:	35 86       	std	Z+13, r3	; 0x0d
    153a:	46 86       	std	Z+14, r4	; 0x0e
    153c:	57 86       	std	Z+15, r5	; 0x0f
			IPHeaderOUT->DestinationAddress = ConnectionStateTable[CSTableEntry].RemoteAddress;
    153e:	f4 01       	movw	r30, r8
    1540:	84 81       	ldd	r24, Z+4	; 0x04
    1542:	95 81       	ldd	r25, Z+5	; 0x05
    1544:	a6 81       	ldd	r26, Z+6	; 0x06
    1546:	b7 81       	ldd	r27, Z+7	; 0x07
    1548:	f5 01       	movw	r30, r10
    154a:	80 8b       	std	Z+16, r24	; 0x10
    154c:	91 8b       	std	Z+17, r25	; 0x11
    154e:	a2 8b       	std	Z+18, r26	; 0x12
    1550:	b3 8b       	std	Z+19, r27	; 0x13

			IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    1552:	c5 01       	movw	r24, r10
    1554:	64 e1       	ldi	r22, 0x14	; 20
    1556:	70 e0       	ldi	r23, 0x00	; 0
    1558:	59 d8       	rcall	.-3918   	; 0x60c <Ethernet_Checksum16>
    155a:	d5 01       	movw	r26, r10
    155c:	1b 96       	adiw	r26, 0x0b	; 11
    155e:	9c 93       	st	X, r25
    1560:	8e 93       	st	-X, r24
    1562:	1a 97       	sbiw	r26, 0x0a	; 10

			PacketSize += sizeof(IP_Header_t);

			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
    1564:	ab 81       	ldd	r26, Y+3	; 0x03
    1566:	bc 81       	ldd	r27, Y+4	; 0x04
    1568:	16 96       	adiw	r26, 0x06	; 6
    156a:	e3 eb       	ldi	r30, 0xB3	; 179
    156c:	f1 e0       	ldi	r31, 0x01	; 1
    156e:	86 e0       	ldi	r24, 0x06	; 6
    1570:	01 90       	ld	r0, Z+
    1572:	0d 92       	st	X+, r0
    1574:	81 50       	subi	r24, 0x01	; 1
    1576:	e1 f7       	brne	.-8      	; 0x1570 <TCP_TCPTask+0x28e>
			FrameOUTHeader->Destination     = (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
    1578:	ab 81       	ldd	r26, Y+3	; 0x03
    157a:	bc 81       	ldd	r27, Y+4	; 0x04
    157c:	eb ec       	ldi	r30, 0xCB	; 203
    157e:	f1 e0       	ldi	r31, 0x01	; 1
    1580:	86 e0       	ldi	r24, 0x06	; 6
    1582:	01 90       	ld	r0, Z+
    1584:	0d 92       	st	X+, r0
    1586:	81 50       	subi	r24, 0x01	; 1
    1588:	e1 f7       	brne	.-8      	; 0x1582 <TCP_TCPTask+0x2a0>
    158a:	88 e0       	ldi	r24, 0x08	; 8
    158c:	90 e0       	ldi	r25, 0x00	; 0
			FrameOUTHeader->EtherType       = SwapEndian_16(ETHERTYPE_IPV4);
    158e:	eb 81       	ldd	r30, Y+3	; 0x03
    1590:	fc 81       	ldd	r31, Y+4	; 0x04
    1592:	95 87       	std	Z+13, r25	; 0x0d
    1594:	84 87       	std	Z+12, r24	; 0x0c

			PacketSize += sizeof(Ethernet_Frame_Header_t);

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT->FrameLength           = PacketSize;
    1596:	e4 52       	subi	r30, 0x24	; 36
    1598:	fa 4f       	sbci	r31, 0xFA	; 250
    159a:	02 5f       	subi	r16, 0xF2	; 242
    159c:	1f 4f       	sbci	r17, 0xFF	; 255
    159e:	11 83       	std	Z+1, r17	; 0x01
    15a0:	00 83       	st	Z, r16

			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;
    15a2:	86 e1       	ldi	r24, 0x16	; 22
    15a4:	92 e0       	ldi	r25, 0x02	; 2
    15a6:	29 81       	ldd	r18, Y+1	; 0x01
    15a8:	3a 81       	ldd	r19, Y+2	; 0x02
    15aa:	28 9f       	mul	r18, r24
    15ac:	f0 01       	movw	r30, r0
    15ae:	29 9f       	mul	r18, r25
    15b0:	f0 0d       	add	r31, r0
    15b2:	38 9f       	mul	r19, r24
    15b4:	f0 0d       	add	r31, r0
    15b6:	11 24       	eor	r1, r1
    15b8:	e8 53       	subi	r30, 0x38	; 56
    15ba:	f0 4f       	sbci	r31, 0xF0	; 240
    15bc:	10 82       	st	Z, r1

			break;
		}
	}
}
    15be:	0f 90       	pop	r0
    15c0:	0f 90       	pop	r0
    15c2:	0f 90       	pop	r0
    15c4:	0f 90       	pop	r0
    15c6:	cf 91       	pop	r28
    15c8:	df 91       	pop	r29
    15ca:	1f 91       	pop	r17
    15cc:	0f 91       	pop	r16
    15ce:	ff 90       	pop	r15
    15d0:	ef 90       	pop	r14
    15d2:	df 90       	pop	r13
    15d4:	cf 90       	pop	r12
    15d6:	bf 90       	pop	r11
    15d8:	af 90       	pop	r10
    15da:	9f 90       	pop	r9
    15dc:	8f 90       	pop	r8
    15de:	7f 90       	pop	r7
    15e0:	6f 90       	pop	r6
    15e2:	5f 90       	pop	r5
    15e4:	4f 90       	pop	r4
    15e6:	3f 90       	pop	r3
    15e8:	2f 90       	pop	r2
    15ea:	08 95       	ret

000015ec <UDP_ProcessUDPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t UDP_ProcessUDPPacket(void* IPHeaderInStart,
                             void* UDPHeaderInStart,
                             void* UDPHeaderOutStart)
{
    15ec:	ef 92       	push	r14
    15ee:	ff 92       	push	r15
    15f0:	0f 93       	push	r16
    15f2:	1f 93       	push	r17
    15f4:	cf 93       	push	r28
    15f6:	df 93       	push	r29
    15f8:	7c 01       	movw	r14, r24
    15fa:	eb 01       	movw	r28, r22
    15fc:	8a 01       	movw	r16, r20
	UDP_Header_t* UDPHeaderIN  = (UDP_Header_t*)UDPHeaderInStart;
	UDP_Header_t* UDPHeaderOUT = (UDP_Header_t*)UDPHeaderOutStart;

	int16_t RetSize = NO_RESPONSE;

	DecodeUDPHeader(UDPHeaderInStart);
    15fe:	cb 01       	movw	r24, r22
    1600:	af d8       	rcall	.-3746   	; 0x760 <DecodeUDPHeader>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    1602:	8a 81       	ldd	r24, Y+2	; 0x02
    1604:	9b 81       	ldd	r25, Y+3	; 0x03

				Temp = Data.Bytes[0];
    1606:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    1608:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    160a:	92 2f       	mov	r25, r18

	switch (SwapEndian_16(UDPHeaderIN->DestinationPort))
    160c:	83 34       	cpi	r24, 0x43	; 67
    160e:	91 05       	cpc	r25, r1
    1610:	e9 f4       	brne	.+58     	; 0x164c <UDP_ProcessUDPPacket+0x60>
	{
		case UDP_PORT_DHCP_REQUEST:
			RetSize = DHCP_ProcessDHCPPacket(IPHeaderInStart,
    1612:	be 01       	movw	r22, r28
    1614:	68 5f       	subi	r22, 0xF8	; 248
    1616:	7f 4f       	sbci	r23, 0xFF	; 255
    1618:	a8 01       	movw	r20, r16
    161a:	48 5f       	subi	r20, 0xF8	; 248
    161c:	5f 4f       	sbci	r21, 0xFF	; 255
    161e:	c7 01       	movw	r24, r14
    1620:	1f d0       	rcall	.+62     	; 0x1660 <DHCP_ProcessDHCPPacket>
    1622:	9c 01       	movw	r18, r24
		                                     &((uint8_t*)UDPHeaderOutStart)[sizeof(UDP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    1624:	18 16       	cp	r1, r24
    1626:	19 06       	cpc	r1, r25
    1628:	8c f4       	brge	.+34     	; 0x164c <UDP_ProcessUDPPacket+0x60>
	{
		/* Fill out the response UDP packet header */
		UDPHeaderOUT->SourcePort      = UDPHeaderIN->DestinationPort;
    162a:	8a 81       	ldd	r24, Y+2	; 0x02
    162c:	9b 81       	ldd	r25, Y+3	; 0x03
    162e:	f8 01       	movw	r30, r16
    1630:	91 83       	std	Z+1, r25	; 0x01
    1632:	80 83       	st	Z, r24
		UDPHeaderOUT->DestinationPort = UDPHeaderIN->SourcePort;
    1634:	88 81       	ld	r24, Y
    1636:	99 81       	ldd	r25, Y+1	; 0x01
    1638:	93 83       	std	Z+3, r25	; 0x03
    163a:	82 83       	std	Z+2, r24	; 0x02
		UDPHeaderOUT->Checksum        = 0;
    163c:	17 82       	std	Z+7, r1	; 0x07
    163e:	16 82       	std	Z+6, r1	; 0x06
		UDPHeaderOUT->Length          = SwapEndian_16(sizeof(UDP_Header_t) + RetSize);
    1640:	c9 01       	movw	r24, r18
    1642:	08 96       	adiw	r24, 0x08	; 8
    1644:	94 83       	std	Z+4, r25	; 0x04
    1646:	85 83       	std	Z+5, r24	; 0x05

		/* Return the size of the response so far */
		return (sizeof(UDP_Header_t) + RetSize);
    1648:	9c 01       	movw	r18, r24
    164a:	02 c0       	rjmp	.+4      	; 0x1650 <UDP_ProcessUDPPacket+0x64>
    164c:	20 e0       	ldi	r18, 0x00	; 0
    164e:	30 e0       	ldi	r19, 0x00	; 0
	}

	return NO_RESPONSE;
}
    1650:	c9 01       	movw	r24, r18
    1652:	df 91       	pop	r29
    1654:	cf 91       	pop	r28
    1656:	1f 91       	pop	r17
    1658:	0f 91       	pop	r16
    165a:	ff 90       	pop	r15
    165c:	ef 90       	pop	r14
    165e:	08 95       	ret

00001660 <DHCP_ProcessDHCPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t DHCP_ProcessDHCPPacket(void* IPHeaderInStart,
                               void* DHCPHeaderInStart,
                               void* DHCPHeaderOutStart)
{
    1660:	8f 92       	push	r8
    1662:	9f 92       	push	r9
    1664:	af 92       	push	r10
    1666:	bf 92       	push	r11
    1668:	cf 92       	push	r12
    166a:	df 92       	push	r13
    166c:	ef 92       	push	r14
    166e:	ff 92       	push	r15
    1670:	0f 93       	push	r16
    1672:	1f 93       	push	r17
    1674:	cf 93       	push	r28
    1676:	df 93       	push	r29
    1678:	8b 01       	movw	r16, r22
    167a:	ea 01       	movw	r28, r20
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
    167c:	5c 01       	movw	r10, r24
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
    167e:	80 ef       	ldi	r24, 0xF0	; 240
    1680:	88 2e       	mov	r8, r24
    1682:	91 2c       	mov	r9, r1
    1684:	86 0e       	add	r8, r22
    1686:	97 1e       	adc	r9, r23
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));

	DecodeDHCPHeader(DHCPHeaderInStart);
    1688:	cb 01       	movw	r24, r22
    168a:	6b d8       	rcall	.-3882   	; 0x762 <DecodeDHCPHeader>

	/* Zero out the response DHCP packet, as much of it is legacy and left at 0 */
	memset(DHCPHeaderOUT, 0, sizeof(DHCP_Header_t));
    168c:	80 ef       	ldi	r24, 0xF0	; 240
    168e:	fe 01       	movw	r30, r28
    1690:	11 92       	st	Z+, r1
    1692:	8a 95       	dec	r24
    1694:	e9 f7       	brne	.-6      	; 0x1690 <DHCP_ProcessDHCPPacket+0x30>

	/* Fill out the response DHCP packet */
	DHCPHeaderOUT->HardwareType          = DHCPHeaderIN->HardwareType;
    1696:	f8 01       	movw	r30, r16
    1698:	81 81       	ldd	r24, Z+1	; 0x01
    169a:	89 83       	std	Y+1, r24	; 0x01
	DHCPHeaderOUT->Operation             = DHCP_OP_BOOTREPLY;
    169c:	82 e0       	ldi	r24, 0x02	; 2
    169e:	88 83       	st	Y, r24
	DHCPHeaderOUT->HardwareAddressLength = DHCPHeaderIN->HardwareAddressLength;
    16a0:	82 81       	ldd	r24, Z+2	; 0x02
    16a2:	8a 83       	std	Y+2, r24	; 0x02
	DHCPHeaderOUT->Hops                  = 0;
    16a4:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeaderOUT->TransactionID         = DHCPHeaderIN->TransactionID;
    16a6:	84 81       	ldd	r24, Z+4	; 0x04
    16a8:	95 81       	ldd	r25, Z+5	; 0x05
    16aa:	a6 81       	ldd	r26, Z+6	; 0x06
    16ac:	b7 81       	ldd	r27, Z+7	; 0x07
    16ae:	8c 83       	std	Y+4, r24	; 0x04
    16b0:	9d 83       	std	Y+5, r25	; 0x05
    16b2:	ae 83       	std	Y+6, r26	; 0x06
    16b4:	bf 83       	std	Y+7, r27	; 0x07
	DHCPHeaderOUT->ElapsedSeconds        = 0;
    16b6:	19 86       	std	Y+9, r1	; 0x09
    16b8:	18 86       	std	Y+8, r1	; 0x08
	DHCPHeaderOUT->Flags                 = DHCPHeaderIN->Flags;
    16ba:	82 85       	ldd	r24, Z+10	; 0x0a
    16bc:	93 85       	ldd	r25, Z+11	; 0x0b
    16be:	9b 87       	std	Y+11, r25	; 0x0b
    16c0:	8a 87       	std	Y+10, r24	; 0x0a
	DHCPHeaderOUT->YourIP                = ClientIPAddress;
    16c2:	c0 90 c7 01 	lds	r12, 0x01C7
    16c6:	d0 90 c8 01 	lds	r13, 0x01C8
    16ca:	e0 90 c9 01 	lds	r14, 0x01C9
    16ce:	f0 90 ca 01 	lds	r15, 0x01CA
    16d2:	c8 8a       	std	Y+16, r12	; 0x10
    16d4:	d9 8a       	std	Y+17, r13	; 0x11
    16d6:	ea 8a       	std	Y+18, r14	; 0x12
    16d8:	fb 8a       	std	Y+19, r15	; 0x13
	memmove(&DHCPHeaderOUT->ClientHardwareAddress, &DHCPHeaderIN->ClientHardwareAddress, sizeof(MAC_Address_t));
    16da:	04 5e       	subi	r16, 0xE4	; 228
    16dc:	1f 4f       	sbci	r17, 0xFF	; 255
    16de:	ce 01       	movw	r24, r28
    16e0:	4c 96       	adiw	r24, 0x1c	; 28
    16e2:	b8 01       	movw	r22, r16
    16e4:	46 e0       	ldi	r20, 0x06	; 6
    16e6:	50 e0       	ldi	r21, 0x00	; 0
    16e8:	0e 94 8f 17 	call	0x2f1e	; 0x2f1e <memmove>
				} Data;

				Data.DWord = DWord;

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[3];
    16ec:	83 e6       	ldi	r24, 0x63	; 99
    16ee:	93 e5       	ldi	r25, 0x53	; 83
    16f0:	a2 e8       	ldi	r26, 0x82	; 130
    16f2:	b3 e6       	ldi	r27, 0x63	; 99
				Data.Bytes[3] = Temp;
    16f4:	b3 e6       	ldi	r27, 0x63	; 99

				Temp = Data.Bytes[1];
    16f6:	29 2f       	mov	r18, r25
				Data.Bytes[1] = Data.Bytes[2];
    16f8:	9a 2f       	mov	r25, r26
				Data.Bytes[2] = Temp;
    16fa:	a2 2f       	mov	r26, r18
	DHCPHeaderOUT->Cookie                = SwapEndian_32(DHCP_MAGIC_COOKIE);
    16fc:	c4 51       	subi	r28, 0x14	; 20
    16fe:	df 4f       	sbci	r29, 0xFF	; 255
    1700:	88 83       	st	Y, r24
    1702:	99 83       	std	Y+1, r25	; 0x01
    1704:	aa 83       	std	Y+2, r26	; 0x02
    1706:	bb 83       	std	Y+3, r27	; 0x03
    1708:	cc 5e       	subi	r28, 0xEC	; 236
    170a:	d0 40       	sbci	r29, 0x00	; 0

	/* Alter the incoming IP packet header so that the corrected IP source and destinations are used - this means that
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
    170c:	f5 01       	movw	r30, r10
    170e:	c4 86       	std	Z+12, r12	; 0x0c
    1710:	d5 86       	std	Z+13, r13	; 0x0d
    1712:	e6 86       	std	Z+14, r14	; 0x0e
    1714:	f7 86       	std	Z+15, r15	; 0x0f
	IPHeaderIN->DestinationAddress = ServerIPAddress;
    1716:	80 91 b9 01 	lds	r24, 0x01B9
    171a:	90 91 ba 01 	lds	r25, 0x01BA
    171e:	a0 91 bb 01 	lds	r26, 0x01BB
    1722:	b0 91 bc 01 	lds	r27, 0x01BC
    1726:	80 8b       	std	Z+16, r24	; 0x10
    1728:	91 8b       	std	Z+17, r25	; 0x11
    172a:	a2 8b       	std	Z+18, r26	; 0x12
    172c:	b3 8b       	std	Z+19, r27	; 0x13
    172e:	5b c0       	rjmp	.+182    	; 0x17e6 <DHCP_ProcessDHCPPacket+0x186>

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
	{
		/* Find the Message Type DHCP option, to determine the type of DHCP packet */
		if (DHCPOptionsINStart[0] == DHCP_OPTION_MESSAGETYPE)
    1730:	85 33       	cpi	r24, 0x35	; 53
    1732:	09 f0       	breq	.+2      	; 0x1736 <DHCP_ProcessDHCPPacket+0xd6>
    1734:	4d c0       	rjmp	.+154    	; 0x17d0 <DHCP_ProcessDHCPPacket+0x170>
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
    1736:	94 01       	movw	r18, r8
    1738:	2e 5f       	subi	r18, 0xFE	; 254
    173a:	3f 4f       	sbci	r19, 0xFF	; 255
    173c:	f4 01       	movw	r30, r8
    173e:	82 81       	ldd	r24, Z+2	; 0x02
    1740:	81 30       	cpi	r24, 0x01	; 1
    1742:	19 f0       	breq	.+6      	; 0x174a <DHCP_ProcessDHCPPacket+0xea>
    1744:	83 30       	cpi	r24, 0x03	; 3
    1746:	09 f0       	breq	.+2      	; 0x174a <DHCP_ProcessDHCPPacket+0xea>
    1748:	48 c0       	rjmp	.+144    	; 0x17da <DHCP_ProcessDHCPPacket+0x17a>
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));
    174a:	fe 01       	movw	r30, r28
    174c:	e0 51       	subi	r30, 0x10	; 16
    174e:	ff 4f       	sbci	r31, 0xFF	; 255
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
			{
				/* Fill out the response DHCP packet options for a DHCP OFFER or ACK response */

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_MESSAGETYPE;
    1750:	df 01       	movw	r26, r30
    1752:	85 e3       	ldi	r24, 0x35	; 53
    1754:	8d 93       	st	X+, r24
				*(DHCPOptionsOUTStart++) = 1;
    1756:	81 e0       	ldi	r24, 0x01	; 1
    1758:	81 83       	std	Z+1, r24	; 0x01
    175a:	ed 01       	movw	r28, r26
    175c:	21 96       	adiw	r28, 0x01	; 1
				*(DHCPOptionsOUTStart++) = (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) ? DHCP_MESSAGETYPE_OFFER
    175e:	f9 01       	movw	r30, r18
    1760:	80 81       	ld	r24, Z
    1762:	81 30       	cpi	r24, 0x01	; 1
    1764:	11 f0       	breq	.+4      	; 0x176a <DHCP_ProcessDHCPPacket+0x10a>
    1766:	85 e0       	ldi	r24, 0x05	; 5
    1768:	01 c0       	rjmp	.+2      	; 0x176c <DHCP_ProcessDHCPPacket+0x10c>
    176a:	82 e0       	ldi	r24, 0x02	; 2
    176c:	11 96       	adiw	r26, 0x01	; 1
    176e:	8c 93       	st	X, r24
    1770:	fe 01       	movw	r30, r28
    1772:	31 96       	adiw	r30, 0x01	; 1
																								: DHCP_MESSAGETYPE_ACK;

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_SUBNETMASK;
    1774:	81 e0       	ldi	r24, 0x01	; 1
    1776:	89 83       	std	Y+1, r24	; 0x01
    1778:	cf 01       	movw	r24, r30
    177a:	01 96       	adiw	r24, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 4;
    177c:	34 e0       	ldi	r19, 0x04	; 4
    177e:	31 83       	std	Z+1, r19	; 0x01
    1780:	dc 01       	movw	r26, r24
    1782:	11 96       	adiw	r26, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    1784:	2f ef       	ldi	r18, 0xFF	; 255
    1786:	fc 01       	movw	r30, r24
    1788:	21 83       	std	Z+1, r18	; 0x01
    178a:	fd 01       	movw	r30, r26
    178c:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    178e:	11 96       	adiw	r26, 0x01	; 1
    1790:	2c 93       	st	X, r18
    1792:	df 01       	movw	r26, r30
    1794:	11 96       	adiw	r26, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    1796:	21 83       	std	Z+1, r18	; 0x01
    1798:	fd 01       	movw	r30, r26
    179a:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0x00;
    179c:	11 96       	adiw	r26, 0x01	; 1
    179e:	1c 92       	st	X, r1
    17a0:	df 01       	movw	r26, r30
    17a2:	11 96       	adiw	r26, 0x01	; 1

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_DHCPSERVER;
    17a4:	86 e3       	ldi	r24, 0x36	; 54
    17a6:	81 83       	std	Z+1, r24	; 0x01
    17a8:	fd 01       	movw	r30, r26
    17aa:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = sizeof(IP_Address_t);
    17ac:	11 96       	adiw	r26, 0x01	; 1
    17ae:	3c 93       	st	X, r19
				memcpy(DHCPOptionsOUTStart, &ServerIPAddress, sizeof(IP_Address_t));
    17b0:	80 91 b9 01 	lds	r24, 0x01B9
    17b4:	90 91 ba 01 	lds	r25, 0x01BA
    17b8:	a0 91 bb 01 	lds	r26, 0x01BB
    17bc:	b0 91 bc 01 	lds	r27, 0x01BC
    17c0:	81 83       	std	Z+1, r24	; 0x01
    17c2:	92 83       	std	Z+2, r25	; 0x02
    17c4:	a3 83       	std	Z+3, r26	; 0x03
    17c6:	b4 83       	std	Z+4, r27	; 0x04
				DHCPOptionsOUTStart     += sizeof(IP_Address_t);

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_END;
    17c8:	25 83       	std	Z+5, r18	; 0x05
    17ca:	20 e0       	ldi	r18, 0x00	; 0
    17cc:	31 e0       	ldi	r19, 0x01	; 1
    17ce:	12 c0       	rjmp	.+36     	; 0x17f4 <DHCP_ProcessDHCPPacket+0x194>
				return (sizeof(DHCP_Header_t) + 12 + sizeof(IP_Address_t));
			}
		}

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
    17d0:	88 23       	and	r24, r24
    17d2:	19 f4       	brne	.+6      	; 0x17da <DHCP_ProcessDHCPPacket+0x17a>
    17d4:	81 e0       	ldi	r24, 0x01	; 1
    17d6:	90 e0       	ldi	r25, 0x00	; 0
    17d8:	04 c0       	rjmp	.+8      	; 0x17e2 <DHCP_ProcessDHCPPacket+0x182>
    17da:	f4 01       	movw	r30, r8
    17dc:	81 81       	ldd	r24, Z+1	; 0x01
    17de:	90 e0       	ldi	r25, 0x00	; 0
    17e0:	02 96       	adiw	r24, 0x02	; 2
    17e2:	88 0e       	add	r8, r24
    17e4:	99 1e       	adc	r9, r25
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
	IPHeaderIN->DestinationAddress = ServerIPAddress;

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
    17e6:	f4 01       	movw	r30, r8
    17e8:	80 81       	ld	r24, Z
    17ea:	8f 3f       	cpi	r24, 0xFF	; 255
    17ec:	09 f0       	breq	.+2      	; 0x17f0 <DHCP_ProcessDHCPPacket+0x190>
    17ee:	a0 cf       	rjmp	.-192    	; 0x1730 <DHCP_ProcessDHCPPacket+0xd0>
    17f0:	20 e0       	ldi	r18, 0x00	; 0
    17f2:	30 e0       	ldi	r19, 0x00	; 0
		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
	}

	return NO_RESPONSE;
}
    17f4:	c9 01       	movw	r24, r18
    17f6:	df 91       	pop	r29
    17f8:	cf 91       	pop	r28
    17fa:	1f 91       	pop	r17
    17fc:	0f 91       	pop	r16
    17fe:	ff 90       	pop	r15
    1800:	ef 90       	pop	r14
    1802:	df 90       	pop	r13
    1804:	cf 90       	pop	r12
    1806:	bf 90       	pop	r11
    1808:	af 90       	pop	r10
    180a:	9f 90       	pop	r9
    180c:	8f 90       	pop	r8
    180e:	08 95       	ret

00001810 <ARP_ProcessARPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ARP_ProcessARPPacket(void* InDataStart,
                             void* OutDataStart)
{
    1810:	ef 92       	push	r14
    1812:	ff 92       	push	r15
    1814:	0f 93       	push	r16
    1816:	1f 93       	push	r17
    1818:	cf 93       	push	r28
    181a:	df 93       	push	r29
    181c:	18 2f       	mov	r17, r24
    181e:	09 2f       	mov	r16, r25
    1820:	f6 2e       	mov	r15, r22
    1822:	e7 2e       	mov	r14, r23
	DecodeARPHeader(InDataStart);
    1824:	0e 94 ac 03 	call	0x758	; 0x758 <DecodeARPHeader>

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
    1828:	c1 2f       	mov	r28, r17
    182a:	d0 2f       	mov	r29, r16
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    182c:	8a 81       	ldd	r24, Y+2	; 0x02
    182e:	9b 81       	ldd	r25, Y+3	; 0x03

				Temp = Data.Bytes[0];
    1830:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    1832:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    1834:	92 2f       	mov	r25, r18
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    1836:	80 50       	subi	r24, 0x00	; 0
    1838:	98 40       	sbci	r25, 0x08	; 8
    183a:	09 f0       	breq	.+2      	; 0x183e <ARP_ProcessARPPacket+0x2e>
    183c:	5e c0       	rjmp	.+188    	; 0x18fa <ARP_ProcessARPPacket+0xea>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    183e:	8e 81       	ldd	r24, Y+6	; 0x06
    1840:	9f 81       	ldd	r25, Y+7	; 0x07

				Temp = Data.Bytes[0];
    1842:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    1844:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    1846:	92 2f       	mov	r25, r18
    1848:	01 97       	sbiw	r24, 0x01	; 1
    184a:	09 f0       	breq	.+2      	; 0x184e <ARP_ProcessARPPacket+0x3e>
    184c:	56 c0       	rjmp	.+172    	; 0x18fa <ARP_ProcessARPPacket+0xea>
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    184e:	ce 01       	movw	r24, r28
    1850:	48 96       	adiw	r24, 0x18	; 24
    1852:	69 eb       	ldi	r22, 0xB9	; 185
    1854:	71 e0       	ldi	r23, 0x01	; 1
    1856:	44 e0       	ldi	r20, 0x04	; 4
    1858:	50 e0       	ldi	r21, 0x00	; 0
    185a:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <memcmp>
    185e:	00 97       	sbiw	r24, 0x00	; 0
    1860:	59 f0       	breq	.+22     	; 0x1878 <ARP_ProcessARPPacket+0x68>
    1862:	ce 01       	movw	r24, r28
    1864:	42 96       	adiw	r24, 0x12	; 18
    1866:	63 eb       	ldi	r22, 0xB3	; 179
    1868:	71 e0       	ldi	r23, 0x01	; 1
    186a:	46 e0       	ldi	r20, 0x06	; 6
    186c:	50 e0       	ldi	r21, 0x00	; 0
    186e:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <memcmp>
    1872:	00 97       	sbiw	r24, 0x00	; 0
    1874:	09 f0       	breq	.+2      	; 0x1878 <ARP_ProcessARPPacket+0x68>
    1876:	41 c0       	rjmp	.+130    	; 0x18fa <ARP_ProcessARPPacket+0xea>
                             void* OutDataStart)
{
	DecodeARPHeader(InDataStart);

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;
    1878:	ef 2d       	mov	r30, r15
    187a:	fe 2d       	mov	r31, r14
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
		{
			/* Fill out the ARP response header */
			ARPHeaderOUT->HardwareType = ARPHeaderIN->HardwareType;
    187c:	88 81       	ld	r24, Y
    187e:	99 81       	ldd	r25, Y+1	; 0x01
    1880:	91 83       	std	Z+1, r25	; 0x01
    1882:	80 83       	st	Z, r24
			ARPHeaderOUT->ProtocolType = ARPHeaderIN->ProtocolType;
    1884:	8a 81       	ldd	r24, Y+2	; 0x02
    1886:	9b 81       	ldd	r25, Y+3	; 0x03
    1888:	93 83       	std	Z+3, r25	; 0x03
    188a:	82 83       	std	Z+2, r24	; 0x02
			ARPHeaderOUT->HLEN         = ARPHeaderIN->HLEN;
    188c:	8c 81       	ldd	r24, Y+4	; 0x04
    188e:	84 83       	std	Z+4, r24	; 0x04
			ARPHeaderOUT->PLEN         = ARPHeaderIN->PLEN;
    1890:	8d 81       	ldd	r24, Y+5	; 0x05
    1892:	85 83       	std	Z+5, r24	; 0x05
    1894:	80 e0       	ldi	r24, 0x00	; 0
    1896:	92 e0       	ldi	r25, 0x02	; 2
			ARPHeaderOUT->Operation    = SwapEndian_16(ARP_OPERATION_REPLY);
    1898:	97 83       	std	Z+7, r25	; 0x07
    189a:	86 83       	std	Z+6, r24	; 0x06

			/* Copy over the sender MAC/IP to the target fields for the response */
			ARPHeaderOUT->THA = ARPHeaderIN->SHA;
    189c:	9f 01       	movw	r18, r30
    189e:	2e 5e       	subi	r18, 0xEE	; 238
    18a0:	3f 4f       	sbci	r19, 0xFF	; 255
    18a2:	ae 01       	movw	r20, r28
    18a4:	48 5f       	subi	r20, 0xF8	; 248
    18a6:	5f 4f       	sbci	r21, 0xFF	; 255
    18a8:	86 e0       	ldi	r24, 0x06	; 6
    18aa:	da 01       	movw	r26, r20
    18ac:	0d 90       	ld	r0, X+
    18ae:	ad 01       	movw	r20, r26
    18b0:	d9 01       	movw	r26, r18
    18b2:	0d 92       	st	X+, r0
    18b4:	9d 01       	movw	r18, r26
    18b6:	81 50       	subi	r24, 0x01	; 1
    18b8:	c1 f7       	brne	.-16     	; 0x18aa <ARP_ProcessARPPacket+0x9a>
			ARPHeaderOUT->TPA = ARPHeaderIN->SPA;
    18ba:	8e 85       	ldd	r24, Y+14	; 0x0e
    18bc:	9f 85       	ldd	r25, Y+15	; 0x0f
    18be:	a8 89       	ldd	r26, Y+16	; 0x10
    18c0:	b9 89       	ldd	r27, Y+17	; 0x11
    18c2:	80 8f       	std	Z+24, r24	; 0x18
    18c4:	91 8f       	std	Z+25, r25	; 0x19
    18c6:	a2 8f       	std	Z+26, r26	; 0x1a
    18c8:	b3 8f       	std	Z+27, r27	; 0x1b

			/* Copy over the new sender MAC/IP - MAC and IP addresses of the virtual webserver */
			ARPHeaderOUT->SHA = ServerMACAddress;
    18ca:	ef 01       	movw	r28, r30
    18cc:	28 96       	adiw	r28, 0x08	; 8
    18ce:	a3 eb       	ldi	r26, 0xB3	; 179
    18d0:	b1 e0       	ldi	r27, 0x01	; 1
    18d2:	86 e0       	ldi	r24, 0x06	; 6
    18d4:	0d 90       	ld	r0, X+
    18d6:	09 92       	st	Y+, r0
    18d8:	81 50       	subi	r24, 0x01	; 1
    18da:	e1 f7       	brne	.-8      	; 0x18d4 <ARP_ProcessARPPacket+0xc4>
			ARPHeaderOUT->SPA = ServerIPAddress;
    18dc:	80 91 b9 01 	lds	r24, 0x01B9
    18e0:	90 91 ba 01 	lds	r25, 0x01BA
    18e4:	a0 91 bb 01 	lds	r26, 0x01BB
    18e8:	b0 91 bc 01 	lds	r27, 0x01BC
    18ec:	86 87       	std	Z+14, r24	; 0x0e
    18ee:	97 87       	std	Z+15, r25	; 0x0f
    18f0:	a0 8b       	std	Z+16, r26	; 0x10
    18f2:	b1 8b       	std	Z+17, r27	; 0x11
    18f4:	2c e1       	ldi	r18, 0x1C	; 28
    18f6:	30 e0       	ldi	r19, 0x00	; 0
    18f8:	02 c0       	rjmp	.+4      	; 0x18fe <ARP_ProcessARPPacket+0xee>

			/* Return the size of the response so far */
			return sizeof(ARP_Header_t);
    18fa:	20 e0       	ldi	r18, 0x00	; 0
    18fc:	30 e0       	ldi	r19, 0x00	; 0
		}
	}

	return NO_RESPONSE;
}
    18fe:	c9 01       	movw	r24, r18
    1900:	df 91       	pop	r29
    1902:	cf 91       	pop	r28
    1904:	1f 91       	pop	r17
    1906:	0f 91       	pop	r16
    1908:	ff 90       	pop	r15
    190a:	ef 90       	pop	r14
    190c:	08 95       	ret

0000190e <IP_ProcessIPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t IP_ProcessIPPacket(Ethernet_Frame_Info_t* const FrameIN,
                           void* InDataStart,
                           void* OutDataStart)
{
    190e:	af 92       	push	r10
    1910:	bf 92       	push	r11
    1912:	df 92       	push	r13
    1914:	ef 92       	push	r14
    1916:	ff 92       	push	r15
    1918:	0f 93       	push	r16
    191a:	1f 93       	push	r17
    191c:	cf 93       	push	r28
    191e:	df 93       	push	r29
    1920:	5c 01       	movw	r10, r24
    1922:	7b 01       	movw	r14, r22
    1924:	ea 01       	movw	r28, r20
	DecodeIPHeader(InDataStart);
    1926:	cb 01       	movw	r24, r22
    1928:	0e 94 ad 03 	call	0x75a	; 0x75a <DecodeIPHeader>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    192c:	f7 01       	movw	r30, r14
    192e:	d0 80       	ld	r13, Z
    1930:	ff e0       	ldi	r31, 0x0F	; 15
    1932:	df 22       	and	r13, r31

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    1934:	87 01       	movw	r16, r14
    1936:	00 5f       	subi	r16, 0xF0	; 240
    1938:	1f 4f       	sbci	r17, 0xFF	; 255
    193a:	c8 01       	movw	r24, r16
    193c:	69 eb       	ldi	r22, 0xB9	; 185
    193e:	71 e0       	ldi	r23, 0x01	; 1
    1940:	44 e0       	ldi	r20, 0x04	; 4
    1942:	50 e0       	ldi	r21, 0x00	; 0
    1944:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <memcmp>
    1948:	00 97       	sbiw	r24, 0x00	; 0
    194a:	49 f0       	breq	.+18     	; 0x195e <IP_ProcessIPPacket+0x50>
    194c:	c8 01       	movw	r24, r16
    194e:	63 ec       	ldi	r22, 0xC3	; 195
    1950:	71 e0       	ldi	r23, 0x01	; 1
    1952:	44 e0       	ldi	r20, 0x04	; 4
    1954:	50 e0       	ldi	r21, 0x00	; 0
    1956:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <memcmp>
    195a:	00 97       	sbiw	r24, 0x00	; 0
    195c:	71 f4       	brne	.+28     	; 0x197a <IP_ProcessIPPacket+0x6c>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    195e:	6d 2d       	mov	r22, r13
    1960:	70 e0       	ldi	r23, 0x00	; 0
    1962:	66 0f       	add	r22, r22
    1964:	77 1f       	adc	r23, r23
    1966:	66 0f       	add	r22, r22
    1968:	77 1f       	adc	r23, r23
	{
		return NO_RESPONSE;
	}

	/* Pass off the IP payload to the appropriate protocol processing routine */
	switch (IPHeaderIN->Protocol)
    196a:	f7 01       	movw	r30, r14
    196c:	81 85       	ldd	r24, Z+9	; 0x09
    196e:	86 30       	cpi	r24, 0x06	; 6
    1970:	81 f0       	breq	.+32     	; 0x1992 <IP_ProcessIPPacket+0x84>
    1972:	81 31       	cpi	r24, 0x11	; 17
    1974:	b1 f0       	breq	.+44     	; 0x19a2 <IP_ProcessIPPacket+0x94>
    1976:	81 30       	cpi	r24, 0x01	; 1
    1978:	19 f0       	breq	.+6      	; 0x1980 <IP_ProcessIPPacket+0x72>
    197a:	20 e0       	ldi	r18, 0x00	; 0
    197c:	30 e0       	ldi	r19, 0x00	; 0
    197e:	47 c0       	rjmp	.+142    	; 0x1a0e <IP_ProcessIPPacket+0x100>
	{
		case PROTOCOL_ICMP:
			RetSize = ICMP_ProcessICMPPacket(FrameIN,
    1980:	6e 0d       	add	r22, r14
    1982:	7f 1d       	adc	r23, r15
    1984:	ae 01       	movw	r20, r28
    1986:	4c 5e       	subi	r20, 0xEC	; 236
    1988:	5f 4f       	sbci	r21, 0xFF	; 255
    198a:	c5 01       	movw	r24, r10
    198c:	0e 94 b2 03 	call	0x764	; 0x764 <ICMP_ProcessICMPPacket>
    1990:	0f c0       	rjmp	.+30     	; 0x19b0 <IP_ProcessIPPacket+0xa2>
			                                 &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                                 &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
		case PROTOCOL_TCP:
			RetSize = TCP_ProcessTCPPacket(InDataStart,
    1992:	6e 0d       	add	r22, r14
    1994:	7f 1d       	adc	r23, r15
    1996:	ae 01       	movw	r20, r28
    1998:	4c 5e       	subi	r20, 0xEC	; 236
    199a:	5f 4f       	sbci	r21, 0xFF	; 255
    199c:	c7 01       	movw	r24, r14
    199e:	d3 d9       	rcall	.-3162   	; 0xd46 <TCP_ProcessTCPPacket>
    19a0:	07 c0       	rjmp	.+14     	; 0x19b0 <IP_ProcessIPPacket+0xa2>
			                               &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
		case PROTOCOL_UDP:
			RetSize = UDP_ProcessUDPPacket(InDataStart,
    19a2:	6e 0d       	add	r22, r14
    19a4:	7f 1d       	adc	r23, r15
    19a6:	ae 01       	movw	r20, r28
    19a8:	4c 5e       	subi	r20, 0xEC	; 236
    19aa:	5f 4f       	sbci	r21, 0xFF	; 255
    19ac:	c7 01       	movw	r24, r14
    19ae:	1e de       	rcall	.-964    	; 0x15ec <UDP_ProcessUDPPacket>
    19b0:	9c 01       	movw	r18, r24
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    19b2:	18 16       	cp	r1, r24
    19b4:	19 06       	cpc	r1, r25
    19b6:	5c f5       	brge	.+86     	; 0x1a0e <IP_ProcessIPPacket+0x100>
	{
		/* Fill out the response IP packet header */
		IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + RetSize);
    19b8:	8c 01       	movw	r16, r24
    19ba:	0c 5e       	subi	r16, 0xEC	; 236
    19bc:	1f 4f       	sbci	r17, 0xFF	; 255
    19be:	1a 83       	std	Y+2, r17	; 0x02
    19c0:	0b 83       	std	Y+3, r16	; 0x03
		IPHeaderOUT->TypeOfService      = 0;
    19c2:	19 82       	std	Y+1, r1	; 0x01
		IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
		IPHeaderOUT->Version            = 4;
    19c4:	85 e4       	ldi	r24, 0x45	; 69
    19c6:	88 83       	st	Y, r24
		IPHeaderOUT->Flags              = 0;
		IPHeaderOUT->FragmentOffset     = 0;
    19c8:	1e 82       	std	Y+6, r1	; 0x06
    19ca:	1f 82       	std	Y+7, r1	; 0x07
		IPHeaderOUT->Identification     = 0;
    19cc:	1d 82       	std	Y+5, r1	; 0x05
    19ce:	1c 82       	std	Y+4, r1	; 0x04
		IPHeaderOUT->HeaderChecksum     = 0;
    19d0:	1b 86       	std	Y+11, r1	; 0x0b
    19d2:	1a 86       	std	Y+10, r1	; 0x0a
		IPHeaderOUT->Protocol           = IPHeaderIN->Protocol;
    19d4:	f7 01       	movw	r30, r14
    19d6:	81 85       	ldd	r24, Z+9	; 0x09
    19d8:	89 87       	std	Y+9, r24	; 0x09
		IPHeaderOUT->TTL                = DEFAULT_TTL;
    19da:	80 e8       	ldi	r24, 0x80	; 128
    19dc:	88 87       	std	Y+8, r24	; 0x08
		IPHeaderOUT->SourceAddress      = IPHeaderIN->DestinationAddress;
    19de:	80 89       	ldd	r24, Z+16	; 0x10
    19e0:	91 89       	ldd	r25, Z+17	; 0x11
    19e2:	a2 89       	ldd	r26, Z+18	; 0x12
    19e4:	b3 89       	ldd	r27, Z+19	; 0x13
    19e6:	8c 87       	std	Y+12, r24	; 0x0c
    19e8:	9d 87       	std	Y+13, r25	; 0x0d
    19ea:	ae 87       	std	Y+14, r26	; 0x0e
    19ec:	bf 87       	std	Y+15, r27	; 0x0f
		IPHeaderOUT->DestinationAddress = IPHeaderIN->SourceAddress;
    19ee:	84 85       	ldd	r24, Z+12	; 0x0c
    19f0:	95 85       	ldd	r25, Z+13	; 0x0d
    19f2:	a6 85       	ldd	r26, Z+14	; 0x0e
    19f4:	b7 85       	ldd	r27, Z+15	; 0x0f
    19f6:	88 8b       	std	Y+16, r24	; 0x10
    19f8:	99 8b       	std	Y+17, r25	; 0x11
    19fa:	aa 8b       	std	Y+18, r26	; 0x12
    19fc:	bb 8b       	std	Y+19, r27	; 0x13

		IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    19fe:	ce 01       	movw	r24, r28
    1a00:	64 e1       	ldi	r22, 0x14	; 20
    1a02:	70 e0       	ldi	r23, 0x00	; 0
    1a04:	0e 94 06 03 	call	0x60c	; 0x60c <Ethernet_Checksum16>
    1a08:	9b 87       	std	Y+11, r25	; 0x0b
    1a0a:	8a 87       	std	Y+10, r24	; 0x0a

		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
    1a0c:	98 01       	movw	r18, r16
	}

	return RetSize;
}
    1a0e:	c9 01       	movw	r24, r18
    1a10:	df 91       	pop	r29
    1a12:	cf 91       	pop	r28
    1a14:	1f 91       	pop	r17
    1a16:	0f 91       	pop	r16
    1a18:	ff 90       	pop	r15
    1a1a:	ef 90       	pop	r14
    1a1c:	df 90       	pop	r13
    1a1e:	bf 90       	pop	r11
    1a20:	af 90       	pop	r10
    1a22:	08 95       	ret

00001a24 <IsHTTPCommand>:
 */
static bool IsHTTPCommand(uint8_t* RequestHeader,
                          char* Command)
{
	/* Returns true if the non null terminated string in RequestHeader matches the null terminated string Command */
	return (strncmp((char*)RequestHeader, Command, strlen(Command)) == 0);
    1a24:	db 01       	movw	r26, r22
    1a26:	0d 90       	ld	r0, X+
    1a28:	00 20       	and	r0, r0
    1a2a:	e9 f7       	brne	.-6      	; 0x1a26 <IsHTTPCommand+0x2>
    1a2c:	11 97       	sbiw	r26, 0x01	; 1
    1a2e:	a6 1b       	sub	r26, r22
    1a30:	b7 0b       	sbc	r27, r23
    1a32:	ad 01       	movw	r20, r26
    1a34:	0e 94 a0 17 	call	0x2f40	; 0x2f40 <strncmp>
    1a38:	9c 01       	movw	r18, r24
    1a3a:	80 e0       	ldi	r24, 0x00	; 0
    1a3c:	23 2b       	or	r18, r19
    1a3e:	09 f4       	brne	.+2      	; 0x1a42 <IsHTTPCommand+0x1e>
    1a40:	81 e0       	ldi	r24, 0x01	; 1
}
    1a42:	08 95       	ret

00001a44 <Webserver_ApplicationCallback>:
 *  \param[in] ConnectionState  Pointer to a TCP Connection State structure giving connection information
 *  \param[in,out] Buffer       Pointer to the application's send/receive packet buffer
 */
void Webserver_ApplicationCallback(TCP_ConnectionState_t* const ConnectionState,
                                   TCP_ConnectionBuffer_t* const Buffer)
{
    1a44:	af 92       	push	r10
    1a46:	bf 92       	push	r11
    1a48:	cf 92       	push	r12
    1a4a:	df 92       	push	r13
    1a4c:	ef 92       	push	r14
    1a4e:	ff 92       	push	r15
    1a50:	0f 93       	push	r16
    1a52:	1f 93       	push	r17
    1a54:	cf 93       	push	r28
    1a56:	df 93       	push	r29
    1a58:	5c 01       	movw	r10, r24
    1a5a:	eb 01       	movw	r28, r22
	char*          BufferDataStr = (char*)Buffer->Data;
    1a5c:	8b 01       	movw	r16, r22
    1a5e:	0e 5f       	subi	r16, 0xFE	; 254
    1a60:	1f 4f       	sbci	r17, 0xFF	; 255
	static uint8_t PageBlock     = 0;

	/* Check to see if a packet has been received on the HTTP port from a remote host */
	if (TCP_APP_HAS_RECEIVED_PACKET(Buffer))
    1a62:	33 e0       	ldi	r19, 0x03	; 3
    1a64:	c3 2e       	mov	r12, r19
    1a66:	32 e0       	ldi	r19, 0x02	; 2
    1a68:	d3 2e       	mov	r13, r19
    1a6a:	c6 0e       	add	r12, r22
    1a6c:	d7 1e       	adc	r13, r23
    1a6e:	f6 01       	movw	r30, r12
    1a70:	80 81       	ld	r24, Z
    1a72:	88 23       	and	r24, r24
    1a74:	09 f4       	brne	.+2      	; 0x1a78 <Webserver_ApplicationCallback+0x34>
    1a76:	66 c0       	rjmp	.+204    	; 0x1b44 <Webserver_ApplicationCallback+0x100>
    1a78:	22 e0       	ldi	r18, 0x02	; 2
    1a7a:	e2 2e       	mov	r14, r18
    1a7c:	f2 2e       	mov	r15, r18
    1a7e:	e6 0e       	add	r14, r22
    1a80:	f7 1e       	adc	r15, r23
    1a82:	f7 01       	movw	r30, r14
    1a84:	80 81       	ld	r24, Z
    1a86:	88 23       	and	r24, r24
    1a88:	09 f0       	breq	.+2      	; 0x1a8c <Webserver_ApplicationCallback+0x48>
    1a8a:	a7 c0       	rjmp	.+334    	; 0x1bda <Webserver_ApplicationCallback+0x196>
	{
		if (IsHTTPCommand(Buffer->Data, "GET"))
    1a8c:	c8 01       	movw	r24, r16
    1a8e:	61 ed       	ldi	r22, 0xD1	; 209
    1a90:	71 e0       	ldi	r23, 0x01	; 1
    1a92:	c8 df       	rcall	.-112    	; 0x1a24 <IsHTTPCommand>
    1a94:	88 23       	and	r24, r24
    1a96:	f9 f0       	breq	.+62     	; 0x1ad6 <Webserver_ApplicationCallback+0x92>
		{
			if (IsHTTPCommand(Buffer->Data, "GET / "))
    1a98:	c8 01       	movw	r24, r16
    1a9a:	65 ed       	ldi	r22, 0xD5	; 213
    1a9c:	71 e0       	ldi	r23, 0x01	; 1
    1a9e:	c2 df       	rcall	.-124    	; 0x1a24 <IsHTTPCommand>
    1aa0:	88 23       	and	r24, r24
    1aa2:	49 f1       	breq	.+82     	; 0x1af6 <Webserver_ApplicationCallback+0xb2>
			{
				PageBlock = 0;
    1aa4:	10 92 b4 0d 	sts	0x0DB4, r1

				/* Copy the HTTP 200 response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    1aa8:	c8 01       	movw	r24, r16
    1aaa:	60 e3       	ldi	r22, 0x30	; 48
    1aac:	71 e0       	ldi	r23, 0x01	; 1
    1aae:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1ab2:	81 e0       	ldi	r24, 0x01	; 1
    1ab4:	f7 01       	movw	r30, r14
    1ab6:	80 83       	st	Z, r24
    1ab8:	f8 01       	movw	r30, r16
    1aba:	01 90       	ld	r0, Z+
    1abc:	00 20       	and	r0, r0
    1abe:	e9 f7       	brne	.-6      	; 0x1aba <Webserver_ApplicationCallback+0x76>
    1ac0:	31 97       	sbiw	r30, 0x01	; 1
    1ac2:	e0 1b       	sub	r30, r16
    1ac4:	f1 0b       	sbc	r31, r17
    1ac6:	f9 83       	std	Y+1, r31	; 0x01
    1ac8:	e8 83       	st	Y, r30
    1aca:	f6 01       	movw	r30, r12
    1acc:	80 83       	st	Z, r24

				/* Lock the buffer to Device->Host transmissions only while we send the page contents */
				TCP_APP_CAPTURE_BUFFER(Buffer);
    1ace:	cc 5f       	subi	r28, 0xFC	; 252
    1ad0:	dd 4f       	sbci	r29, 0xFD	; 253
    1ad2:	88 83       	st	Y, r24
    1ad4:	82 c0       	rjmp	.+260    	; 0x1bda <Webserver_ApplicationCallback+0x196>

				/* All data sent, close the connection */
				TCP_APP_CLOSECONNECTION(ConnectionState);
			}
		}
		else if (IsHTTPCommand(Buffer->Data, "HEAD"))
    1ad6:	c8 01       	movw	r24, r16
    1ad8:	6c ed       	ldi	r22, 0xDC	; 220
    1ada:	71 e0       	ldi	r23, 0x01	; 1
    1adc:	a3 df       	rcall	.-186    	; 0x1a24 <IsHTTPCommand>
    1ade:	88 23       	and	r24, r24
    1ae0:	11 f1       	breq	.+68     	; 0x1b26 <Webserver_ApplicationCallback+0xe2>
		{
			if (IsHTTPCommand(Buffer->Data, "HEAD / "))
    1ae2:	c8 01       	movw	r24, r16
    1ae4:	61 ee       	ldi	r22, 0xE1	; 225
    1ae6:	71 e0       	ldi	r23, 0x01	; 1
    1ae8:	9d df       	rcall	.-198    	; 0x1a24 <IsHTTPCommand>
    1aea:	88 23       	and	r24, r24
    1aec:	21 f0       	breq	.+8      	; 0x1af6 <Webserver_ApplicationCallback+0xb2>
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    1aee:	c8 01       	movw	r24, r16
    1af0:	60 e3       	ldi	r22, 0x30	; 48
    1af2:	71 e0       	ldi	r23, 0x01	; 1
    1af4:	03 c0       	rjmp	.+6      	; 0x1afc <Webserver_ApplicationCallback+0xb8>
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
			}
			else
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP404Header);
    1af6:	c8 01       	movw	r24, r16
    1af8:	64 e8       	ldi	r22, 0x84	; 132
    1afa:	71 e0       	ldi	r23, 0x01	; 1
    1afc:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1b00:	81 e0       	ldi	r24, 0x01	; 1
    1b02:	f7 01       	movw	r30, r14
    1b04:	80 83       	st	Z, r24
    1b06:	f8 01       	movw	r30, r16
    1b08:	01 90       	ld	r0, Z+
    1b0a:	00 20       	and	r0, r0
    1b0c:	e9 f7       	brne	.-6      	; 0x1b08 <Webserver_ApplicationCallback+0xc4>
    1b0e:	31 97       	sbiw	r30, 0x01	; 1
    1b10:	e0 1b       	sub	r30, r16
    1b12:	f1 0b       	sbc	r31, r17
    1b14:	f9 83       	std	Y+1, r31	; 0x01
    1b16:	e8 83       	st	Y, r30
    1b18:	f6 01       	movw	r30, r12
    1b1a:	80 83       	st	Z, r24
			}

			/* All data sent, close the connection */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    1b1c:	85 e1       	ldi	r24, 0x15	; 21
    1b1e:	92 e0       	ldi	r25, 0x02	; 2
    1b20:	a8 0e       	add	r10, r24
    1b22:	b9 1e       	adc	r11, r25
    1b24:	57 c0       	rjmp	.+174    	; 0x1bd4 <Webserver_ApplicationCallback+0x190>
		}
		else if (IsHTTPCommand(Buffer->Data, "TRACE"))
    1b26:	c8 01       	movw	r24, r16
    1b28:	69 ee       	ldi	r22, 0xE9	; 233
    1b2a:	71 e0       	ldi	r23, 0x01	; 1
    1b2c:	7b df       	rcall	.-266    	; 0x1a24 <IsHTTPCommand>
    1b2e:	88 23       	and	r24, r24
    1b30:	21 f0       	breq	.+8      	; 0x1b3a <Webserver_ApplicationCallback+0xf6>
		{
			/* Echo the host's query back to the host */
			TCP_APP_SEND_BUFFER(Buffer, Buffer->Length);
    1b32:	81 e0       	ldi	r24, 0x01	; 1
    1b34:	f7 01       	movw	r30, r14
    1b36:	80 83       	st	Z, r24
    1b38:	ef cf       	rjmp	.-34     	; 0x1b18 <Webserver_ApplicationCallback+0xd4>
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else
		{
			/* Unknown request, just clear the buffer (drop the packet) */
			TCP_APP_CLEAR_BUFFER(Buffer);
    1b3a:	f6 01       	movw	r30, r12
    1b3c:	10 82       	st	Z, r1
    1b3e:	19 82       	std	Y+1, r1	; 0x01
    1b40:	18 82       	st	Y, r1
    1b42:	4b c0       	rjmp	.+150    	; 0x1bda <Webserver_ApplicationCallback+0x196>
		}
	}
	else if (TCP_APP_HAVE_CAPTURED_BUFFER(Buffer))
    1b44:	cc 5f       	subi	r28, 0xFC	; 252
    1b46:	dd 4f       	sbci	r29, 0xFD	; 253
    1b48:	88 81       	ld	r24, Y
    1b4a:	c4 50       	subi	r28, 0x04	; 4
    1b4c:	d2 40       	sbci	r29, 0x02	; 2
    1b4e:	88 23       	and	r24, r24
    1b50:	09 f4       	brne	.+2      	; 0x1b54 <Webserver_ApplicationCallback+0x110>
    1b52:	43 c0       	rjmp	.+134    	; 0x1bda <Webserver_ApplicationCallback+0x196>
    1b54:	ce 5f       	subi	r28, 0xFE	; 254
    1b56:	dd 4f       	sbci	r29, 0xFD	; 253
    1b58:	88 81       	ld	r24, Y
    1b5a:	c2 50       	subi	r28, 0x02	; 2
    1b5c:	d2 40       	sbci	r29, 0x02	; 2
    1b5e:	88 23       	and	r24, r24
    1b60:	e1 f1       	breq	.+120    	; 0x1bda <Webserver_ApplicationCallback+0x196>
	{
		uint16_t RemLength = strlen_P(&HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE]);
    1b62:	80 91 b4 0d 	lds	r24, 0x0DB4
    1b66:	c8 2e       	mov	r12, r24
    1b68:	dd 24       	eor	r13, r13
    1b6a:	d6 94       	lsr	r13
    1b6c:	dc 2c       	mov	r13, r12
    1b6e:	cc 24       	eor	r12, r12
    1b70:	d7 94       	ror	r13
    1b72:	c7 94       	ror	r12
    1b74:	86 ec       	ldi	r24, 0xC6	; 198
    1b76:	91 e0       	ldi	r25, 0x01	; 1
    1b78:	c8 0e       	add	r12, r24
    1b7a:	d9 1e       	adc	r13, r25
    1b7c:	c6 01       	movw	r24, r12
    1b7e:	0e 94 61 17 	call	0x2ec2	; 0x2ec2 <strlen_P>
		uint16_t Length;

		/* Determine the length of the loaded block */
		Length = ((RemLength > HTTP_REPLY_BLOCK_SIZE) ? HTTP_REPLY_BLOCK_SIZE : RemLength);
    1b82:	7c 01       	movw	r14, r24
    1b84:	91 e8       	ldi	r25, 0x81	; 129
    1b86:	e9 16       	cp	r14, r25
    1b88:	f1 04       	cpc	r15, r1
    1b8a:	18 f0       	brcs	.+6      	; 0x1b92 <Webserver_ApplicationCallback+0x14e>
    1b8c:	80 e8       	ldi	r24, 0x80	; 128
    1b8e:	e8 2e       	mov	r14, r24
    1b90:	f1 2c       	mov	r15, r1

		/* Copy the next buffer sized block of the page to the packet buffer */
		strncpy_P(BufferDataStr, &HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE], Length);
    1b92:	c8 01       	movw	r24, r16
    1b94:	b6 01       	movw	r22, r12
    1b96:	a7 01       	movw	r20, r14
    1b98:	0e 94 6a 17 	call	0x2ed4	; 0x2ed4 <strncpy_P>

		/* Send the buffer contents to the host */
		TCP_APP_SEND_BUFFER(Buffer, Length);
    1b9c:	ce 5f       	subi	r28, 0xFE	; 254
    1b9e:	dd 4f       	sbci	r29, 0xFD	; 253
    1ba0:	81 e0       	ldi	r24, 0x01	; 1
    1ba2:	88 83       	st	Y, r24
    1ba4:	c2 50       	subi	r28, 0x02	; 2
    1ba6:	d2 40       	sbci	r29, 0x02	; 2
    1ba8:	f9 82       	std	Y+1, r15	; 0x01
    1baa:	e8 82       	st	Y, r14
    1bac:	cd 5f       	subi	r28, 0xFD	; 253
    1bae:	dd 4f       	sbci	r29, 0xFD	; 253
    1bb0:	88 83       	st	Y, r24
    1bb2:	c3 50       	subi	r28, 0x03	; 3
    1bb4:	d2 40       	sbci	r29, 0x02	; 2

		/* Check to see if the entire page has been sent */
		if (PageBlock++ == (sizeof(HTTPPage) / HTTP_REPLY_BLOCK_SIZE))
    1bb6:	80 91 b4 0d 	lds	r24, 0x0DB4
    1bba:	8f 5f       	subi	r24, 0xFF	; 255
    1bbc:	80 93 b4 0d 	sts	0x0DB4, r24
    1bc0:	81 50       	subi	r24, 0x01	; 1
    1bc2:	83 30       	cpi	r24, 0x03	; 3
    1bc4:	51 f4       	brne	.+20     	; 0x1bda <Webserver_ApplicationCallback+0x196>
		{
			/* Unlock the buffer so that the host can fill it with future packets */
			TCP_APP_RELEASE_BUFFER(Buffer);
    1bc6:	cc 5f       	subi	r28, 0xFC	; 252
    1bc8:	dd 4f       	sbci	r29, 0xFD	; 253
    1bca:	18 82       	st	Y, r1

			/* Close the connection to the host */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    1bcc:	e5 e1       	ldi	r30, 0x15	; 21
    1bce:	f2 e0       	ldi	r31, 0x02	; 2
    1bd0:	ae 0e       	add	r10, r30
    1bd2:	bf 1e       	adc	r11, r31
    1bd4:	87 e0       	ldi	r24, 0x07	; 7
    1bd6:	f5 01       	movw	r30, r10
    1bd8:	80 83       	st	Z, r24
		}
	}
}
    1bda:	df 91       	pop	r29
    1bdc:	cf 91       	pop	r28
    1bde:	1f 91       	pop	r17
    1be0:	0f 91       	pop	r16
    1be2:	ff 90       	pop	r15
    1be4:	ef 90       	pop	r14
    1be6:	df 90       	pop	r13
    1be8:	cf 90       	pop	r12
    1bea:	bf 90       	pop	r11
    1bec:	af 90       	pop	r10
    1bee:	08 95       	ret

00001bf0 <Webserver_Init>:
 *  callback routine for packets sent to the HTTP protocol port.
 */
void Webserver_Init(void)
{
	/* Open the HTTP port in the TCP protocol so that HTTP connections to the device can be established */
	TCP_SetPortState(TCP_PORT_HTTP, TCP_Port_Open, Webserver_ApplicationCallback);
    1bf0:	80 e0       	ldi	r24, 0x00	; 0
    1bf2:	90 e5       	ldi	r25, 0x50	; 80
    1bf4:	61 e0       	ldi	r22, 0x01	; 1
    1bf6:	42 e2       	ldi	r20, 0x22	; 34
    1bf8:	5d e0       	ldi	r21, 0x0D	; 13
    1bfa:	0c 94 01 04 	jmp	0x802	; 0x802 <TCP_SetPortState>

00001bfe <Endpoint_ConfigureEndpoint_Prv>:
#endif

bool Endpoint_ConfigureEndpoint_Prv(const uint8_t Number,
                                    const uint8_t UECFG0XData,
                                    const uint8_t UECFG1XData)
{
    1bfe:	38 2f       	mov	r19, r24
    1c00:	28 2f       	mov	r18, r24
    1c02:	2c c0       	rjmp	.+88     	; 0x1c5c <Endpoint_ConfigureEndpoint_Prv+0x5e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1c04:	20 93 e9 00 	sts	0x00E9, r18
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);
		
		if (EPNum == Number)
    1c08:	23 17       	cp	r18, r19
    1c0a:	21 f4       	brne	.+8      	; 0x1c14 <Endpoint_ConfigureEndpoint_Prv+0x16>
    1c0c:	76 2f       	mov	r23, r22
    1c0e:	94 2f       	mov	r25, r20
    1c10:	50 e0       	ldi	r21, 0x00	; 0
    1c12:	06 c0       	rjmp	.+12     	; 0x1c20 <Endpoint_ConfigureEndpoint_Prv+0x22>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
    1c14:	70 91 ec 00 	lds	r23, 0x00EC
			UECFG1XTemp = UECFG1X;
    1c18:	90 91 ed 00 	lds	r25, 0x00ED
			UEIENXTemp  = UEIENX;
    1c1c:	50 91 f0 00 	lds	r21, 0x00F0
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
    1c20:	91 ff       	sbrs	r25, 1
    1c22:	1b c0       	rjmp	.+54     	; 0x1c5a <Endpoint_ConfigureEndpoint_Prv+0x5c>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
    1c24:	80 91 eb 00 	lds	r24, 0x00EB
    1c28:	8e 7f       	andi	r24, 0xFE	; 254
    1c2a:	80 93 eb 00 	sts	0x00EB, r24
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= (1 << ALLOC);
    1c2e:	80 91 ed 00 	lds	r24, 0x00ED
    1c32:	82 70       	andi	r24, 0x02	; 2
    1c34:	80 93 ed 00 	sts	0x00ED, r24
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    1c38:	80 91 eb 00 	lds	r24, 0x00EB
    1c3c:	81 60       	ori	r24, 0x01	; 1
    1c3e:	80 93 eb 00 	sts	0x00EB, r24

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
    1c42:	70 93 ec 00 	sts	0x00EC, r23
		UECFG1X = UECFG1XTemp;
    1c46:	90 93 ed 00 	sts	0x00ED, r25
		UEIENX  = UEIENXTemp;
    1c4a:	50 93 f0 00 	sts	0x00F0, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    1c4e:	80 91 ee 00 	lds	r24, 0x00EE
			
		if (!(Endpoint_IsConfigured()))
    1c52:	87 fd       	sbrc	r24, 7
    1c54:	02 c0       	rjmp	.+4      	; 0x1c5a <Endpoint_ConfigureEndpoint_Prv+0x5c>
    1c56:	80 e0       	ldi	r24, 0x00	; 0
    1c58:	08 95       	ret
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else	
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    1c5a:	2f 5f       	subi	r18, 0xFF	; 255
    1c5c:	27 30       	cpi	r18, 0x07	; 7
    1c5e:	90 f2       	brcs	.-92     	; 0x1c04 <Endpoint_ConfigureEndpoint_Prv+0x6>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1c60:	30 93 e9 00 	sts	0x00E9, r19
    1c64:	81 e0       	ldi	r24, 0x01	; 1
	}
	
	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
    1c66:	08 95       	ret

00001c68 <Endpoint_ClearStatusStage>:
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    1c68:	80 91 01 14 	lds	r24, 0x1401
    1c6c:	88 23       	and	r24, r24
    1c6e:	9c f4       	brge	.+38     	; 0x1c96 <Endpoint_ClearStatusStage+0x2e>
    1c70:	04 c0       	rjmp	.+8      	; 0x1c7a <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1c72:	80 91 00 14 	lds	r24, 0x1400
    1c76:	88 23       	and	r24, r24
    1c78:	b9 f0       	breq	.+46     	; 0x1ca8 <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1c7a:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    1c7e:	82 ff       	sbrs	r24, 2
    1c80:	f8 cf       	rjmp	.-16     	; 0x1c72 <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1c82:	80 91 e8 00 	lds	r24, 0x00E8
    1c86:	8b 77       	andi	r24, 0x7B	; 123
    1c88:	80 93 e8 00 	sts	0x00E8, r24
    1c8c:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1c8e:	80 91 00 14 	lds	r24, 0x1400
    1c92:	88 23       	and	r24, r24
    1c94:	49 f0       	breq	.+18     	; 0x1ca8 <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1c96:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    1c9a:	80 ff       	sbrs	r24, 0
    1c9c:	f8 cf       	rjmp	.-16     	; 0x1c8e <Endpoint_ClearStatusStage+0x26>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1c9e:	80 91 e8 00 	lds	r24, 0x00E8
    1ca2:	8e 77       	andi	r24, 0x7E	; 126
    1ca4:	80 93 e8 00 	sts	0x00E8, r24
    1ca8:	08 95       	ret

00001caa <Endpoint_WaitUntilReady>:
			 *  the frame number is incremented by one.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    1caa:	40 91 e4 00 	lds	r20, 0x00E4
    1cae:	50 91 e5 00 	lds	r21, 0x00E5
    1cb2:	24 e6       	ldi	r18, 0x64	; 100
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & ENDPOINT_DIR_IN);
    1cb4:	80 91 ec 00 	lds	r24, 0x00EC

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
    1cb8:	80 ff       	sbrs	r24, 0
    1cba:	05 c0       	rjmp	.+10     	; 0x1cc6 <Endpoint_WaitUntilReady+0x1c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1cbc:	80 91 e8 00 	lds	r24, 0x00E8
		{
			if (Endpoint_IsINReady())
    1cc0:	80 ff       	sbrs	r24, 0
    1cc2:	05 c0       	rjmp	.+10     	; 0x1cce <Endpoint_WaitUntilReady+0x24>
    1cc4:	22 c0       	rjmp	.+68     	; 0x1d0a <Endpoint_WaitUntilReady+0x60>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1cc6:	80 91 e8 00 	lds	r24, 0x00E8
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    1cca:	82 fd       	sbrc	r24, 2
    1ccc:	1e c0       	rjmp	.+60     	; 0x1d0a <Endpoint_WaitUntilReady+0x60>
			  return ENDPOINT_READYWAIT_NoError;
		}
		
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1cce:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1cd2:	88 23       	and	r24, r24
    1cd4:	11 f4       	brne	.+4      	; 0x1cda <Endpoint_WaitUntilReady+0x30>
    1cd6:	82 e0       	ldi	r24, 0x02	; 2
    1cd8:	08 95       	ret
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1cda:	85 30       	cpi	r24, 0x05	; 5
    1cdc:	11 f4       	brne	.+4      	; 0x1ce2 <Endpoint_WaitUntilReady+0x38>
    1cde:	83 e0       	ldi	r24, 0x03	; 3
    1ce0:	08 95       	ret
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    1ce2:	80 91 eb 00 	lds	r24, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    1ce6:	85 ff       	sbrs	r24, 5
    1ce8:	02 c0       	rjmp	.+4      	; 0x1cee <Endpoint_WaitUntilReady+0x44>
    1cea:	81 e0       	ldi	r24, 0x01	; 1
    1cec:	08 95       	ret
    1cee:	80 91 e4 00 	lds	r24, 0x00E4
    1cf2:	90 91 e5 00 	lds	r25, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    1cf6:	84 17       	cp	r24, r20
    1cf8:	95 07       	cpc	r25, r21
    1cfa:	e1 f2       	breq	.-72     	; 0x1cb4 <Endpoint_WaitUntilReady+0xa>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    1cfc:	22 23       	and	r18, r18
    1cfe:	11 f4       	brne	.+4      	; 0x1d04 <Endpoint_WaitUntilReady+0x5a>
    1d00:	84 e0       	ldi	r24, 0x04	; 4
    1d02:	08 95       	ret
    1d04:	21 50       	subi	r18, 0x01	; 1
    1d06:	ac 01       	movw	r20, r24
    1d08:	d5 cf       	rjmp	.-86     	; 0x1cb4 <Endpoint_WaitUntilReady+0xa>
    1d0a:	80 e0       	ldi	r24, 0x00	; 0
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    1d0c:	08 95       	ret

00001d0e <USB_ResetInterface>:

void USB_ResetInterface(void)
{
    1d0e:	ef 92       	push	r14
    1d10:	ff 92       	push	r15
    1d12:	0f 93       	push	r16
    1d14:	1f 93       	push	r17
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    1d16:	4d d0       	rcall	.+154    	; 0x1db2 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    1d18:	54 d0       	rcall	.+168    	; 0x1dc2 <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				const uint8_t Temp = USBCON;
    1d1a:	08 ed       	ldi	r16, 0xD8	; 216
    1d1c:	10 e0       	ldi	r17, 0x00	; 0
    1d1e:	f8 01       	movw	r30, r16
    1d20:	80 81       	ld	r24, Z

				USBCON = (Temp & ~(1 << USBE));
    1d22:	98 2f       	mov	r25, r24
    1d24:	9f 77       	andi	r25, 0x7F	; 127
    1d26:	90 83       	st	Z, r25
				USBCON = (Temp |  (1 << USBE));
    1d28:	80 68       	ori	r24, 0x80	; 128
    1d2a:	80 83       	st	Z, r24
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    1d2c:	80 81       	ld	r24, Z
    1d2e:	8f 7d       	andi	r24, 0xDF	; 223
    1d30:	80 83       	st	Z, r24

	if (USB_CurrentMode == USB_MODE_Device)
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    1d32:	e7 ed       	ldi	r30, 0xD7	; 215
    1d34:	f0 e0       	ldi	r31, 0x00	; 0
    1d36:	80 81       	ld	r24, Z
    1d38:	80 68       	ori	r24, 0x80	; 128
    1d3a:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR  = 0;
    1d3c:	19 bc       	out	0x29, r1	; 41
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState          = DEVICE_STATE_Unattached;
    1d3e:	10 92 00 14 	sts	0x1400, r1
	USB_ConfigurationNumber  = 0;
    1d42:	10 92 fe 13 	sts	0x13FE, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_RemoteWakeupEnabled  = false;
    1d46:	10 92 fd 13 	sts	0x13FD, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_CurrentlySelfPowered = false;
    1d4a:	10 92 fc 13 	sts	0x13FC, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    1d4e:	80 ee       	ldi	r24, 0xE0	; 224
    1d50:	e8 2e       	mov	r14, r24
    1d52:	f1 2c       	mov	r15, r1
    1d54:	f7 01       	movw	r30, r14
    1d56:	80 81       	ld	r24, Z
    1d58:	8b 7f       	andi	r24, 0xFB	; 251
    1d5a:	80 83       	st	Z, r24
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    1d5c:	f8 01       	movw	r30, r16
    1d5e:	80 81       	ld	r24, Z
    1d60:	81 60       	ori	r24, 0x01	; 1
    1d62:	80 83       	st	Z, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | Direction),
    1d64:	80 e0       	ldi	r24, 0x00	; 0
    1d66:	60 e0       	ldi	r22, 0x00	; 0
    1d68:	42 e0       	ldi	r20, 0x02	; 2
    1d6a:	49 df       	rcall	.-366    	; 0x1bfe <Endpoint_ConfigureEndpoint_Prv>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    1d6c:	e1 ee       	ldi	r30, 0xE1	; 225
    1d6e:	f0 e0       	ldi	r31, 0x00	; 0
    1d70:	80 81       	ld	r24, Z
    1d72:	8e 7f       	andi	r24, 0xFE	; 254
    1d74:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    1d76:	e2 ee       	ldi	r30, 0xE2	; 226
    1d78:	f0 e0       	ldi	r31, 0x00	; 0
    1d7a:	80 81       	ld	r24, Z
    1d7c:	81 60       	ori	r24, 0x01	; 1
    1d7e:	80 83       	st	Z, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    1d80:	80 81       	ld	r24, Z
    1d82:	88 60       	ori	r24, 0x08	; 8
    1d84:	80 83       	st	Z, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    1d86:	f7 01       	movw	r30, r14
    1d88:	80 81       	ld	r24, Z
    1d8a:	8e 7f       	andi	r24, 0xFE	; 254
    1d8c:	80 83       	st	Z, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON  |=  (1 << OTGPADE);
    1d8e:	f8 01       	movw	r30, r16
    1d90:	80 81       	ld	r24, Z
    1d92:	80 61       	ori	r24, 0x10	; 16
    1d94:	80 83       	st	Z, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    1d96:	1f 91       	pop	r17
    1d98:	0f 91       	pop	r16
    1d9a:	ff 90       	pop	r15
    1d9c:	ef 90       	pop	r14
    1d9e:	08 95       	ret

00001da0 <USB_Init>:

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  |=  (1 << UVREGE);
    1da0:	e7 ed       	ldi	r30, 0xD7	; 215
    1da2:	f0 e0       	ldi	r31, 0x00	; 0
    1da4:	80 81       	ld	r24, Z
    1da6:	81 60       	ori	r24, 0x01	; 1
    1da8:	80 83       	st	Z, r24
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    1daa:	81 e0       	ldi	r24, 0x01	; 1
    1dac:	80 93 ff 13 	sts	0x13FF, r24

	USB_ResetInterface();
}
    1db0:	ae cf       	rjmp	.-164    	; 0x1d0e <USB_ResetInterface>

00001db2 <USB_INT_DisableAllInterrupts>:
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    1db2:	e8 ed       	ldi	r30, 0xD8	; 216
    1db4:	f0 e0       	ldi	r31, 0x00	; 0
    1db6:	80 81       	ld	r24, Z
    1db8:	8c 7f       	andi	r24, 0xFC	; 252
    1dba:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    1dbc:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
    1dc0:	08 95       	ret

00001dc2 <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    1dc2:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    1dc6:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
    1dca:	08 95       	ret

00001dcc <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
    1dcc:	1f 92       	push	r1
    1dce:	0f 92       	push	r0
    1dd0:	0f b6       	in	r0, 0x3f	; 63
    1dd2:	0f 92       	push	r0
    1dd4:	0b b6       	in	r0, 0x3b	; 59
    1dd6:	0f 92       	push	r0
    1dd8:	11 24       	eor	r1, r1
    1dda:	2f 93       	push	r18
    1ddc:	3f 93       	push	r19
    1dde:	4f 93       	push	r20
    1de0:	5f 93       	push	r21
    1de2:	6f 93       	push	r22
    1de4:	7f 93       	push	r23
    1de6:	8f 93       	push	r24
    1de8:	9f 93       	push	r25
    1dea:	af 93       	push	r26
    1dec:	bf 93       	push	r27
    1dee:	ef 93       	push	r30
    1df0:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    1df2:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    1df6:	82 ff       	sbrs	r24, 2
    1df8:	0a c0       	rjmp	.+20     	; 0x1e0e <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    1dfa:	80 91 e2 00 	lds	r24, 0x00E2
    1dfe:	82 ff       	sbrs	r24, 2
    1e00:	06 c0       	rjmp	.+12     	; 0x1e0e <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    1e02:	80 91 e1 00 	lds	r24, 0x00E1
    1e06:	8b 7f       	andi	r24, 0xFB	; 251
    1e08:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    1e0c:	32 d2       	rcall	.+1124   	; 0x2272 <USB_Event_Stub>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    1e0e:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    1e12:	80 ff       	sbrs	r24, 0
    1e14:	20 c0       	rjmp	.+64     	; 0x1e56 <__vector_10+0x8a>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    1e16:	80 91 d8 00 	lds	r24, 0x00D8
    1e1a:	80 ff       	sbrs	r24, 0
    1e1c:	1c c0       	rjmp	.+56     	; 0x1e56 <__vector_10+0x8a>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    1e1e:	80 91 da 00 	lds	r24, 0x00DA
    1e22:	8e 7f       	andi	r24, 0xFE	; 254
    1e24:	80 93 da 00 	sts	0x00DA, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    1e28:	80 91 d9 00 	lds	r24, 0x00D9
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    1e2c:	80 ff       	sbrs	r24, 0
    1e2e:	0e c0       	rjmp	.+28     	; 0x1e4c <__vector_10+0x80>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR  = USB_PLL_PSC;
    1e30:	8c e0       	ldi	r24, 0x0C	; 12
    1e32:	89 bd       	out	0x29, r24	; 41
				PLLCSR |= (1 << PLLE);
    1e34:	89 b5       	in	r24, 0x29	; 41
    1e36:	82 60       	ori	r24, 0x02	; 2
    1e38:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    1e3a:	09 b4       	in	r0, 0x29	; 41
    1e3c:	00 fe       	sbrs	r0, 0
    1e3e:	fd cf       	rjmp	.-6      	; 0x1e3a <__vector_10+0x6e>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    1e40:	81 e0       	ldi	r24, 0x01	; 1
    1e42:	80 93 00 14 	sts	0x1400, r24
			EVENT_USB_Device_Connect();
    1e46:	0e 94 30 02 	call	0x460	; 0x460 <EVENT_USB_Device_Connect>
    1e4a:	05 c0       	rjmp	.+10     	; 0x1e56 <__vector_10+0x8a>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR  = 0;
    1e4c:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    1e4e:	10 92 00 14 	sts	0x1400, r1
			EVENT_USB_Device_Disconnect();
    1e52:	0e 94 35 02 	call	0x46a	; 0x46a <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    1e56:	80 91 e1 00 	lds	r24, 0x00E1
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    1e5a:	80 ff       	sbrs	r24, 0
    1e5c:	18 c0       	rjmp	.+48     	; 0x1e8e <__vector_10+0xc2>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    1e5e:	80 91 e2 00 	lds	r24, 0x00E2
    1e62:	80 ff       	sbrs	r24, 0
    1e64:	14 c0       	rjmp	.+40     	; 0x1e8e <__vector_10+0xc2>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    1e66:	80 91 e2 00 	lds	r24, 0x00E2
    1e6a:	8e 7f       	andi	r24, 0xFE	; 254
    1e6c:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    1e70:	80 91 e2 00 	lds	r24, 0x00E2
    1e74:	80 61       	ori	r24, 0x10	; 16
    1e76:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON  |=  (1 << FRZCLK);
    1e7a:	80 91 d8 00 	lds	r24, 0x00D8
    1e7e:	80 62       	ori	r24, 0x20	; 32
    1e80:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR  = 0;
    1e84:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    1e86:	85 e0       	ldi	r24, 0x05	; 5
    1e88:	80 93 00 14 	sts	0x1400, r24
		EVENT_USB_Device_Suspend();
    1e8c:	f2 d1       	rcall	.+996    	; 0x2272 <USB_Event_Stub>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    1e8e:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    1e92:	84 ff       	sbrs	r24, 4
    1e94:	2e c0       	rjmp	.+92     	; 0x1ef2 <__vector_10+0x126>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    1e96:	80 91 e2 00 	lds	r24, 0x00E2
    1e9a:	84 ff       	sbrs	r24, 4
    1e9c:	2a c0       	rjmp	.+84     	; 0x1ef2 <__vector_10+0x126>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR  = USB_PLL_PSC;
    1e9e:	8c e0       	ldi	r24, 0x0C	; 12
    1ea0:	89 bd       	out	0x29, r24	; 41
				PLLCSR |= (1 << PLLE);
    1ea2:	89 b5       	in	r24, 0x29	; 41
    1ea4:	82 60       	ori	r24, 0x02	; 2
    1ea6:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    1ea8:	09 b4       	in	r0, 0x29	; 41
    1eaa:	00 fe       	sbrs	r0, 0
    1eac:	fd cf       	rjmp	.-6      	; 0x1ea8 <__vector_10+0xdc>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    1eae:	80 91 d8 00 	lds	r24, 0x00D8
    1eb2:	8f 7d       	andi	r24, 0xDF	; 223
    1eb4:	80 93 d8 00 	sts	0x00D8, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    1eb8:	80 91 e1 00 	lds	r24, 0x00E1
    1ebc:	8f 7e       	andi	r24, 0xEF	; 239
    1ebe:	80 93 e1 00 	sts	0x00E1, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    1ec2:	80 91 e2 00 	lds	r24, 0x00E2
    1ec6:	8f 7e       	andi	r24, 0xEF	; 239
    1ec8:	80 93 e2 00 	sts	0x00E2, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    1ecc:	80 91 e2 00 	lds	r24, 0x00E2
    1ed0:	81 60       	ori	r24, 0x01	; 1
    1ed2:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_ConfigurationNumber)
    1ed6:	80 91 fe 13 	lds	r24, 0x13FE
    1eda:	88 23       	and	r24, r24
    1edc:	31 f4       	brne	.+12     	; 0x1eea <__vector_10+0x11e>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    1ede:	80 91 e3 00 	lds	r24, 0x00E3
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    1ee2:	87 fd       	sbrc	r24, 7
    1ee4:	02 c0       	rjmp	.+4      	; 0x1eea <__vector_10+0x11e>
    1ee6:	81 e0       	ldi	r24, 0x01	; 1
    1ee8:	01 c0       	rjmp	.+2      	; 0x1eec <__vector_10+0x120>
    1eea:	84 e0       	ldi	r24, 0x04	; 4
    1eec:	80 93 00 14 	sts	0x1400, r24

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    1ef0:	c0 d1       	rcall	.+896    	; 0x2272 <USB_Event_Stub>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    1ef2:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    1ef6:	83 ff       	sbrs	r24, 3
    1ef8:	22 c0       	rjmp	.+68     	; 0x1f3e <__vector_10+0x172>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    1efa:	80 91 e2 00 	lds	r24, 0x00E2
    1efe:	83 ff       	sbrs	r24, 3
    1f00:	1e c0       	rjmp	.+60     	; 0x1f3e <__vector_10+0x172>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    1f02:	80 91 e1 00 	lds	r24, 0x00E1
    1f06:	87 7f       	andi	r24, 0xF7	; 247
    1f08:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState         = DEVICE_STATE_Default;
    1f0c:	82 e0       	ldi	r24, 0x02	; 2
    1f0e:	80 93 00 14 	sts	0x1400, r24
		USB_ConfigurationNumber = 0;
    1f12:	10 92 fe 13 	sts	0x13FE, r1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    1f16:	80 91 e1 00 	lds	r24, 0x00E1
    1f1a:	8e 7f       	andi	r24, 0xFE	; 254
    1f1c:	80 93 e1 00 	sts	0x00E1, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    1f20:	80 91 e2 00 	lds	r24, 0x00E2
    1f24:	8e 7f       	andi	r24, 0xFE	; 254
    1f26:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    1f2a:	80 91 e2 00 	lds	r24, 0x00E2
    1f2e:	80 61       	ori	r24, 0x10	; 16
    1f30:	80 93 e2 00 	sts	0x00E2, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | Direction),
    1f34:	80 e0       	ldi	r24, 0x00	; 0
    1f36:	60 e0       	ldi	r22, 0x00	; 0
    1f38:	42 e0       	ldi	r20, 0x02	; 2
    1f3a:	61 de       	rcall	.-830    	; 0x1bfe <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    1f3c:	9a d1       	rcall	.+820    	; 0x2272 <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    1f3e:	ff 91       	pop	r31
    1f40:	ef 91       	pop	r30
    1f42:	bf 91       	pop	r27
    1f44:	af 91       	pop	r26
    1f46:	9f 91       	pop	r25
    1f48:	8f 91       	pop	r24
    1f4a:	7f 91       	pop	r23
    1f4c:	6f 91       	pop	r22
    1f4e:	5f 91       	pop	r21
    1f50:	4f 91       	pop	r20
    1f52:	3f 91       	pop	r19
    1f54:	2f 91       	pop	r18
    1f56:	0f 90       	pop	r0
    1f58:	0b be       	out	0x3b, r0	; 59
    1f5a:	0f 90       	pop	r0
    1f5c:	0f be       	out	0x3f, r0	; 63
    1f5e:	0f 90       	pop	r0
    1f60:	1f 90       	pop	r1
    1f62:	18 95       	reti

00001f64 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    1f64:	0f 93       	push	r16
    1f66:	1f 93       	push	r17
    1f68:	df 93       	push	r29
    1f6a:	cf 93       	push	r28
    1f6c:	cd b7       	in	r28, 0x3d	; 61
    1f6e:	de b7       	in	r29, 0x3e	; 62
    1f70:	ac 97       	sbiw	r28, 0x2c	; 44
    1f72:	0f b6       	in	r0, 0x3f	; 63
    1f74:	f8 94       	cli
    1f76:	de bf       	out	0x3e, r29	; 62
    1f78:	0f be       	out	0x3f, r0	; 63
    1f7a:	cd bf       	out	0x3d, r28	; 61
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    1f7c:	80 91 f1 00 	lds	r24, 0x00F1
	USB_ControlRequest.bmRequestType = Endpoint_Read_8();
    1f80:	80 93 01 14 	sts	0x1401, r24
    1f84:	80 91 f1 00 	lds	r24, 0x00F1
	USB_ControlRequest.bRequest      = Endpoint_Read_8();
    1f88:	80 93 02 14 	sts	0x1402, r24
				{
					uint16_t Value;
					uint8_t  Bytes[2];
				} Data;

				Data.Bytes[0] = UEDATX;
    1f8c:	80 91 f1 00 	lds	r24, 0x00F1
				Data.Bytes[1] = UEDATX;
    1f90:	90 91 f1 00 	lds	r25, 0x00F1
	USB_ControlRequest.wValue        = Endpoint_Read_16_LE();
    1f94:	e3 e0       	ldi	r30, 0x03	; 3
    1f96:	f4 e1       	ldi	r31, 0x14	; 20
    1f98:	80 93 03 14 	sts	0x1403, r24
    1f9c:	90 93 04 14 	sts	0x1404, r25
				{
					uint16_t Value;
					uint8_t  Bytes[2];
				} Data;

				Data.Bytes[0] = UEDATX;
    1fa0:	80 91 f1 00 	lds	r24, 0x00F1
				Data.Bytes[1] = UEDATX;
    1fa4:	90 91 f1 00 	lds	r25, 0x00F1
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
    1fa8:	80 93 05 14 	sts	0x1405, r24
    1fac:	93 83       	std	Z+3, r25	; 0x03
				{
					uint16_t Value;
					uint8_t  Bytes[2];
				} Data;

				Data.Bytes[0] = UEDATX;
    1fae:	80 91 f1 00 	lds	r24, 0x00F1
				Data.Bytes[1] = UEDATX;
    1fb2:	90 91 f1 00 	lds	r25, 0x00F1
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
    1fb6:	80 93 07 14 	sts	0x1407, r24
    1fba:	95 83       	std	Z+5, r25	; 0x05

	EVENT_USB_Device_ControlRequest();
    1fbc:	0e 94 3a 02 	call	0x474	; 0x474 <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1fc0:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    1fc4:	83 ff       	sbrs	r24, 3
    1fc6:	3c c1       	rjmp	.+632    	; 0x2240 <__stack+0x141>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    1fc8:	80 91 01 14 	lds	r24, 0x1401

		switch (USB_ControlRequest.bRequest)
    1fcc:	30 91 02 14 	lds	r19, 0x1402
    1fd0:	35 30       	cpi	r19, 0x05	; 5
    1fd2:	09 f4       	brne	.+2      	; 0x1fd6 <USB_Device_ProcessControlRequest+0x72>
    1fd4:	87 c0       	rjmp	.+270    	; 0x20e4 <USB_Device_ProcessControlRequest+0x180>
    1fd6:	36 30       	cpi	r19, 0x06	; 6
    1fd8:	40 f4       	brcc	.+16     	; 0x1fea <USB_Device_ProcessControlRequest+0x86>
    1fda:	31 30       	cpi	r19, 0x01	; 1
    1fdc:	c9 f1       	breq	.+114    	; 0x2050 <USB_Device_ProcessControlRequest+0xec>
    1fde:	31 30       	cpi	r19, 0x01	; 1
    1fe0:	70 f0       	brcs	.+28     	; 0x1ffe <USB_Device_ProcessControlRequest+0x9a>
    1fe2:	33 30       	cpi	r19, 0x03	; 3
    1fe4:	09 f0       	breq	.+2      	; 0x1fe8 <USB_Device_ProcessControlRequest+0x84>
    1fe6:	2c c1       	rjmp	.+600    	; 0x2240 <__stack+0x141>
    1fe8:	33 c0       	rjmp	.+102    	; 0x2050 <USB_Device_ProcessControlRequest+0xec>
    1fea:	38 30       	cpi	r19, 0x08	; 8
    1fec:	09 f4       	brne	.+2      	; 0x1ff0 <USB_Device_ProcessControlRequest+0x8c>
    1fee:	f9 c0       	rjmp	.+498    	; 0x21e2 <__stack+0xe3>
    1ff0:	39 30       	cpi	r19, 0x09	; 9
    1ff2:	09 f4       	brne	.+2      	; 0x1ff6 <USB_Device_ProcessControlRequest+0x92>
    1ff4:	08 c1       	rjmp	.+528    	; 0x2206 <__stack+0x107>
    1ff6:	36 30       	cpi	r19, 0x06	; 6
    1ff8:	09 f0       	breq	.+2      	; 0x1ffc <USB_Device_ProcessControlRequest+0x98>
    1ffa:	22 c1       	rjmp	.+580    	; 0x2240 <__stack+0x141>
    1ffc:	99 c0       	rjmp	.+306    	; 0x2130 <__stack+0x31>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    1ffe:	80 38       	cpi	r24, 0x80	; 128
    2000:	21 f0       	breq	.+8      	; 0x200a <USB_Device_ProcessControlRequest+0xa6>
    2002:	82 38       	cpi	r24, 0x82	; 130
    2004:	09 f0       	breq	.+2      	; 0x2008 <USB_Device_ProcessControlRequest+0xa4>
    2006:	1c c1       	rjmp	.+568    	; 0x2240 <__stack+0x141>
    2008:	08 c0       	rjmp	.+16     	; 0x201a <USB_Device_ProcessControlRequest+0xb6>
    200a:	90 91 fc 13 	lds	r25, 0x13FC
			if (USB_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_RemoteWakeupEnabled)
    200e:	80 91 fd 13 	lds	r24, 0x13FD
    2012:	88 23       	and	r24, r24
    2014:	99 f0       	breq	.+38     	; 0x203c <USB_Device_ProcessControlRequest+0xd8>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    2016:	92 60       	ori	r25, 0x02	; 2
    2018:	11 c0       	rjmp	.+34     	; 0x203c <USB_Device_ProcessControlRequest+0xd8>
			#endif
			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    201a:	80 91 05 14 	lds	r24, 0x1405
    201e:	87 70       	andi	r24, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2020:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    2024:	80 91 eb 00 	lds	r24, 0x00EB

			CurrentStatus = Endpoint_IsStalled();
    2028:	90 e0       	ldi	r25, 0x00	; 0
    202a:	25 e0       	ldi	r18, 0x05	; 5
    202c:	96 95       	lsr	r25
    202e:	87 95       	ror	r24
    2030:	2a 95       	dec	r18
    2032:	e1 f7       	brne	.-8      	; 0x202c <USB_Device_ProcessControlRequest+0xc8>
    2034:	98 2f       	mov	r25, r24
    2036:	91 70       	andi	r25, 0x01	; 1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2038:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    203c:	80 91 e8 00 	lds	r24, 0x00E8
    2040:	87 7f       	andi	r24, 0xF7	; 247
    2042:	80 93 e8 00 	sts	0x00E8, r24
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    2046:	90 93 f1 00 	sts	0x00F1, r25
				UEDATX = (Data >> 8);
    204a:	10 92 f1 00 	sts	0x00F1, r1
    204e:	d4 c0       	rjmp	.+424    	; 0x21f8 <__stack+0xf9>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2050:	88 23       	and	r24, r24
    2052:	19 f0       	breq	.+6      	; 0x205a <USB_Device_ProcessControlRequest+0xf6>
    2054:	82 30       	cpi	r24, 0x02	; 2
    2056:	09 f0       	breq	.+2      	; 0x205a <USB_Device_ProcessControlRequest+0xf6>
    2058:	f3 c0       	rjmp	.+486    	; 0x2240 <__stack+0x141>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    205a:	90 e0       	ldi	r25, 0x00	; 0
    205c:	8f 71       	andi	r24, 0x1F	; 31
    205e:	90 70       	andi	r25, 0x00	; 0
    2060:	00 97       	sbiw	r24, 0x00	; 0
    2062:	21 f0       	breq	.+8      	; 0x206c <USB_Device_ProcessControlRequest+0x108>
    2064:	02 97       	sbiw	r24, 0x02	; 2
    2066:	09 f0       	breq	.+2      	; 0x206a <USB_Device_ProcessControlRequest+0x106>
    2068:	eb c0       	rjmp	.+470    	; 0x2240 <__stack+0x141>
    206a:	0c c0       	rjmp	.+24     	; 0x2084 <USB_Device_ProcessControlRequest+0x120>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    206c:	80 91 03 14 	lds	r24, 0x1403
    2070:	81 30       	cpi	r24, 0x01	; 1
    2072:	09 f0       	breq	.+2      	; 0x2076 <USB_Device_ProcessControlRequest+0x112>
    2074:	e5 c0       	rjmp	.+458    	; 0x2240 <__stack+0x141>
			  USB_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    2076:	10 92 fd 13 	sts	0x13FD, r1
    207a:	33 30       	cpi	r19, 0x03	; 3
    207c:	69 f5       	brne	.+90     	; 0x20d8 <USB_Device_ProcessControlRequest+0x174>
    207e:	80 93 fd 13 	sts	0x13FD, r24
    2082:	2a c0       	rjmp	.+84     	; 0x20d8 <USB_Device_ProcessControlRequest+0x174>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    2084:	80 91 03 14 	lds	r24, 0x1403
    2088:	88 23       	and	r24, r24
    208a:	31 f5       	brne	.+76     	; 0x20d8 <USB_Device_ProcessControlRequest+0x174>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    208c:	20 91 05 14 	lds	r18, 0x1405
    2090:	27 70       	andi	r18, 0x07	; 7

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    2092:	09 f4       	brne	.+2      	; 0x2096 <USB_Device_ProcessControlRequest+0x132>
    2094:	d5 c0       	rjmp	.+426    	; 0x2240 <__stack+0x141>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2096:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    209a:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    209e:	80 ff       	sbrs	r24, 0
    20a0:	1b c0       	rjmp	.+54     	; 0x20d8 <USB_Device_ProcessControlRequest+0x174>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    20a2:	33 30       	cpi	r19, 0x03	; 3
    20a4:	21 f4       	brne	.+8      	; 0x20ae <USB_Device_ProcessControlRequest+0x14a>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    20a6:	80 91 eb 00 	lds	r24, 0x00EB
    20aa:	80 62       	ori	r24, 0x20	; 32
    20ac:	13 c0       	rjmp	.+38     	; 0x20d4 <USB_Device_ProcessControlRequest+0x170>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    20ae:	80 91 eb 00 	lds	r24, 0x00EB
    20b2:	80 61       	ori	r24, 0x10	; 16
    20b4:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    20b8:	81 e0       	ldi	r24, 0x01	; 1
    20ba:	90 e0       	ldi	r25, 0x00	; 0
    20bc:	02 c0       	rjmp	.+4      	; 0x20c2 <USB_Device_ProcessControlRequest+0x15e>
    20be:	88 0f       	add	r24, r24
    20c0:	99 1f       	adc	r25, r25
    20c2:	2a 95       	dec	r18
    20c4:	e2 f7       	brpl	.-8      	; 0x20be <USB_Device_ProcessControlRequest+0x15a>
    20c6:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    20ca:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    20ce:	80 91 eb 00 	lds	r24, 0x00EB
    20d2:	88 60       	ori	r24, 0x08	; 8
    20d4:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    20d8:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    20dc:	80 91 e8 00 	lds	r24, 0x00E8
    20e0:	87 7f       	andi	r24, 0xF7	; 247
    20e2:	8d c0       	rjmp	.+282    	; 0x21fe <__stack+0xff>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    20e4:	88 23       	and	r24, r24
    20e6:	09 f0       	breq	.+2      	; 0x20ea <USB_Device_ProcessControlRequest+0x186>
    20e8:	ab c0       	rjmp	.+342    	; 0x2240 <__stack+0x141>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t    DeviceAddress    = (USB_ControlRequest.wValue & 0x7F);
    20ea:	10 91 03 14 	lds	r17, 0x1403
    20ee:	1f 77       	andi	r17, 0x7F	; 127
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    20f0:	0f b7       	in	r16, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    20f2:	f8 94       	cli
    20f4:	80 91 e8 00 	lds	r24, 0x00E8
    20f8:	87 7f       	andi	r24, 0xF7	; 247
    20fa:	80 93 e8 00 	sts	0x00E8, r24
	uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
	GlobalInterruptDisable();
				
	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    20fe:	b4 dd       	rcall	.-1176   	; 0x1c68 <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2100:	80 91 e8 00 	lds	r24, 0x00E8

	while (!(Endpoint_IsINReady()));
    2104:	80 ff       	sbrs	r24, 0
    2106:	fc cf       	rjmp	.-8      	; 0x2100 <__stack+0x1>
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR  = ((UDADDR & (1 << ADDEN)) | (Address & 0x7F));
    2108:	80 91 e3 00 	lds	r24, 0x00E3
    210c:	80 78       	andi	r24, 0x80	; 128
    210e:	81 2b       	or	r24, r17
    2110:	80 93 e3 00 	sts	0x00E3, r24
				UDADDR |= (1 << ADDEN);
    2114:	80 91 e3 00 	lds	r24, 0x00E3
    2118:	80 68       	ori	r24, 0x80	; 128
    211a:	80 93 e3 00 	sts	0x00E3, r24

	USB_Device_SetDeviceAddress(DeviceAddress);
	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    211e:	11 23       	and	r17, r17
    2120:	11 f4       	brne	.+4      	; 0x2126 <__stack+0x27>
    2122:	82 e0       	ldi	r24, 0x02	; 2
    2124:	01 c0       	rjmp	.+2      	; 0x2128 <__stack+0x29>
    2126:	83 e0       	ldi	r24, 0x03	; 3
    2128:	80 93 00 14 	sts	0x1400, r24
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    212c:	0f bf       	out	0x3f, r16	; 63
				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
				else
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#endif
				
				GCC_MEMORY_BARRIER();
    212e:	88 c0       	rjmp	.+272    	; 0x2240 <__stack+0x141>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2130:	80 58       	subi	r24, 0x80	; 128
    2132:	82 30       	cpi	r24, 0x02	; 2
    2134:	08 f0       	brcs	.+2      	; 0x2138 <__stack+0x39>
    2136:	84 c0       	rjmp	.+264    	; 0x2240 <__stack+0x141>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    2138:	80 91 03 14 	lds	r24, 0x1403
    213c:	90 91 04 14 	lds	r25, 0x1404
    2140:	23 e0       	ldi	r18, 0x03	; 3
    2142:	8c 3d       	cpi	r24, 0xDC	; 220
    2144:	92 07       	cpc	r25, r18
    2146:	09 f0       	breq	.+2      	; 0x214a <__stack+0x4b>
    2148:	33 c0       	rjmp	.+102    	; 0x21b0 <__stack+0xb1>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    214a:	83 e0       	ldi	r24, 0x03	; 3
    214c:	8c 83       	std	Y+4, r24	; 0x04
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    214e:	8a e2       	ldi	r24, 0x2A	; 42
    2150:	8b 83       	std	Y+3, r24	; 0x03
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    2152:	7f b7       	in	r23, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    2154:	f8 94       	cli
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#endif

				GCC_MEMORY_BARRIER();
    2156:	de 01       	movw	r26, r28
    2158:	15 96       	adiw	r26, 0x05	; 5
    215a:	6e e0       	ldi	r22, 0x0E	; 14
    215c:	40 e0       	ldi	r20, 0x00	; 0
    215e:	50 e0       	ldi	r21, 0x00	; 0
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    2160:	11 e2       	ldi	r17, 0x21	; 33
    2162:	e6 2f       	mov	r30, r22
    2164:	f0 e0       	ldi	r31, 0x00	; 0
    2166:	10 93 57 00 	sts	0x0057, r17
    216a:	84 91       	lpm	r24, Z+

					if (SerialCharNum & 0x01)
    216c:	40 ff       	sbrs	r20, 0
    216e:	03 c0       	rjmp	.+6      	; 0x2176 <__stack+0x77>
					{
						SerialByte >>= 4;
    2170:	82 95       	swap	r24
    2172:	8f 70       	andi	r24, 0x0F	; 15
						SigReadAddress++;
    2174:	6f 5f       	subi	r22, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    2176:	8f 70       	andi	r24, 0x0F	; 15
    2178:	28 2f       	mov	r18, r24
    217a:	30 e0       	ldi	r19, 0x00	; 0

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    217c:	8a 30       	cpi	r24, 0x0A	; 10
    217e:	18 f0       	brcs	.+6      	; 0x2186 <__stack+0x87>
    2180:	c9 01       	movw	r24, r18
    2182:	c7 96       	adiw	r24, 0x37	; 55
    2184:	02 c0       	rjmp	.+4      	; 0x218a <__stack+0x8b>
    2186:	c9 01       	movw	r24, r18
    2188:	c0 96       	adiw	r24, 0x30	; 48
    218a:	8d 93       	st	X+, r24
    218c:	9d 93       	st	X+, r25
    218e:	4f 5f       	subi	r20, 0xFF	; 255
    2190:	5f 4f       	sbci	r21, 0xFF	; 255
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    2192:	44 31       	cpi	r20, 0x14	; 20
    2194:	51 05       	cpc	r21, r1
    2196:	29 f7       	brne	.-54     	; 0x2162 <__stack+0x63>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    2198:	7f bf       	out	0x3f, r23	; 63
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    219a:	80 91 e8 00 	lds	r24, 0x00E8
    219e:	87 7f       	andi	r24, 0xF7	; 247
    21a0:	80 93 e8 00 	sts	0x00E8, r24
	
	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    21a4:	ce 01       	movw	r24, r28
    21a6:	03 96       	adiw	r24, 0x03	; 3
    21a8:	6a e2       	ldi	r22, 0x2A	; 42
    21aa:	70 e0       	ldi	r23, 0x00	; 0
    21ac:	63 d0       	rcall	.+198    	; 0x2274 <Endpoint_Write_Control_Stream_LE>
    21ae:	13 c0       	rjmp	.+38     	; 0x21d6 <__stack+0xd7>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    21b0:	60 91 05 14 	lds	r22, 0x1405
    21b4:	ae 01       	movw	r20, r28
    21b6:	4f 5f       	subi	r20, 0xFF	; 255
    21b8:	5f 4f       	sbci	r21, 0xFF	; 255
    21ba:	0e 94 d8 02 	call	0x5b0	; 0x5b0 <CALLBACK_USB_GetDescriptor>
    21be:	bc 01       	movw	r22, r24
    21c0:	00 97       	sbiw	r24, 0x00	; 0
    21c2:	09 f4       	brne	.+2      	; 0x21c6 <__stack+0xc7>
    21c4:	3d c0       	rjmp	.+122    	; 0x2240 <__stack+0x141>
    21c6:	80 91 e8 00 	lds	r24, 0x00E8
    21ca:	87 7f       	andi	r24, 0xF7	; 247
    21cc:	80 93 e8 00 	sts	0x00E8, r24
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    21d0:	89 81       	ldd	r24, Y+1	; 0x01
    21d2:	9a 81       	ldd	r25, Y+2	; 0x02
    21d4:	ee d0       	rcall	.+476    	; 0x23b2 <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    21d6:	80 91 e8 00 	lds	r24, 0x00E8
    21da:	8b 77       	andi	r24, 0x7B	; 123
    21dc:	80 93 e8 00 	sts	0x00E8, r24
    21e0:	2f c0       	rjmp	.+94     	; 0x2240 <__stack+0x141>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    21e2:	80 38       	cpi	r24, 0x80	; 128
    21e4:	69 f5       	brne	.+90     	; 0x2240 <__stack+0x141>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    21e6:	80 91 e8 00 	lds	r24, 0x00E8
    21ea:	87 7f       	andi	r24, 0xF7	; 247
    21ec:	80 93 e8 00 	sts	0x00E8, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_ConfigurationNumber);
    21f0:	80 91 fe 13 	lds	r24, 0x13FE
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    21f4:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    21f8:	80 91 e8 00 	lds	r24, 0x00E8
    21fc:	8e 77       	andi	r24, 0x7E	; 126
    21fe:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    2202:	32 dd       	rcall	.-1436   	; 0x1c68 <Endpoint_ClearStatusStage>
    2204:	1d c0       	rjmp	.+58     	; 0x2240 <__stack+0x141>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    2206:	88 23       	and	r24, r24
    2208:	d9 f4       	brne	.+54     	; 0x2240 <__stack+0x141>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    220a:	90 91 03 14 	lds	r25, 0x1403
    220e:	92 30       	cpi	r25, 0x02	; 2
    2210:	b8 f4       	brcc	.+46     	; 0x2240 <__stack+0x141>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2212:	80 91 e8 00 	lds	r24, 0x00E8
    2216:	87 7f       	andi	r24, 0xF7	; 247
    2218:	80 93 e8 00 	sts	0x00E8, r24
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    221c:	90 93 fe 13 	sts	0x13FE, r25

	Endpoint_ClearStatusStage();
    2220:	23 dd       	rcall	.-1466   	; 0x1c68 <Endpoint_ClearStatusStage>

	if (USB_ConfigurationNumber)
    2222:	80 91 fe 13 	lds	r24, 0x13FE
    2226:	88 23       	and	r24, r24
    2228:	31 f4       	brne	.+12     	; 0x2236 <__stack+0x137>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    222a:	80 91 e3 00 	lds	r24, 0x00E3
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    222e:	87 fd       	sbrc	r24, 7
    2230:	02 c0       	rjmp	.+4      	; 0x2236 <__stack+0x137>
    2232:	81 e0       	ldi	r24, 0x01	; 1
    2234:	01 c0       	rjmp	.+2      	; 0x2238 <__stack+0x139>
    2236:	84 e0       	ldi	r24, 0x04	; 4
    2238:	80 93 00 14 	sts	0x1400, r24

	EVENT_USB_Device_ConfigurationChanged();
    223c:	0e 94 3e 02 	call	0x47c	; 0x47c <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2240:	80 91 e8 00 	lds	r24, 0x00E8

				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    2244:	83 ff       	sbrs	r24, 3
    2246:	0a c0       	rjmp	.+20     	; 0x225c <__stack+0x15d>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    2248:	80 91 eb 00 	lds	r24, 0x00EB
    224c:	80 62       	ori	r24, 0x20	; 32
    224e:	80 93 eb 00 	sts	0x00EB, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2252:	80 91 e8 00 	lds	r24, 0x00E8
    2256:	87 7f       	andi	r24, 0xF7	; 247
    2258:	80 93 e8 00 	sts	0x00E8, r24
	{
		Endpoint_StallTransaction();
		Endpoint_ClearSETUP();
	}
}
    225c:	ac 96       	adiw	r28, 0x2c	; 44
    225e:	0f b6       	in	r0, 0x3f	; 63
    2260:	f8 94       	cli
    2262:	de bf       	out	0x3e, r29	; 62
    2264:	0f be       	out	0x3f, r0	; 63
    2266:	cd bf       	out	0x3d, r28	; 61
    2268:	cf 91       	pop	r28
    226a:	df 91       	pop	r29
    226c:	1f 91       	pop	r17
    226e:	0f 91       	pop	r16
    2270:	08 95       	ret

00002272 <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    2272:	08 95       	ret

00002274 <Endpoint_Write_Control_Stream_LE>:
    2274:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    2276:	40 91 07 14 	lds	r20, 0x1407
    227a:	50 91 08 14 	lds	r21, 0x1408
    227e:	46 17       	cp	r20, r22
    2280:	57 07       	cpc	r21, r23
    2282:	18 f4       	brcc	.+6      	; 0x228a <Endpoint_Write_Control_Stream_LE+0x16>
uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    2284:	f9 01       	movw	r30, r18
    2286:	90 e0       	ldi	r25, 0x00	; 0
    2288:	3d c0       	rjmp	.+122    	; 0x2304 <Endpoint_Write_Control_Stream_LE+0x90>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    228a:	61 15       	cp	r22, r1
    228c:	71 05       	cpc	r23, r1
    228e:	11 f0       	breq	.+4      	; 0x2294 <Endpoint_Write_Control_Stream_LE+0x20>
    2290:	ab 01       	movw	r20, r22
    2292:	f8 cf       	rjmp	.-16     	; 0x2284 <Endpoint_Write_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2294:	80 91 e8 00 	lds	r24, 0x00E8
    2298:	8e 77       	andi	r24, 0x7E	; 126
    229a:	80 93 e8 00 	sts	0x00E8, r24
    229e:	40 e0       	ldi	r20, 0x00	; 0
    22a0:	50 e0       	ldi	r21, 0x00	; 0
    22a2:	f0 cf       	rjmp	.-32     	; 0x2284 <Endpoint_Write_Control_Stream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    22a4:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    22a8:	88 23       	and	r24, r24
    22aa:	f1 f1       	breq	.+124    	; 0x2328 <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    22ac:	85 30       	cpi	r24, 0x05	; 5
    22ae:	f1 f1       	breq	.+124    	; 0x232c <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    22b0:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    22b4:	83 ff       	sbrs	r24, 3
    22b6:	02 c0       	rjmp	.+4      	; 0x22bc <Endpoint_Write_Control_Stream_LE+0x48>
    22b8:	81 e0       	ldi	r24, 0x01	; 1
    22ba:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    22bc:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    22c0:	82 fd       	sbrc	r24, 2
    22c2:	2c c0       	rjmp	.+88     	; 0x231c <Endpoint_Write_Control_Stream_LE+0xa8>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    22c4:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    22c8:	80 ff       	sbrs	r24, 0
    22ca:	1c c0       	rjmp	.+56     	; 0x2304 <Endpoint_Write_Control_Stream_LE+0x90>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    22cc:	20 91 f2 00 	lds	r18, 0x00F2
    22d0:	30 91 f3 00 	lds	r19, 0x00F3
    22d4:	07 c0       	rjmp	.+14     	; 0x22e4 <Endpoint_Write_Control_Stream_LE+0x70>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    22d6:	81 91       	ld	r24, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    22d8:	80 93 f1 00 	sts	0x00F1, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    22dc:	41 50       	subi	r20, 0x01	; 1
    22de:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    22e0:	2f 5f       	subi	r18, 0xFF	; 255
    22e2:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
    22e4:	41 15       	cp	r20, r1
    22e6:	51 05       	cpc	r21, r1
    22e8:	19 f0       	breq	.+6      	; 0x22f0 <Endpoint_Write_Control_Stream_LE+0x7c>
    22ea:	28 30       	cpi	r18, 0x08	; 8
    22ec:	31 05       	cpc	r19, r1
    22ee:	98 f3       	brcs	.-26     	; 0x22d6 <Endpoint_Write_Control_Stream_LE+0x62>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
    22f0:	90 e0       	ldi	r25, 0x00	; 0
    22f2:	28 30       	cpi	r18, 0x08	; 8
    22f4:	31 05       	cpc	r19, r1
    22f6:	09 f4       	brne	.+2      	; 0x22fa <Endpoint_Write_Control_Stream_LE+0x86>
    22f8:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    22fa:	80 91 e8 00 	lds	r24, 0x00E8
    22fe:	8e 77       	andi	r24, 0x7E	; 126
    2300:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    2304:	41 15       	cp	r20, r1
    2306:	51 05       	cpc	r21, r1
    2308:	69 f6       	brne	.-102    	; 0x22a4 <Endpoint_Write_Control_Stream_LE+0x30>
    230a:	99 23       	and	r25, r25
    230c:	59 f6       	brne	.-106    	; 0x22a4 <Endpoint_Write_Control_Stream_LE+0x30>
    230e:	06 c0       	rjmp	.+12     	; 0x231c <Endpoint_Write_Control_Stream_LE+0xa8>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2310:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2314:	88 23       	and	r24, r24
    2316:	41 f0       	breq	.+16     	; 0x2328 <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2318:	85 30       	cpi	r24, 0x05	; 5
    231a:	41 f0       	breq	.+16     	; 0x232c <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    231c:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    2320:	82 ff       	sbrs	r24, 2
    2322:	f6 cf       	rjmp	.-20     	; 0x2310 <Endpoint_Write_Control_Stream_LE+0x9c>
    2324:	80 e0       	ldi	r24, 0x00	; 0
    2326:	08 95       	ret
    2328:	82 e0       	ldi	r24, 0x02	; 2
    232a:	08 95       	ret
    232c:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    232e:	08 95       	ret

00002330 <Endpoint_Read_Control_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
    2330:	9c 01       	movw	r18, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
    2332:	61 15       	cp	r22, r1
    2334:	71 05       	cpc	r23, r1
    2336:	29 f4       	brne	.+10     	; 0x2342 <Endpoint_Read_Control_Stream_LE+0x12>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2338:	80 91 e8 00 	lds	r24, 0x00E8
    233c:	8b 77       	andi	r24, 0x7B	; 123
    233e:	80 93 e8 00 	sts	0x00E8, r24
uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    2342:	f9 01       	movw	r30, r18
    2344:	22 c0       	rjmp	.+68     	; 0x238a <Endpoint_Read_Control_Stream_LE+0x5a>
	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2346:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    234a:	88 23       	and	r24, r24
    234c:	71 f1       	breq	.+92     	; 0x23aa <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    234e:	85 30       	cpi	r24, 0x05	; 5
    2350:	71 f1       	breq	.+92     	; 0x23ae <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2352:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    2356:	83 ff       	sbrs	r24, 3
    2358:	02 c0       	rjmp	.+4      	; 0x235e <Endpoint_Read_Control_Stream_LE+0x2e>
    235a:	81 e0       	ldi	r24, 0x01	; 1
    235c:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    235e:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    2362:	82 ff       	sbrs	r24, 2
    2364:	f0 cf       	rjmp	.-32     	; 0x2346 <Endpoint_Read_Control_Stream_LE+0x16>
    2366:	06 c0       	rjmp	.+12     	; 0x2374 <Endpoint_Read_Control_Stream_LE+0x44>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    2368:	80 91 f1 00 	lds	r24, 0x00F1
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    236c:	81 93       	st	Z+, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    236e:	61 50       	subi	r22, 0x01	; 1
    2370:	70 40       	sbci	r23, 0x00	; 0
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
    2372:	31 f0       	breq	.+12     	; 0x2380 <Endpoint_Read_Control_Stream_LE+0x50>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    2374:	80 91 f2 00 	lds	r24, 0x00F2
    2378:	90 91 f3 00 	lds	r25, 0x00F3
    237c:	89 2b       	or	r24, r25
    237e:	a1 f7       	brne	.-24     	; 0x2368 <Endpoint_Read_Control_Stream_LE+0x38>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2380:	80 91 e8 00 	lds	r24, 0x00E8
    2384:	8b 77       	andi	r24, 0x7B	; 123
    2386:	80 93 e8 00 	sts	0x00E8, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
    238a:	61 15       	cp	r22, r1
    238c:	71 05       	cpc	r23, r1
    238e:	d9 f6       	brne	.-74     	; 0x2346 <Endpoint_Read_Control_Stream_LE+0x16>
    2390:	06 c0       	rjmp	.+12     	; 0x239e <Endpoint_Read_Control_Stream_LE+0x6e>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2392:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2396:	88 23       	and	r24, r24
    2398:	41 f0       	breq	.+16     	; 0x23aa <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    239a:	85 30       	cpi	r24, 0x05	; 5
    239c:	41 f0       	breq	.+16     	; 0x23ae <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    239e:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
    23a2:	80 ff       	sbrs	r24, 0
    23a4:	f6 cf       	rjmp	.-20     	; 0x2392 <Endpoint_Read_Control_Stream_LE+0x62>
    23a6:	80 e0       	ldi	r24, 0x00	; 0
    23a8:	08 95       	ret
    23aa:	82 e0       	ldi	r24, 0x02	; 2
    23ac:	08 95       	ret
    23ae:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    23b0:	08 95       	ret

000023b2 <Endpoint_Write_Control_PStream_LE>:
uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
    23b2:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    23b4:	40 91 07 14 	lds	r20, 0x1407
    23b8:	50 91 08 14 	lds	r21, 0x1408
    23bc:	46 17       	cp	r20, r22
    23be:	57 07       	cpc	r21, r23
    23c0:	18 f4       	brcc	.+6      	; 0x23c8 <Endpoint_Write_Control_PStream_LE+0x16>
uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    23c2:	f9 01       	movw	r30, r18
    23c4:	90 e0       	ldi	r25, 0x00	; 0
    23c6:	40 c0       	rjmp	.+128    	; 0x2448 <Endpoint_Write_Control_PStream_LE+0x96>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    23c8:	61 15       	cp	r22, r1
    23ca:	71 05       	cpc	r23, r1
    23cc:	11 f0       	breq	.+4      	; 0x23d2 <Endpoint_Write_Control_PStream_LE+0x20>
    23ce:	ab 01       	movw	r20, r22
    23d0:	f8 cf       	rjmp	.-16     	; 0x23c2 <Endpoint_Write_Control_PStream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    23d2:	80 91 e8 00 	lds	r24, 0x00E8
    23d6:	8e 77       	andi	r24, 0x7E	; 126
    23d8:	80 93 e8 00 	sts	0x00E8, r24
    23dc:	40 e0       	ldi	r20, 0x00	; 0
    23de:	50 e0       	ldi	r21, 0x00	; 0
    23e0:	f0 cf       	rjmp	.-32     	; 0x23c2 <Endpoint_Write_Control_PStream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    23e2:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    23e6:	88 23       	and	r24, r24
    23e8:	09 f4       	brne	.+2      	; 0x23ec <Endpoint_Write_Control_PStream_LE+0x3a>
    23ea:	40 c0       	rjmp	.+128    	; 0x246c <Endpoint_Write_Control_PStream_LE+0xba>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    23ec:	85 30       	cpi	r24, 0x05	; 5
    23ee:	09 f4       	brne	.+2      	; 0x23f2 <Endpoint_Write_Control_PStream_LE+0x40>
    23f0:	3f c0       	rjmp	.+126    	; 0x2470 <Endpoint_Write_Control_PStream_LE+0xbe>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    23f2:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    23f6:	83 ff       	sbrs	r24, 3
    23f8:	02 c0       	rjmp	.+4      	; 0x23fe <Endpoint_Write_Control_PStream_LE+0x4c>
    23fa:	81 e0       	ldi	r24, 0x01	; 1
    23fc:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    23fe:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    2402:	82 fd       	sbrc	r24, 2
    2404:	2d c0       	rjmp	.+90     	; 0x2460 <Endpoint_Write_Control_PStream_LE+0xae>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2406:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    240a:	80 ff       	sbrs	r24, 0
    240c:	1d c0       	rjmp	.+58     	; 0x2448 <Endpoint_Write_Control_PStream_LE+0x96>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    240e:	20 91 f2 00 	lds	r18, 0x00F2
    2412:	30 91 f3 00 	lds	r19, 0x00F3
    2416:	08 c0       	rjmp	.+16     	; 0x2428 <Endpoint_Write_Control_PStream_LE+0x76>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    2418:	84 91       	lpm	r24, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    241a:	80 93 f1 00 	sts	0x00F1, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    241e:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    2420:	41 50       	subi	r20, 0x01	; 1
    2422:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    2424:	2f 5f       	subi	r18, 0xFF	; 255
    2426:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
    2428:	41 15       	cp	r20, r1
    242a:	51 05       	cpc	r21, r1
    242c:	19 f0       	breq	.+6      	; 0x2434 <Endpoint_Write_Control_PStream_LE+0x82>
    242e:	28 30       	cpi	r18, 0x08	; 8
    2430:	31 05       	cpc	r19, r1
    2432:	90 f3       	brcs	.-28     	; 0x2418 <Endpoint_Write_Control_PStream_LE+0x66>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
    2434:	90 e0       	ldi	r25, 0x00	; 0
    2436:	28 30       	cpi	r18, 0x08	; 8
    2438:	31 05       	cpc	r19, r1
    243a:	09 f4       	brne	.+2      	; 0x243e <Endpoint_Write_Control_PStream_LE+0x8c>
    243c:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    243e:	80 91 e8 00 	lds	r24, 0x00E8
    2442:	8e 77       	andi	r24, 0x7E	; 126
    2444:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    2448:	41 15       	cp	r20, r1
    244a:	51 05       	cpc	r21, r1
    244c:	51 f6       	brne	.-108    	; 0x23e2 <Endpoint_Write_Control_PStream_LE+0x30>
    244e:	99 23       	and	r25, r25
    2450:	41 f6       	brne	.-112    	; 0x23e2 <Endpoint_Write_Control_PStream_LE+0x30>
    2452:	06 c0       	rjmp	.+12     	; 0x2460 <Endpoint_Write_Control_PStream_LE+0xae>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2454:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2458:	88 23       	and	r24, r24
    245a:	41 f0       	breq	.+16     	; 0x246c <Endpoint_Write_Control_PStream_LE+0xba>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    245c:	85 30       	cpi	r24, 0x05	; 5
    245e:	41 f0       	breq	.+16     	; 0x2470 <Endpoint_Write_Control_PStream_LE+0xbe>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2460:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    2464:	82 ff       	sbrs	r24, 2
    2466:	f6 cf       	rjmp	.-20     	; 0x2454 <Endpoint_Write_Control_PStream_LE+0xa2>
    2468:	80 e0       	ldi	r24, 0x00	; 0
    246a:	08 95       	ret
    246c:	82 e0       	ldi	r24, 0x02	; 2
    246e:	08 95       	ret
    2470:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    2472:	08 95       	ret

00002474 <Endpoint_Read_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    2474:	bf 92       	push	r11
    2476:	cf 92       	push	r12
    2478:	df 92       	push	r13
    247a:	ef 92       	push	r14
    247c:	ff 92       	push	r15
    247e:	0f 93       	push	r16
    2480:	1f 93       	push	r17
    2482:	cf 93       	push	r28
    2484:	df 93       	push	r29
    2486:	18 2f       	mov	r17, r24
    2488:	09 2f       	mov	r16, r25
    248a:	7b 01       	movw	r14, r22
    248c:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    248e:	0d dc       	rcall	.-2022   	; 0x1caa <Endpoint_WaitUntilReady>
    2490:	b8 2e       	mov	r11, r24
    2492:	88 23       	and	r24, r24
    2494:	b1 f5       	brne	.+108    	; 0x2502 <Endpoint_Read_Stream_LE+0x8e>
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    2496:	81 2f       	mov	r24, r17
    2498:	90 2f       	mov	r25, r16
    249a:	9c 01       	movw	r18, r24
    249c:	e9 01       	movw	r28, r18
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    249e:	c1 14       	cp	r12, r1
    24a0:	d1 04       	cpc	r13, r1
    24a2:	39 f0       	breq	.+14     	; 0x24b2 <Endpoint_Read_Stream_LE+0x3e>
	{
		Length -= *BytesProcessed;
    24a4:	f6 01       	movw	r30, r12
    24a6:	80 81       	ld	r24, Z
    24a8:	91 81       	ldd	r25, Z+1	; 0x01
    24aa:	e8 1a       	sub	r14, r24
    24ac:	f9 0a       	sbc	r15, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    24ae:	c8 0f       	add	r28, r24
    24b0:	d9 1f       	adc	r29, r25
    24b2:	00 e0       	ldi	r16, 0x00	; 0
    24b4:	10 e0       	ldi	r17, 0x00	; 0
    24b6:	22 c0       	rjmp	.+68     	; 0x24fc <Endpoint_Read_Stream_LE+0x88>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    24b8:	80 91 e8 00 	lds	r24, 0x00E8
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    24bc:	85 fd       	sbrc	r24, 5
    24be:	16 c0       	rjmp	.+44     	; 0x24ec <Endpoint_Read_Stream_LE+0x78>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    24c0:	80 91 e8 00 	lds	r24, 0x00E8
    24c4:	8b 77       	andi	r24, 0x7B	; 123
    24c6:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			if (BytesProcessed != NULL)
    24ca:	c1 14       	cp	r12, r1
    24cc:	d1 04       	cpc	r13, r1
    24ce:	49 f0       	breq	.+18     	; 0x24e2 <Endpoint_Read_Stream_LE+0x6e>
			{
				*BytesProcessed += BytesInTransfer;
    24d0:	f6 01       	movw	r30, r12
    24d2:	80 81       	ld	r24, Z
    24d4:	91 81       	ldd	r25, Z+1	; 0x01
    24d6:	80 0f       	add	r24, r16
    24d8:	91 1f       	adc	r25, r17
    24da:	91 83       	std	Z+1, r25	; 0x01
    24dc:	80 83       	st	Z, r24
    24de:	85 e0       	ldi	r24, 0x05	; 5
    24e0:	11 c0       	rjmp	.+34     	; 0x2504 <Endpoint_Read_Stream_LE+0x90>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    24e2:	6c d0       	rcall	.+216    	; 0x25bc <USB_USBTask>
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    24e4:	e2 db       	rcall	.-2108   	; 0x1caa <Endpoint_WaitUntilReady>
    24e6:	88 23       	and	r24, r24
    24e8:	49 f0       	breq	.+18     	; 0x24fc <Endpoint_Read_Stream_LE+0x88>
    24ea:	0c c0       	rjmp	.+24     	; 0x2504 <Endpoint_Read_Stream_LE+0x90>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    24ec:	80 91 f1 00 	lds	r24, 0x00F1
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    24f0:	89 93       	st	Y+, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    24f2:	08 94       	sec
    24f4:	e1 08       	sbc	r14, r1
    24f6:	f1 08       	sbc	r15, r1
			BytesInTransfer++;
    24f8:	0f 5f       	subi	r16, 0xFF	; 255
    24fa:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    24fc:	e1 14       	cp	r14, r1
    24fe:	f1 04       	cpc	r15, r1
    2500:	d9 f6       	brne	.-74     	; 0x24b8 <Endpoint_Read_Stream_LE+0x44>
    2502:	8b 2d       	mov	r24, r11
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    2504:	df 91       	pop	r29
    2506:	cf 91       	pop	r28
    2508:	1f 91       	pop	r17
    250a:	0f 91       	pop	r16
    250c:	ff 90       	pop	r15
    250e:	ef 90       	pop	r14
    2510:	df 90       	pop	r13
    2512:	cf 90       	pop	r12
    2514:	bf 90       	pop	r11
    2516:	08 95       	ret

00002518 <Endpoint_Write_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    2518:	bf 92       	push	r11
    251a:	cf 92       	push	r12
    251c:	df 92       	push	r13
    251e:	ef 92       	push	r14
    2520:	ff 92       	push	r15
    2522:	0f 93       	push	r16
    2524:	1f 93       	push	r17
    2526:	cf 93       	push	r28
    2528:	df 93       	push	r29
    252a:	18 2f       	mov	r17, r24
    252c:	09 2f       	mov	r16, r25
    252e:	7b 01       	movw	r14, r22
    2530:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    2532:	bb db       	rcall	.-2186   	; 0x1caa <Endpoint_WaitUntilReady>
    2534:	b8 2e       	mov	r11, r24
    2536:	88 23       	and	r24, r24
    2538:	b1 f5       	brne	.+108    	; 0x25a6 <Endpoint_Write_Stream_LE+0x8e>
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    253a:	81 2f       	mov	r24, r17
    253c:	90 2f       	mov	r25, r16
    253e:	9c 01       	movw	r18, r24
    2540:	e9 01       	movw	r28, r18
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    2542:	c1 14       	cp	r12, r1
    2544:	d1 04       	cpc	r13, r1
    2546:	39 f0       	breq	.+14     	; 0x2556 <Endpoint_Write_Stream_LE+0x3e>
	{
		Length -= *BytesProcessed;
    2548:	f6 01       	movw	r30, r12
    254a:	80 81       	ld	r24, Z
    254c:	91 81       	ldd	r25, Z+1	; 0x01
    254e:	e8 1a       	sub	r14, r24
    2550:	f9 0a       	sbc	r15, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    2552:	c8 0f       	add	r28, r24
    2554:	d9 1f       	adc	r29, r25
    2556:	00 e0       	ldi	r16, 0x00	; 0
    2558:	10 e0       	ldi	r17, 0x00	; 0
    255a:	22 c0       	rjmp	.+68     	; 0x25a0 <Endpoint_Write_Stream_LE+0x88>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    255c:	80 91 e8 00 	lds	r24, 0x00E8
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    2560:	85 fd       	sbrc	r24, 5
    2562:	16 c0       	rjmp	.+44     	; 0x2590 <Endpoint_Write_Stream_LE+0x78>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2564:	80 91 e8 00 	lds	r24, 0x00E8
    2568:	8e 77       	andi	r24, 0x7E	; 126
    256a:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			if (BytesProcessed != NULL)
    256e:	c1 14       	cp	r12, r1
    2570:	d1 04       	cpc	r13, r1
    2572:	49 f0       	breq	.+18     	; 0x2586 <Endpoint_Write_Stream_LE+0x6e>
			{
				*BytesProcessed += BytesInTransfer;
    2574:	f6 01       	movw	r30, r12
    2576:	80 81       	ld	r24, Z
    2578:	91 81       	ldd	r25, Z+1	; 0x01
    257a:	80 0f       	add	r24, r16
    257c:	91 1f       	adc	r25, r17
    257e:	91 83       	std	Z+1, r25	; 0x01
    2580:	80 83       	st	Z, r24
    2582:	85 e0       	ldi	r24, 0x05	; 5
    2584:	11 c0       	rjmp	.+34     	; 0x25a8 <Endpoint_Write_Stream_LE+0x90>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    2586:	1a d0       	rcall	.+52     	; 0x25bc <USB_USBTask>
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    2588:	90 db       	rcall	.-2272   	; 0x1caa <Endpoint_WaitUntilReady>
    258a:	88 23       	and	r24, r24
    258c:	49 f0       	breq	.+18     	; 0x25a0 <Endpoint_Write_Stream_LE+0x88>
    258e:	0c c0       	rjmp	.+24     	; 0x25a8 <Endpoint_Write_Stream_LE+0x90>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    2590:	89 91       	ld	r24, Y+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    2592:	80 93 f1 00 	sts	0x00F1, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    2596:	08 94       	sec
    2598:	e1 08       	sbc	r14, r1
    259a:	f1 08       	sbc	r15, r1
			BytesInTransfer++;
    259c:	0f 5f       	subi	r16, 0xFF	; 255
    259e:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    25a0:	e1 14       	cp	r14, r1
    25a2:	f1 04       	cpc	r15, r1
    25a4:	d9 f6       	brne	.-74     	; 0x255c <Endpoint_Write_Stream_LE+0x44>
    25a6:	8b 2d       	mov	r24, r11
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    25a8:	df 91       	pop	r29
    25aa:	cf 91       	pop	r28
    25ac:	1f 91       	pop	r17
    25ae:	0f 91       	pop	r16
    25b0:	ff 90       	pop	r15
    25b2:	ef 90       	pop	r14
    25b4:	df 90       	pop	r13
    25b6:	cf 90       	pop	r12
    25b8:	bf 90       	pop	r11
    25ba:	08 95       	ret

000025bc <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    25bc:	1f 93       	push	r17
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
    25be:	80 91 00 14 	lds	r24, 0x1400
    25c2:	88 23       	and	r24, r24
    25c4:	61 f0       	breq	.+24     	; 0x25de <USB_USBTask+0x22>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    25c6:	10 91 e9 00 	lds	r17, 0x00E9
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    25ca:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    25ce:	80 91 e8 00 	lds	r24, 0x00E8
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSETUPReceived())
    25d2:	83 ff       	sbrs	r24, 3
    25d4:	01 c0       	rjmp	.+2      	; 0x25d8 <USB_USBTask+0x1c>
		  USB_Device_ProcessControlRequest();
    25d6:	c6 dc       	rcall	.-1652   	; 0x1f64 <USB_Device_ProcessControlRequest>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    25d8:	17 70       	andi	r17, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    25da:	10 93 e9 00 	sts	0x00E9, r17
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
		  USB_HostTask();
	#endif
}
    25de:	1f 91       	pop	r17
    25e0:	08 95       	ret

000025e2 <RNDIS_Device_IsPacketReceived>:
			return false;
	}
}

bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    25e2:	fc 01       	movw	r30, r24
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    25e4:	80 91 00 14 	lds	r24, 0x1400
    25e8:	84 30       	cpi	r24, 0x04	; 4
    25ea:	99 f4       	brne	.+38     	; 0x2612 <RNDIS_Device_IsPacketReceived+0x30>
    25ec:	ea 56       	subi	r30, 0x6A	; 106
    25ee:	ff 4f       	sbci	r31, 0xFF	; 255
    25f0:	80 81       	ld	r24, Z
    25f2:	e6 59       	subi	r30, 0x96	; 150
    25f4:	f0 40       	sbci	r31, 0x00	; 0
    25f6:	82 30       	cpi	r24, 0x02	; 2
    25f8:	61 f4       	brne	.+24     	; 0x2612 <RNDIS_Device_IsPacketReceived+0x30>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return false;
	}
	
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpointNumber);
    25fa:	85 81       	ldd	r24, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    25fc:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2600:	80 91 e8 00 	lds	r24, 0x00E8
    2604:	90 e0       	ldi	r25, 0x00	; 0
    2606:	96 95       	lsr	r25
    2608:	87 95       	ror	r24
    260a:	96 95       	lsr	r25
    260c:	87 95       	ror	r24
    260e:	81 70       	andi	r24, 0x01	; 1
    2610:	08 95       	ret
	return Endpoint_IsOUTReceived();
    2612:	80 e0       	ldi	r24, 0x00	; 0
}
    2614:	08 95       	ret

00002616 <RNDIS_Device_SendPacket>:
}

uint8_t RNDIS_Device_SendPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                const uint16_t PacketLength)
{
    2616:	cf 92       	push	r12
    2618:	df 92       	push	r13
    261a:	ff 92       	push	r15
    261c:	0f 93       	push	r16
    261e:	1f 93       	push	r17
    2620:	df 93       	push	r29
    2622:	cf 93       	push	r28
    2624:	cd b7       	in	r28, 0x3d	; 61
    2626:	de b7       	in	r29, 0x3e	; 62
    2628:	ac 97       	sbiw	r28, 0x2c	; 44
    262a:	0f b6       	in	r0, 0x3f	; 63
    262c:	f8 94       	cli
    262e:	de bf       	out	0x3e, r29	; 62
    2630:	0f be       	out	0x3f, r0	; 63
    2632:	cd bf       	out	0x3d, r28	; 61
    2634:	fc 01       	movw	r30, r24
    2636:	6b 01       	movw	r12, r22
    2638:	8a 01       	movw	r16, r20
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    263a:	80 91 00 14 	lds	r24, 0x1400
    263e:	84 30       	cpi	r24, 0x04	; 4
    2640:	09 f0       	breq	.+2      	; 0x2644 <RNDIS_Device_SendPacket+0x2e>
    2642:	49 c0       	rjmp	.+146    	; 0x26d6 <RNDIS_Device_SendPacket+0xc0>
    2644:	ea 56       	subi	r30, 0x6A	; 106
    2646:	ff 4f       	sbci	r31, 0xFF	; 255
    2648:	80 81       	ld	r24, Z
    264a:	e6 59       	subi	r30, 0x96	; 150
    264c:	f0 40       	sbci	r31, 0x00	; 0
    264e:	82 30       	cpi	r24, 0x02	; 2
    2650:	09 f0       	breq	.+2      	; 0x2654 <RNDIS_Device_SendPacket+0x3e>
    2652:	41 c0       	rjmp	.+130    	; 0x26d6 <RNDIS_Device_SendPacket+0xc0>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}
	
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataINEndpointNumber);
    2654:	81 81       	ldd	r24, Z+1	; 0x01
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2656:	80 93 e9 00 	sts	0x00E9, r24

	if ((ErrorCode = Endpoint_WaitUntilReady()) != ENDPOINT_READYWAIT_NoError)
    265a:	27 db       	rcall	.-2482   	; 0x1caa <Endpoint_WaitUntilReady>
    265c:	f8 2e       	mov	r15, r24
    265e:	88 23       	and	r24, r24
    2660:	e1 f5       	brne	.+120    	; 0x26da <RNDIS_Device_SendPacket+0xc4>
	  return ErrorCode;

	RNDIS_Packet_Message_t RNDISPacketHeader;

	memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));
    2662:	fe 01       	movw	r30, r28
    2664:	31 96       	adiw	r30, 0x01	; 1
    2666:	8c e2       	ldi	r24, 0x2C	; 44
    2668:	df 01       	movw	r26, r30
    266a:	1d 92       	st	X+, r1
    266c:	8a 95       	dec	r24
    266e:	e9 f7       	brne	.-6      	; 0x266a <RNDIS_Device_SendPacket+0x54>

	RNDISPacketHeader.MessageType   = REMOTE_NDIS_PACKET_MSG;
    2670:	81 e0       	ldi	r24, 0x01	; 1
    2672:	90 e0       	ldi	r25, 0x00	; 0
    2674:	a0 e0       	ldi	r26, 0x00	; 0
    2676:	b0 e0       	ldi	r27, 0x00	; 0
    2678:	89 83       	std	Y+1, r24	; 0x01
    267a:	9a 83       	std	Y+2, r25	; 0x02
    267c:	ab 83       	std	Y+3, r26	; 0x03
    267e:	bc 83       	std	Y+4, r27	; 0x04
	RNDISPacketHeader.MessageLength = (sizeof(RNDIS_Packet_Message_t) + PacketLength);
    2680:	04 5d       	subi	r16, 0xD4	; 212
    2682:	1f 4f       	sbci	r17, 0xFF	; 255
    2684:	c8 01       	movw	r24, r16
    2686:	a0 e0       	ldi	r26, 0x00	; 0
    2688:	b0 e0       	ldi	r27, 0x00	; 0
    268a:	0c 52       	subi	r16, 0x2C	; 44
    268c:	10 40       	sbci	r17, 0x00	; 0
    268e:	8d 83       	std	Y+5, r24	; 0x05
    2690:	9e 83       	std	Y+6, r25	; 0x06
    2692:	af 83       	std	Y+7, r26	; 0x07
    2694:	b8 87       	std	Y+8, r27	; 0x08
	RNDISPacketHeader.DataOffset    = (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
    2696:	84 e2       	ldi	r24, 0x24	; 36
    2698:	90 e0       	ldi	r25, 0x00	; 0
    269a:	a0 e0       	ldi	r26, 0x00	; 0
    269c:	b0 e0       	ldi	r27, 0x00	; 0
    269e:	89 87       	std	Y+9, r24	; 0x09
    26a0:	9a 87       	std	Y+10, r25	; 0x0a
    26a2:	ab 87       	std	Y+11, r26	; 0x0b
    26a4:	bc 87       	std	Y+12, r27	; 0x0c
	RNDISPacketHeader.DataLength    = PacketLength;
    26a6:	c8 01       	movw	r24, r16
    26a8:	a0 e0       	ldi	r26, 0x00	; 0
    26aa:	b0 e0       	ldi	r27, 0x00	; 0
    26ac:	8d 87       	std	Y+13, r24	; 0x0d
    26ae:	9e 87       	std	Y+14, r25	; 0x0e
    26b0:	af 87       	std	Y+15, r26	; 0x0f
    26b2:	b8 8b       	std	Y+16, r27	; 0x10

	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    26b4:	cf 01       	movw	r24, r30
    26b6:	6c e2       	ldi	r22, 0x2C	; 44
    26b8:	70 e0       	ldi	r23, 0x00	; 0
    26ba:	40 e0       	ldi	r20, 0x00	; 0
    26bc:	50 e0       	ldi	r21, 0x00	; 0
    26be:	2c df       	rcall	.-424    	; 0x2518 <Endpoint_Write_Stream_LE>
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
    26c0:	c6 01       	movw	r24, r12
    26c2:	b8 01       	movw	r22, r16
    26c4:	40 e0       	ldi	r20, 0x00	; 0
    26c6:	50 e0       	ldi	r21, 0x00	; 0
    26c8:	27 df       	rcall	.-434    	; 0x2518 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    26ca:	80 91 e8 00 	lds	r24, 0x00E8
    26ce:	8e 77       	andi	r24, 0x7E	; 126
    26d0:	80 93 e8 00 	sts	0x00E8, r24
    26d4:	02 c0       	rjmp	.+4      	; 0x26da <RNDIS_Device_SendPacket+0xc4>
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
    26d6:	32 e0       	ldi	r19, 0x02	; 2
    26d8:	f3 2e       	mov	r15, r19
}
    26da:	8f 2d       	mov	r24, r15
    26dc:	ac 96       	adiw	r28, 0x2c	; 44
    26de:	0f b6       	in	r0, 0x3f	; 63
    26e0:	f8 94       	cli
    26e2:	de bf       	out	0x3e, r29	; 62
    26e4:	0f be       	out	0x3f, r0	; 63
    26e6:	cd bf       	out	0x3d, r28	; 61
    26e8:	cf 91       	pop	r28
    26ea:	df 91       	pop	r29
    26ec:	1f 91       	pop	r17
    26ee:	0f 91       	pop	r16
    26f0:	ff 90       	pop	r15
    26f2:	df 90       	pop	r13
    26f4:	cf 90       	pop	r12
    26f6:	08 95       	ret

000026f8 <RNDIS_Device_USBTask>:

	return true;
}

void RNDIS_Device_USBTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    26f8:	0f 93       	push	r16
    26fa:	1f 93       	push	r17
    26fc:	df 93       	push	r29
    26fe:	cf 93       	push	r28
    2700:	cd b7       	in	r28, 0x3d	; 61
    2702:	de b7       	in	r29, 0x3e	; 62
    2704:	28 97       	sbiw	r28, 0x08	; 8
    2706:	0f b6       	in	r0, 0x3f	; 63
    2708:	f8 94       	cli
    270a:	de bf       	out	0x3e, r29	; 62
    270c:	0f be       	out	0x3f, r0	; 63
    270e:	cd bf       	out	0x3d, r28	; 61
    2710:	8c 01       	movw	r16, r24
	if (USB_DeviceState != DEVICE_STATE_Configured)
    2712:	80 91 00 14 	lds	r24, 0x1400
    2716:	84 30       	cpi	r24, 0x04	; 4
    2718:	49 f5       	brne	.+82     	; 0x276c <RNDIS_Device_USBTask+0x74>
	  return;

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.NotificationEndpointNumber);
    271a:	f8 01       	movw	r30, r16
    271c:	81 85       	ldd	r24, Z+9	; 0x09
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    271e:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2722:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsINReady() && RNDISInterfaceInfo->State.ResponseReady)
    2726:	80 ff       	sbrs	r24, 0
    2728:	21 c0       	rjmp	.+66     	; 0x276c <RNDIS_Device_USBTask+0x74>
    272a:	0b 56       	subi	r16, 0x6B	; 107
    272c:	1f 4f       	sbci	r17, 0xFF	; 255
    272e:	f8 01       	movw	r30, r16
    2730:	80 81       	ld	r24, Z
    2732:	05 59       	subi	r16, 0x95	; 149
    2734:	10 40       	sbci	r17, 0x00	; 0
    2736:	88 23       	and	r24, r24
    2738:	c9 f0       	breq	.+50     	; 0x276c <RNDIS_Device_USBTask+0x74>
				.bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
				.bRequest      = RNDIS_NOTIF_ResponseAvailable,
				.wValue        = 0,
				.wIndex        = 0,
				.wLength       = 0,
			};
    273a:	de 01       	movw	r26, r28
    273c:	11 96       	adiw	r26, 0x01	; 1
    273e:	ef ee       	ldi	r30, 0xEF	; 239
    2740:	f1 e0       	ldi	r31, 0x01	; 1
    2742:	88 e0       	ldi	r24, 0x08	; 8
    2744:	01 90       	ld	r0, Z+
    2746:	0d 92       	st	X+, r0
    2748:	81 50       	subi	r24, 0x01	; 1
    274a:	e1 f7       	brne	.-8      	; 0x2744 <RNDIS_Device_USBTask+0x4c>

		Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NULL);
    274c:	ce 01       	movw	r24, r28
    274e:	01 96       	adiw	r24, 0x01	; 1
    2750:	68 e0       	ldi	r22, 0x08	; 8
    2752:	70 e0       	ldi	r23, 0x00	; 0
    2754:	40 e0       	ldi	r20, 0x00	; 0
    2756:	50 e0       	ldi	r21, 0x00	; 0
    2758:	df de       	rcall	.-578    	; 0x2518 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    275a:	80 91 e8 00 	lds	r24, 0x00E8
    275e:	8e 77       	andi	r24, 0x7E	; 126
    2760:	80 93 e8 00 	sts	0x00E8, r24

		Endpoint_ClearIN();

		RNDISInterfaceInfo->State.ResponseReady = false;
    2764:	0b 56       	subi	r16, 0x6B	; 107
    2766:	1f 4f       	sbci	r17, 0xFF	; 255
    2768:	f8 01       	movw	r30, r16
    276a:	10 82       	st	Z, r1
	}
}
    276c:	28 96       	adiw	r28, 0x08	; 8
    276e:	0f b6       	in	r0, 0x3f	; 63
    2770:	f8 94       	cli
    2772:	de bf       	out	0x3e, r29	; 62
    2774:	0f be       	out	0x3f, r0	; 63
    2776:	cd bf       	out	0x3d, r28	; 61
    2778:	cf 91       	pop	r28
    277a:	df 91       	pop	r29
    277c:	1f 91       	pop	r17
    277e:	0f 91       	pop	r16
    2780:	08 95       	ret

00002782 <RNDIS_Device_ReadPacket>:
}

uint8_t RNDIS_Device_ReadPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                uint16_t* const PacketLength)
{
    2782:	ef 92       	push	r14
    2784:	ff 92       	push	r15
    2786:	0f 93       	push	r16
    2788:	1f 93       	push	r17
    278a:	df 93       	push	r29
    278c:	cf 93       	push	r28
    278e:	cd b7       	in	r28, 0x3d	; 61
    2790:	de b7       	in	r29, 0x3e	; 62
    2792:	ac 97       	sbiw	r28, 0x2c	; 44
    2794:	0f b6       	in	r0, 0x3f	; 63
    2796:	f8 94       	cli
    2798:	de bf       	out	0x3e, r29	; 62
    279a:	0f be       	out	0x3f, r0	; 63
    279c:	cd bf       	out	0x3d, r28	; 61
    279e:	fc 01       	movw	r30, r24
    27a0:	7b 01       	movw	r14, r22
    27a2:	8a 01       	movw	r16, r20
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    27a4:	80 91 00 14 	lds	r24, 0x1400
    27a8:	84 30       	cpi	r24, 0x04	; 4
    27aa:	d9 f5       	brne	.+118    	; 0x2822 <RNDIS_Device_ReadPacket+0xa0>
    27ac:	ea 56       	subi	r30, 0x6A	; 106
    27ae:	ff 4f       	sbci	r31, 0xFF	; 255
    27b0:	80 81       	ld	r24, Z
    27b2:	e6 59       	subi	r30, 0x96	; 150
    27b4:	f0 40       	sbci	r31, 0x00	; 0
    27b6:	82 30       	cpi	r24, 0x02	; 2
    27b8:	a1 f5       	brne	.+104    	; 0x2822 <RNDIS_Device_ReadPacket+0xa0>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}
	
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpointNumber);
    27ba:	85 81       	ldd	r24, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    27bc:	80 93 e9 00 	sts	0x00E9, r24
	
	*PacketLength = 0;
    27c0:	fa 01       	movw	r30, r20
    27c2:	11 82       	std	Z+1, r1	; 0x01
    27c4:	10 82       	st	Z, r1
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    27c6:	80 91 e8 00 	lds	r24, 0x00E8

	if (!(Endpoint_IsOUTReceived()))
    27ca:	82 ff       	sbrs	r24, 2
    27cc:	28 c0       	rjmp	.+80     	; 0x281e <RNDIS_Device_ReadPacket+0x9c>
		return ENDPOINT_RWSTREAM_NoError;

	RNDIS_Packet_Message_t RNDISPacketHeader;	
	Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    27ce:	ce 01       	movw	r24, r28
    27d0:	01 96       	adiw	r24, 0x01	; 1
    27d2:	6c e2       	ldi	r22, 0x2C	; 44
    27d4:	70 e0       	ldi	r23, 0x00	; 0
    27d6:	40 e0       	ldi	r20, 0x00	; 0
    27d8:	50 e0       	ldi	r21, 0x00	; 0
    27da:	4c de       	rcall	.-872    	; 0x2474 <Endpoint_Read_Stream_LE>

	if (RNDISPacketHeader.DataLength > ETHERNET_FRAME_SIZE_MAX)
    27dc:	8d 85       	ldd	r24, Y+13	; 0x0d
    27de:	9e 85       	ldd	r25, Y+14	; 0x0e
    27e0:	af 85       	ldd	r26, Y+15	; 0x0f
    27e2:	b8 89       	ldd	r27, Y+16	; 0x10
    27e4:	8d 3d       	cpi	r24, 0xDD	; 221
    27e6:	f5 e0       	ldi	r31, 0x05	; 5
    27e8:	9f 07       	cpc	r25, r31
    27ea:	f0 e0       	ldi	r31, 0x00	; 0
    27ec:	af 07       	cpc	r26, r31
    27ee:	f0 e0       	ldi	r31, 0x00	; 0
    27f0:	bf 07       	cpc	r27, r31
    27f2:	38 f0       	brcs	.+14     	; 0x2802 <RNDIS_Device_ReadPacket+0x80>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    27f4:	80 91 eb 00 	lds	r24, 0x00EB
    27f8:	80 62       	ori	r24, 0x20	; 32
    27fa:	80 93 eb 00 	sts	0x00EB, r24
    27fe:	80 e8       	ldi	r24, 0x80	; 128
    2800:	11 c0       	rjmp	.+34     	; 0x2824 <RNDIS_Device_ReadPacket+0xa2>
		Endpoint_StallTransaction();

		return RNDIS_ERROR_LOGICAL_CMD_FAILED;
	}
	
	*PacketLength = (uint16_t)RNDISPacketHeader.DataLength;
    2802:	f8 01       	movw	r30, r16
    2804:	91 83       	std	Z+1, r25	; 0x01
    2806:	80 83       	st	Z, r24

	Endpoint_Read_Stream_LE(Buffer, RNDISPacketHeader.DataLength, NULL);
    2808:	6d 85       	ldd	r22, Y+13	; 0x0d
    280a:	7e 85       	ldd	r23, Y+14	; 0x0e
    280c:	c7 01       	movw	r24, r14
    280e:	40 e0       	ldi	r20, 0x00	; 0
    2810:	50 e0       	ldi	r21, 0x00	; 0
    2812:	30 de       	rcall	.-928    	; 0x2474 <Endpoint_Read_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2814:	80 91 e8 00 	lds	r24, 0x00E8
    2818:	8b 77       	andi	r24, 0x7B	; 123
    281a:	80 93 e8 00 	sts	0x00E8, r24
    281e:	80 e0       	ldi	r24, 0x00	; 0
    2820:	01 c0       	rjmp	.+2      	; 0x2824 <RNDIS_Device_ReadPacket+0xa2>
	Endpoint_ClearOUT();
	
	return ENDPOINT_RWSTREAM_NoError;
    2822:	82 e0       	ldi	r24, 0x02	; 2
}
    2824:	ac 96       	adiw	r28, 0x2c	; 44
    2826:	0f b6       	in	r0, 0x3f	; 63
    2828:	f8 94       	cli
    282a:	de bf       	out	0x3e, r29	; 62
    282c:	0f be       	out	0x3f, r0	; 63
    282e:	cd bf       	out	0x3d, r28	; 61
    2830:	cf 91       	pop	r28
    2832:	df 91       	pop	r29
    2834:	1f 91       	pop	r17
    2836:	0f 91       	pop	r16
    2838:	ff 90       	pop	r15
    283a:	ef 90       	pop	r14
    283c:	08 95       	ret

0000283e <RNDIS_Device_ConfigureEndpoints>:
			break;
	}
}

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    283e:	1f 93       	push	r17
    2840:	cf 93       	push	r28
    2842:	df 93       	push	r29
    2844:	ec 01       	movw	r28, r24
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));
    2846:	45 96       	adiw	r24, 0x15	; 21
    2848:	fc 01       	movw	r30, r24
    284a:	86 e8       	ldi	r24, 0x86	; 134
    284c:	df 01       	movw	r26, r30
    284e:	1d 92       	st	X+, r1
    2850:	8a 95       	dec	r24
    2852:	e9 f7       	brne	.-6      	; 0x284e <RNDIS_Device_ConfigureEndpoints+0x10>
    2854:	11 e0       	ldi	r17, 0x01	; 1
		uint16_t Size;
		uint8_t  Type;
		uint8_t  Direction;
		bool     DoubleBanked;

		if (EndpointNum == RNDISInterfaceInfo->Config.DataINEndpointNumber)
    2856:	89 81       	ldd	r24, Y+1	; 0x01
    2858:	18 17       	cp	r17, r24
    285a:	29 f4       	brne	.+10     	; 0x2866 <RNDIS_Device_ConfigureEndpoints+0x28>
		{
			Size         = RNDISInterfaceInfo->Config.DataINEndpointSize;
    285c:	ea 81       	ldd	r30, Y+2	; 0x02
    285e:	fb 81       	ldd	r31, Y+3	; 0x03
			Direction    = ENDPOINT_DIR_IN;
			Type         = EP_TYPE_BULK;
			DoubleBanked = RNDISInterfaceInfo->Config.DataINEndpointDoubleBank;
    2860:	8c 81       	ldd	r24, Y+4	; 0x04
    2862:	62 e0       	ldi	r22, 0x02	; 2
    2864:	10 c0       	rjmp	.+32     	; 0x2886 <RNDIS_Device_ConfigureEndpoints+0x48>
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.DataOUTEndpointNumber)
    2866:	8d 81       	ldd	r24, Y+5	; 0x05
    2868:	18 17       	cp	r17, r24
    286a:	31 f4       	brne	.+12     	; 0x2878 <RNDIS_Device_ConfigureEndpoints+0x3a>
		{
			Size         = RNDISInterfaceInfo->Config.DataOUTEndpointSize;
    286c:	ee 81       	ldd	r30, Y+6	; 0x06
    286e:	ff 81       	ldd	r31, Y+7	; 0x07
			Direction    = ENDPOINT_DIR_OUT;
			Type         = EP_TYPE_BULK;
			DoubleBanked = RNDISInterfaceInfo->Config.DataOUTEndpointDoubleBank;
    2870:	88 85       	ldd	r24, Y+8	; 0x08
    2872:	62 e0       	ldi	r22, 0x02	; 2
    2874:	30 e0       	ldi	r19, 0x00	; 0
    2876:	08 c0       	rjmp	.+16     	; 0x2888 <RNDIS_Device_ConfigureEndpoints+0x4a>
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.NotificationEndpointNumber)
    2878:	89 85       	ldd	r24, Y+9	; 0x09
    287a:	18 17       	cp	r17, r24
    287c:	09 f5       	brne	.+66     	; 0x28c0 <RNDIS_Device_ConfigureEndpoints+0x82>
		{
			Size         = RNDISInterfaceInfo->Config.NotificationEndpointSize;
    287e:	ea 85       	ldd	r30, Y+10	; 0x0a
    2880:	fb 85       	ldd	r31, Y+11	; 0x0b
			Direction    = ENDPOINT_DIR_IN;
			Type         = EP_TYPE_INTERRUPT;
			DoubleBanked = RNDISInterfaceInfo->Config.NotificationEndpointDoubleBank;
    2882:	8c 85       	ldd	r24, Y+12	; 0x0c
    2884:	63 e0       	ldi	r22, 0x03	; 3
    2886:	31 e0       	ldi	r19, 0x01	; 1
		else
		{
			continue;
		}

		if (!(Endpoint_ConfigureEndpoint(EndpointNum, Type, Direction, Size,
    2888:	88 23       	and	r24, r24
    288a:	11 f4       	brne	.+4      	; 0x2890 <RNDIS_Device_ConfigureEndpoints+0x52>
    288c:	40 e0       	ldi	r20, 0x00	; 0
    288e:	01 c0       	rjmp	.+2      	; 0x2892 <RNDIS_Device_ConfigureEndpoints+0x54>
    2890:	44 e0       	ldi	r20, 0x04	; 4
    2892:	20 e0       	ldi	r18, 0x00	; 0
    2894:	88 e0       	ldi	r24, 0x08	; 8
    2896:	90 e0       	ldi	r25, 0x00	; 0
    2898:	03 c0       	rjmp	.+6      	; 0x28a0 <RNDIS_Device_ConfigureEndpoints+0x62>
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
				{
					MaskVal++;
    289a:	2f 5f       	subi	r18, 0xFF	; 255
					CheckBytes <<= 1;
    289c:	88 0f       	add	r24, r24
    289e:	99 1f       	adc	r25, r25
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    28a0:	8e 17       	cp	r24, r30
    28a2:	9f 07       	cpc	r25, r31
    28a4:	d0 f3       	brcs	.-12     	; 0x289a <RNDIS_Device_ConfigureEndpoints+0x5c>
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | Direction),
    28a6:	62 95       	swap	r22
    28a8:	66 0f       	add	r22, r22
    28aa:	66 0f       	add	r22, r22
    28ac:	60 7c       	andi	r22, 0xC0	; 192
    28ae:	63 2b       	or	r22, r19
    28b0:	42 60       	ori	r20, 0x02	; 2
    28b2:	22 95       	swap	r18
    28b4:	20 7f       	andi	r18, 0xF0	; 240
    28b6:	42 2b       	or	r20, r18
    28b8:	81 2f       	mov	r24, r17
    28ba:	a1 d9       	rcall	.-3262   	; 0x1bfe <Endpoint_ConfigureEndpoint_Prv>
    28bc:	88 23       	and	r24, r24
    28be:	21 f0       	breq	.+8      	; 0x28c8 <RNDIS_Device_ConfigureEndpoints+0x8a>

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));

	for (uint8_t EndpointNum = 1; EndpointNum < ENDPOINT_TOTAL_ENDPOINTS; EndpointNum++)
    28c0:	1f 5f       	subi	r17, 0xFF	; 255
    28c2:	17 30       	cpi	r17, 0x07	; 7
    28c4:	41 f6       	brne	.-112    	; 0x2856 <RNDIS_Device_ConfigureEndpoints+0x18>
    28c6:	81 e0       	ldi	r24, 0x01	; 1
			return false;
		}
	}

	return true;
}
    28c8:	df 91       	pop	r29
    28ca:	cf 91       	pop	r28
    28cc:	1f 91       	pop	r17
    28ce:	08 95       	ret

000028d0 <RNDIS_Device_ProcessControlRequest>:
		OID_802_3_XMIT_ONE_COLLISION,
		OID_802_3_XMIT_MORE_COLLISIONS,
	};

void RNDIS_Device_ProcessControlRequest(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    28d0:	ef 92       	push	r14
    28d2:	ff 92       	push	r15
    28d4:	0f 93       	push	r16
    28d6:	1f 93       	push	r17
    28d8:	cf 93       	push	r28
    28da:	df 93       	push	r29
    28dc:	ec 01       	movw	r28, r24
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    28de:	80 91 e8 00 	lds	r24, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
    28e2:	83 ff       	sbrs	r24, 3
    28e4:	b9 c2       	rjmp	.+1394   	; 0x2e58 <RNDIS_Device_ProcessControlRequest+0x588>
	  return;

	if (USB_ControlRequest.wIndex != RNDISInterfaceInfo->Config.ControlInterfaceNumber)
    28e6:	88 81       	ld	r24, Y
    28e8:	90 e0       	ldi	r25, 0x00	; 0
    28ea:	20 91 05 14 	lds	r18, 0x1405
    28ee:	30 91 06 14 	lds	r19, 0x1406
    28f2:	28 17       	cp	r18, r24
    28f4:	39 07       	cpc	r19, r25
    28f6:	09 f0       	breq	.+2      	; 0x28fa <RNDIS_Device_ProcessControlRequest+0x2a>
    28f8:	af c2       	rjmp	.+1374   	; 0x2e58 <RNDIS_Device_ProcessControlRequest+0x588>
	  return;

	switch (USB_ControlRequest.bRequest)
    28fa:	80 91 02 14 	lds	r24, 0x1402
    28fe:	88 23       	and	r24, r24
    2900:	21 f0       	breq	.+8      	; 0x290a <RNDIS_Device_ProcessControlRequest+0x3a>
    2902:	81 30       	cpi	r24, 0x01	; 1
    2904:	09 f0       	breq	.+2      	; 0x2908 <RNDIS_Device_ProcessControlRequest+0x38>
    2906:	a8 c2       	rjmp	.+1360   	; 0x2e58 <RNDIS_Device_ProcessControlRequest+0x588>
    2908:	57 c2       	rjmp	.+1198   	; 0x2db8 <RNDIS_Device_ProcessControlRequest+0x4e8>
	{
		case RNDIS_REQ_SendEncapsulatedCommand:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    290a:	80 91 01 14 	lds	r24, 0x1401
    290e:	81 32       	cpi	r24, 0x21	; 33
    2910:	09 f0       	breq	.+2      	; 0x2914 <RNDIS_Device_ProcessControlRequest+0x44>
    2912:	a2 c2       	rjmp	.+1348   	; 0x2e58 <RNDIS_Device_ProcessControlRequest+0x588>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2914:	80 91 e8 00 	lds	r24, 0x00E8
    2918:	87 7f       	andi	r24, 0xF7	; 247
    291a:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, USB_ControlRequest.wLength);
    291e:	8e 01       	movw	r16, r28
    2920:	0b 5e       	subi	r16, 0xEB	; 235
    2922:	1f 4f       	sbci	r17, 0xFF	; 255
    2924:	60 91 07 14 	lds	r22, 0x1407
    2928:	70 91 08 14 	lds	r23, 0x1408
    292c:	c8 01       	movw	r24, r16
    292e:	00 dd       	rcall	.-1536   	; 0x2330 <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2930:	80 91 e8 00 	lds	r24, 0x00E8
    2934:	8e 77       	andi	r24, 0x7E	; 126
    2936:	80 93 e8 00 	sts	0x00E8, r24
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

	switch (MessageHeader->MessageType)
    293a:	8d 89       	ldd	r24, Y+21	; 0x15
    293c:	9e 89       	ldd	r25, Y+22	; 0x16
    293e:	af 89       	ldd	r26, Y+23	; 0x17
    2940:	b8 8d       	ldd	r27, Y+24	; 0x18
    2942:	84 30       	cpi	r24, 0x04	; 4
    2944:	91 05       	cpc	r25, r1
    2946:	a1 05       	cpc	r26, r1
    2948:	b1 05       	cpc	r27, r1
    294a:	09 f4       	brne	.+2      	; 0x294e <RNDIS_Device_ProcessControlRequest+0x7e>
    294c:	77 c0       	rjmp	.+238    	; 0x2a3c <RNDIS_Device_ProcessControlRequest+0x16c>
    294e:	85 30       	cpi	r24, 0x05	; 5
    2950:	91 05       	cpc	r25, r1
    2952:	a1 05       	cpc	r26, r1
    2954:	b1 05       	cpc	r27, r1
    2956:	58 f4       	brcc	.+22     	; 0x296e <RNDIS_Device_ProcessControlRequest+0x9e>
    2958:	82 30       	cpi	r24, 0x02	; 2
    295a:	91 05       	cpc	r25, r1
    295c:	a1 05       	cpc	r26, r1
    295e:	b1 05       	cpc	r27, r1
    2960:	c1 f0       	breq	.+48     	; 0x2992 <RNDIS_Device_ProcessControlRequest+0xc2>
    2962:	03 97       	sbiw	r24, 0x03	; 3
    2964:	a1 05       	cpc	r26, r1
    2966:	b1 05       	cpc	r27, r1
    2968:	09 f0       	breq	.+2      	; 0x296c <RNDIS_Device_ProcessControlRequest+0x9c>
    296a:	76 c2       	rjmp	.+1260   	; 0x2e58 <RNDIS_Device_ProcessControlRequest+0x588>
    296c:	5d c0       	rjmp	.+186    	; 0x2a28 <RNDIS_Device_ProcessControlRequest+0x158>
    296e:	86 30       	cpi	r24, 0x06	; 6
    2970:	91 05       	cpc	r25, r1
    2972:	a1 05       	cpc	r26, r1
    2974:	b1 05       	cpc	r27, r1
    2976:	09 f4       	brne	.+2      	; 0x297a <RNDIS_Device_ProcessControlRequest+0xaa>
    2978:	e7 c1       	rjmp	.+974    	; 0x2d48 <RNDIS_Device_ProcessControlRequest+0x478>
    297a:	86 30       	cpi	r24, 0x06	; 6
    297c:	91 05       	cpc	r25, r1
    297e:	a1 05       	cpc	r26, r1
    2980:	b1 05       	cpc	r27, r1
    2982:	08 f4       	brcc	.+2      	; 0x2986 <RNDIS_Device_ProcessControlRequest+0xb6>
    2984:	96 c1       	rjmp	.+812    	; 0x2cb2 <RNDIS_Device_ProcessControlRequest+0x3e2>
    2986:	08 97       	sbiw	r24, 0x08	; 8
    2988:	a1 05       	cpc	r26, r1
    298a:	b1 05       	cpc	r27, r1
    298c:	09 f0       	breq	.+2      	; 0x2990 <RNDIS_Device_ProcessControlRequest+0xc0>
    298e:	64 c2       	rjmp	.+1224   	; 0x2e58 <RNDIS_Device_ProcessControlRequest+0x588>
    2990:	f7 c1       	rjmp	.+1006   	; 0x2d80 <RNDIS_Device_ProcessControlRequest+0x4b0>
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			RNDISInterfaceInfo->State.ResponseReady = true;
    2992:	cb 56       	subi	r28, 0x6B	; 107
    2994:	df 4f       	sbci	r29, 0xFF	; 255
    2996:	21 e0       	ldi	r18, 0x01	; 1
    2998:	28 83       	st	Y, r18
    299a:	c5 59       	subi	r28, 0x95	; 149
    299c:	d0 40       	sbci	r29, 0x00	; 0
			RNDIS_Initialize_Message_t*  INITIALIZE_Message  =
			               (RNDIS_Initialize_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response =
			               (RNDIS_Initialize_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			INITIALIZE_Response->MessageType           = REMOTE_NDIS_INITIALIZE_CMPLT;
    299e:	82 e0       	ldi	r24, 0x02	; 2
    29a0:	90 e0       	ldi	r25, 0x00	; 0
    29a2:	a0 e0       	ldi	r26, 0x00	; 0
    29a4:	b0 e8       	ldi	r27, 0x80	; 128
    29a6:	8d 8b       	std	Y+21, r24	; 0x15
    29a8:	9e 8b       	std	Y+22, r25	; 0x16
    29aa:	af 8b       	std	Y+23, r26	; 0x17
    29ac:	b8 8f       	std	Y+24, r27	; 0x18
			INITIALIZE_Response->MessageLength         = sizeof(RNDIS_Initialize_Complete_t);
    29ae:	84 e3       	ldi	r24, 0x34	; 52
    29b0:	90 e0       	ldi	r25, 0x00	; 0
    29b2:	a0 e0       	ldi	r26, 0x00	; 0
    29b4:	b0 e0       	ldi	r27, 0x00	; 0
    29b6:	f8 01       	movw	r30, r16
    29b8:	84 83       	std	Z+4, r24	; 0x04
    29ba:	95 83       	std	Z+5, r25	; 0x05
    29bc:	a6 83       	std	Z+6, r26	; 0x06
    29be:	b7 83       	std	Z+7, r27	; 0x07
			INITIALIZE_Response->RequestId             = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                = REMOTE_NDIS_STATUS_SUCCESS;
    29c0:	14 86       	std	Z+12, r1	; 0x0c
    29c2:	15 86       	std	Z+13, r1	; 0x0d
    29c4:	16 86       	std	Z+14, r1	; 0x0e
    29c6:	17 86       	std	Z+15, r1	; 0x0f

			INITIALIZE_Response->MajorVersion          = REMOTE_NDIS_VERSION_MAJOR;
    29c8:	81 e0       	ldi	r24, 0x01	; 1
    29ca:	90 e0       	ldi	r25, 0x00	; 0
    29cc:	a0 e0       	ldi	r26, 0x00	; 0
    29ce:	b0 e0       	ldi	r27, 0x00	; 0
    29d0:	80 8b       	std	Z+16, r24	; 0x10
    29d2:	91 8b       	std	Z+17, r25	; 0x11
    29d4:	a2 8b       	std	Z+18, r26	; 0x12
    29d6:	b3 8b       	std	Z+19, r27	; 0x13
			INITIALIZE_Response->MinorVersion          = REMOTE_NDIS_VERSION_MINOR;
    29d8:	14 8a       	std	Z+20, r1	; 0x14
    29da:	15 8a       	std	Z+21, r1	; 0x15
    29dc:	16 8a       	std	Z+22, r1	; 0x16
    29de:	17 8a       	std	Z+23, r1	; 0x17
			INITIALIZE_Response->DeviceFlags           = REMOTE_NDIS_DF_CONNECTIONLESS;
    29e0:	80 8f       	std	Z+24, r24	; 0x18
    29e2:	91 8f       	std	Z+25, r25	; 0x19
    29e4:	a2 8f       	std	Z+26, r26	; 0x1a
    29e6:	b3 8f       	std	Z+27, r27	; 0x1b
			INITIALIZE_Response->Medium                = REMOTE_NDIS_MEDIUM_802_3;
    29e8:	14 8e       	std	Z+28, r1	; 0x1c
    29ea:	15 8e       	std	Z+29, r1	; 0x1d
    29ec:	16 8e       	std	Z+30, r1	; 0x1e
    29ee:	17 8e       	std	Z+31, r1	; 0x1f
			INITIALIZE_Response->MaxPacketsPerTransfer = 1;
    29f0:	80 a3       	std	Z+32, r24	; 0x20
    29f2:	91 a3       	std	Z+33, r25	; 0x21
    29f4:	a2 a3       	std	Z+34, r26	; 0x22
    29f6:	b3 a3       	std	Z+35, r27	; 0x23
			INITIALIZE_Response->MaxTransferSize       = (sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
    29f8:	88 e0       	ldi	r24, 0x08	; 8
    29fa:	96 e0       	ldi	r25, 0x06	; 6
    29fc:	a0 e0       	ldi	r26, 0x00	; 0
    29fe:	b0 e0       	ldi	r27, 0x00	; 0
    2a00:	84 a3       	std	Z+36, r24	; 0x24
    2a02:	95 a3       	std	Z+37, r25	; 0x25
    2a04:	a6 a3       	std	Z+38, r26	; 0x26
    2a06:	b7 a3       	std	Z+39, r27	; 0x27
			INITIALIZE_Response->PacketAlignmentFactor = 0;
    2a08:	10 a6       	std	Z+40, r1	; 0x28
    2a0a:	11 a6       	std	Z+41, r1	; 0x29
    2a0c:	12 a6       	std	Z+42, r1	; 0x2a
    2a0e:	13 a6       	std	Z+43, r1	; 0x2b
			INITIALIZE_Response->AFListOffset          = 0;
    2a10:	14 a6       	std	Z+44, r1	; 0x2c
    2a12:	15 a6       	std	Z+45, r1	; 0x2d
    2a14:	16 a6       	std	Z+46, r1	; 0x2e
    2a16:	17 a6       	std	Z+47, r1	; 0x2f
			INITIALIZE_Response->AFListSize            = 0;
    2a18:	10 aa       	std	Z+48, r1	; 0x30
    2a1a:	11 aa       	std	Z+49, r1	; 0x31
    2a1c:	12 aa       	std	Z+50, r1	; 0x32
    2a1e:	13 aa       	std	Z+51, r1	; 0x33

			RNDISInterfaceInfo->State.CurrRNDISState = RNDIS_Initialized;
    2a20:	ca 56       	subi	r28, 0x6A	; 106
    2a22:	df 4f       	sbci	r29, 0xFF	; 255
    2a24:	28 83       	st	Y, r18
    2a26:	18 c2       	rjmp	.+1072   	; 0x2e58 <RNDIS_Device_ProcessControlRequest+0x588>

			break;
		case REMOTE_NDIS_HALT_MSG:
			RNDISInterfaceInfo->State.ResponseReady = false;
    2a28:	cb 56       	subi	r28, 0x6B	; 107
    2a2a:	df 4f       	sbci	r29, 0xFF	; 255
    2a2c:	19 92       	st	Y+, r1
			MessageHeader->MessageLength = 0;
    2a2e:	f8 01       	movw	r30, r16
    2a30:	14 82       	std	Z+4, r1	; 0x04
    2a32:	15 82       	std	Z+5, r1	; 0x05
    2a34:	16 82       	std	Z+6, r1	; 0x06
    2a36:	17 82       	std	Z+7, r1	; 0x07

			RNDISInterfaceInfo->State.CurrRNDISState = RNDIS_Uninitialized;
    2a38:	18 82       	st	Y, r1
    2a3a:	0e c2       	rjmp	.+1052   	; 0x2e58 <RNDIS_Device_ProcessControlRequest+0x588>

			break;
		case REMOTE_NDIS_QUERY_MSG:
			RNDISInterfaceInfo->State.ResponseReady = true;
    2a3c:	cb 56       	subi	r28, 0x6B	; 107
    2a3e:	df 4f       	sbci	r29, 0xFF	; 255
    2a40:	81 e0       	ldi	r24, 0x01	; 1
    2a42:	88 83       	st	Y, r24
    2a44:	c5 59       	subi	r28, 0x95	; 149
    2a46:	d0 40       	sbci	r29, 0x00	; 0

			RNDIS_Query_Message_t*  QUERY_Message  = (RNDIS_Query_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response = (RNDIS_Query_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t                Query_Oid      = QUERY_Message->Oid;
    2a48:	f8 01       	movw	r30, r16
    2a4a:	24 85       	ldd	r18, Z+12	; 0x0c
    2a4c:	35 85       	ldd	r19, Z+13	; 0x0d
    2a4e:	46 85       	ldd	r20, Z+14	; 0x0e
    2a50:	57 85       	ldd	r21, Z+15	; 0x0f

			void*     QueryData    = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                                       QUERY_Message->InformationBufferOffset];
			void*     ResponseData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Query_Complete_t)];
    2a52:	6d e2       	ldi	r22, 0x2D	; 45
    2a54:	e6 2e       	mov	r14, r22
    2a56:	f1 2c       	mov	r15, r1
    2a58:	ec 0e       	add	r14, r28
    2a5a:	fd 1e       	adc	r15, r29
			uint16_t  ResponseSize;

			QUERY_Response->MessageType   = REMOTE_NDIS_QUERY_CMPLT;
    2a5c:	84 e0       	ldi	r24, 0x04	; 4
    2a5e:	90 e0       	ldi	r25, 0x00	; 0
    2a60:	a0 e0       	ldi	r26, 0x00	; 0
    2a62:	b0 e8       	ldi	r27, 0x80	; 128
    2a64:	8d 8b       	std	Y+21, r24	; 0x15
    2a66:	9e 8b       	std	Y+22, r25	; 0x16
    2a68:	af 8b       	std	Y+23, r26	; 0x17
    2a6a:	b8 8f       	std	Y+24, r27	; 0x18
			QUERY_Response->MessageLength = sizeof(RNDIS_Query_Complete_t);
    2a6c:	88 e1       	ldi	r24, 0x18	; 24
    2a6e:	90 e0       	ldi	r25, 0x00	; 0
    2a70:	a0 e0       	ldi	r26, 0x00	; 0
    2a72:	b0 e0       	ldi	r27, 0x00	; 0
    2a74:	84 83       	std	Z+4, r24	; 0x04
    2a76:	95 83       	std	Z+5, r25	; 0x05
    2a78:	a6 83       	std	Z+6, r26	; 0x06
    2a7a:	b7 83       	std	Z+7, r27	; 0x07
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    2a7c:	2e 30       	cpi	r18, 0x0E	; 14
    2a7e:	f1 e0       	ldi	r31, 0x01	; 1
    2a80:	3f 07       	cpc	r19, r31
    2a82:	f1 e0       	ldi	r31, 0x01	; 1
    2a84:	4f 07       	cpc	r20, r31
    2a86:	f0 e0       	ldi	r31, 0x00	; 0
    2a88:	5f 07       	cpc	r21, r31
    2a8a:	09 f4       	brne	.+2      	; 0x2a8e <RNDIS_Device_ProcessControlRequest+0x1be>
    2a8c:	e7 c0       	rjmp	.+462    	; 0x2c5c <RNDIS_Device_ProcessControlRequest+0x38c>
    2a8e:	2f 30       	cpi	r18, 0x0F	; 15
    2a90:	61 e0       	ldi	r22, 0x01	; 1
    2a92:	36 07       	cpc	r19, r22
    2a94:	61 e0       	ldi	r22, 0x01	; 1
    2a96:	46 07       	cpc	r20, r22
    2a98:	60 e0       	ldi	r22, 0x00	; 0
    2a9a:	56 07       	cpc	r21, r22
    2a9c:	08 f0       	brcs	.+2      	; 0x2aa0 <RNDIS_Device_ProcessControlRequest+0x1d0>
    2a9e:	58 c0       	rjmp	.+176    	; 0x2b50 <RNDIS_Device_ProcessControlRequest+0x280>
    2aa0:	26 30       	cpi	r18, 0x06	; 6
    2aa2:	81 e0       	ldi	r24, 0x01	; 1
    2aa4:	38 07       	cpc	r19, r24
    2aa6:	81 e0       	ldi	r24, 0x01	; 1
    2aa8:	48 07       	cpc	r20, r24
    2aaa:	80 e0       	ldi	r24, 0x00	; 0
    2aac:	58 07       	cpc	r21, r24
    2aae:	09 f4       	brne	.+2      	; 0x2ab2 <RNDIS_Device_ProcessControlRequest+0x1e2>
    2ab0:	ae c0       	rjmp	.+348    	; 0x2c0e <RNDIS_Device_ProcessControlRequest+0x33e>
    2ab2:	27 30       	cpi	r18, 0x07	; 7
    2ab4:	e1 e0       	ldi	r30, 0x01	; 1
    2ab6:	3e 07       	cpc	r19, r30
    2ab8:	e1 e0       	ldi	r30, 0x01	; 1
    2aba:	4e 07       	cpc	r20, r30
    2abc:	e0 e0       	ldi	r30, 0x00	; 0
    2abe:	5e 07       	cpc	r21, r30
    2ac0:	f8 f4       	brcc	.+62     	; 0x2b00 <RNDIS_Device_ProcessControlRequest+0x230>
    2ac2:	22 30       	cpi	r18, 0x02	; 2
    2ac4:	f1 e0       	ldi	r31, 0x01	; 1
    2ac6:	3f 07       	cpc	r19, r31
    2ac8:	f1 e0       	ldi	r31, 0x01	; 1
    2aca:	4f 07       	cpc	r20, r31
    2acc:	f0 e0       	ldi	r31, 0x00	; 0
    2ace:	5f 07       	cpc	r21, r31
    2ad0:	09 f4       	brne	.+2      	; 0x2ad4 <RNDIS_Device_ProcessControlRequest+0x204>
    2ad2:	cd c0       	rjmp	.+410    	; 0x2c6e <RNDIS_Device_ProcessControlRequest+0x39e>
    2ad4:	23 30       	cpi	r18, 0x03	; 3
    2ad6:	61 e0       	ldi	r22, 0x01	; 1
    2ad8:	36 07       	cpc	r19, r22
    2ada:	61 e0       	ldi	r22, 0x01	; 1
    2adc:	46 07       	cpc	r20, r22
    2ade:	60 e0       	ldi	r22, 0x00	; 0
    2ae0:	56 07       	cpc	r21, r22
    2ae2:	38 f4       	brcc	.+14     	; 0x2af2 <RNDIS_Device_ProcessControlRequest+0x222>
    2ae4:	21 50       	subi	r18, 0x01	; 1
    2ae6:	31 40       	sbci	r19, 0x01	; 1
    2ae8:	41 40       	sbci	r20, 0x01	; 1
    2aea:	50 40       	sbci	r21, 0x00	; 0
    2aec:	09 f0       	breq	.+2      	; 0x2af0 <RNDIS_Device_ProcessControlRequest+0x220>
    2aee:	cf c0       	rjmp	.+414    	; 0x2c8e <RNDIS_Device_ProcessControlRequest+0x3be>
    2af0:	80 c0       	rjmp	.+256    	; 0x2bf2 <RNDIS_Device_ProcessControlRequest+0x322>
    2af2:	25 50       	subi	r18, 0x05	; 5
    2af4:	31 40       	sbci	r19, 0x01	; 1
    2af6:	41 40       	sbci	r20, 0x01	; 1
    2af8:	50 40       	sbci	r21, 0x00	; 0
    2afa:	08 f0       	brcs	.+2      	; 0x2afe <RNDIS_Device_ProcessControlRequest+0x22e>
    2afc:	c8 c0       	rjmp	.+400    	; 0x2c8e <RNDIS_Device_ProcessControlRequest+0x3be>
    2afe:	b7 c0       	rjmp	.+366    	; 0x2c6e <RNDIS_Device_ProcessControlRequest+0x39e>
    2b00:	2c 30       	cpi	r18, 0x0C	; 12
    2b02:	f1 e0       	ldi	r31, 0x01	; 1
    2b04:	3f 07       	cpc	r19, r31
    2b06:	f1 e0       	ldi	r31, 0x01	; 1
    2b08:	4f 07       	cpc	r20, r31
    2b0a:	f0 e0       	ldi	r31, 0x00	; 0
    2b0c:	5f 07       	cpc	r21, r31
    2b0e:	80 f4       	brcc	.+32     	; 0x2b30 <RNDIS_Device_ProcessControlRequest+0x260>
    2b10:	2a 30       	cpi	r18, 0x0A	; 10
    2b12:	61 e0       	ldi	r22, 0x01	; 1
    2b14:	36 07       	cpc	r19, r22
    2b16:	61 e0       	ldi	r22, 0x01	; 1
    2b18:	46 07       	cpc	r20, r22
    2b1a:	60 e0       	ldi	r22, 0x00	; 0
    2b1c:	56 07       	cpc	r21, r22
    2b1e:	08 f0       	brcs	.+2      	; 0x2b22 <RNDIS_Device_ProcessControlRequest+0x252>
    2b20:	76 c0       	rjmp	.+236    	; 0x2c0e <RNDIS_Device_ProcessControlRequest+0x33e>
    2b22:	27 50       	subi	r18, 0x07	; 7
    2b24:	31 40       	sbci	r19, 0x01	; 1
    2b26:	41 40       	sbci	r20, 0x01	; 1
    2b28:	50 40       	sbci	r21, 0x00	; 0
    2b2a:	09 f0       	breq	.+2      	; 0x2b2e <RNDIS_Device_ProcessControlRequest+0x25e>
    2b2c:	b0 c0       	rjmp	.+352    	; 0x2c8e <RNDIS_Device_ProcessControlRequest+0x3be>
    2b2e:	81 c0       	rjmp	.+258    	; 0x2c32 <RNDIS_Device_ProcessControlRequest+0x362>
    2b30:	2c 30       	cpi	r18, 0x0C	; 12
    2b32:	e1 e0       	ldi	r30, 0x01	; 1
    2b34:	3e 07       	cpc	r19, r30
    2b36:	e1 e0       	ldi	r30, 0x01	; 1
    2b38:	4e 07       	cpc	r20, r30
    2b3a:	e0 e0       	ldi	r30, 0x00	; 0
    2b3c:	5e 07       	cpc	r21, r30
    2b3e:	09 f4       	brne	.+2      	; 0x2b42 <RNDIS_Device_ProcessControlRequest+0x272>
    2b40:	61 c0       	rjmp	.+194    	; 0x2c04 <RNDIS_Device_ProcessControlRequest+0x334>
    2b42:	2d 50       	subi	r18, 0x0D	; 13
    2b44:	31 40       	sbci	r19, 0x01	; 1
    2b46:	41 40       	sbci	r20, 0x01	; 1
    2b48:	50 40       	sbci	r21, 0x00	; 0
    2b4a:	09 f0       	breq	.+2      	; 0x2b4e <RNDIS_Device_ProcessControlRequest+0x27e>
    2b4c:	a0 c0       	rjmp	.+320    	; 0x2c8e <RNDIS_Device_ProcessControlRequest+0x3be>
    2b4e:	64 c0       	rjmp	.+200    	; 0x2c18 <RNDIS_Device_ProcessControlRequest+0x348>
    2b50:	26 30       	cpi	r18, 0x06	; 6
    2b52:	61 e0       	ldi	r22, 0x01	; 1
    2b54:	36 07       	cpc	r19, r22
    2b56:	62 e0       	ldi	r22, 0x02	; 2
    2b58:	46 07       	cpc	r20, r22
    2b5a:	60 e0       	ldi	r22, 0x00	; 0
    2b5c:	56 07       	cpc	r21, r22
    2b5e:	10 f5       	brcc	.+68     	; 0x2ba4 <RNDIS_Device_ProcessControlRequest+0x2d4>
    2b60:	21 30       	cpi	r18, 0x01	; 1
    2b62:	81 e0       	ldi	r24, 0x01	; 1
    2b64:	38 07       	cpc	r19, r24
    2b66:	82 e0       	ldi	r24, 0x02	; 2
    2b68:	48 07       	cpc	r20, r24
    2b6a:	80 e0       	ldi	r24, 0x00	; 0
    2b6c:	58 07       	cpc	r21, r24
    2b6e:	08 f0       	brcs	.+2      	; 0x2b72 <RNDIS_Device_ProcessControlRequest+0x2a2>
    2b70:	7e c0       	rjmp	.+252    	; 0x2c6e <RNDIS_Device_ProcessControlRequest+0x39e>
    2b72:	24 31       	cpi	r18, 0x14	; 20
    2b74:	e1 e0       	ldi	r30, 0x01	; 1
    2b76:	3e 07       	cpc	r19, r30
    2b78:	e1 e0       	ldi	r30, 0x01	; 1
    2b7a:	4e 07       	cpc	r20, r30
    2b7c:	e0 e0       	ldi	r30, 0x00	; 0
    2b7e:	5e 07       	cpc	r21, r30
    2b80:	09 f4       	brne	.+2      	; 0x2b84 <RNDIS_Device_ProcessControlRequest+0x2b4>
    2b82:	75 c0       	rjmp	.+234    	; 0x2c6e <RNDIS_Device_ProcessControlRequest+0x39e>
    2b84:	22 30       	cpi	r18, 0x02	; 2
    2b86:	f2 e0       	ldi	r31, 0x02	; 2
    2b88:	3f 07       	cpc	r19, r31
    2b8a:	f1 e0       	ldi	r31, 0x01	; 1
    2b8c:	4f 07       	cpc	r20, r31
    2b8e:	f0 e0       	ldi	r31, 0x00	; 0
    2b90:	5f 07       	cpc	r21, r31
    2b92:	09 f4       	brne	.+2      	; 0x2b96 <RNDIS_Device_ProcessControlRequest+0x2c6>
    2b94:	6c c0       	rjmp	.+216    	; 0x2c6e <RNDIS_Device_ProcessControlRequest+0x39e>
    2b96:	21 51       	subi	r18, 0x11	; 17
    2b98:	31 40       	sbci	r19, 0x01	; 1
    2b9a:	41 40       	sbci	r20, 0x01	; 1
    2b9c:	50 40       	sbci	r21, 0x00	; 0
    2b9e:	09 f0       	breq	.+2      	; 0x2ba2 <RNDIS_Device_ProcessControlRequest+0x2d2>
    2ba0:	76 c0       	rjmp	.+236    	; 0x2c8e <RNDIS_Device_ProcessControlRequest+0x3be>
    2ba2:	6a c0       	rjmp	.+212    	; 0x2c78 <RNDIS_Device_ProcessControlRequest+0x3a8>
    2ba4:	24 30       	cpi	r18, 0x04	; 4
    2ba6:	81 e0       	ldi	r24, 0x01	; 1
    2ba8:	38 07       	cpc	r19, r24
    2baa:	81 e0       	ldi	r24, 0x01	; 1
    2bac:	48 07       	cpc	r20, r24
    2bae:	81 e0       	ldi	r24, 0x01	; 1
    2bb0:	58 07       	cpc	r21, r24
    2bb2:	09 f4       	brne	.+2      	; 0x2bb6 <RNDIS_Device_ProcessControlRequest+0x2e6>
    2bb4:	4e c0       	rjmp	.+156    	; 0x2c52 <RNDIS_Device_ProcessControlRequest+0x382>
    2bb6:	25 30       	cpi	r18, 0x05	; 5
    2bb8:	e1 e0       	ldi	r30, 0x01	; 1
    2bba:	3e 07       	cpc	r19, r30
    2bbc:	e1 e0       	ldi	r30, 0x01	; 1
    2bbe:	4e 07       	cpc	r20, r30
    2bc0:	e1 e0       	ldi	r30, 0x01	; 1
    2bc2:	5e 07       	cpc	r21, r30
    2bc4:	58 f4       	brcc	.+22     	; 0x2bdc <RNDIS_Device_ProcessControlRequest+0x30c>
    2bc6:	21 50       	subi	r18, 0x01	; 1
    2bc8:	31 40       	sbci	r19, 0x01	; 1
    2bca:	41 40       	sbci	r20, 0x01	; 1
    2bcc:	51 40       	sbci	r21, 0x01	; 1
    2bce:	22 30       	cpi	r18, 0x02	; 2
    2bd0:	31 05       	cpc	r19, r1
    2bd2:	41 05       	cpc	r20, r1
    2bd4:	51 05       	cpc	r21, r1
    2bd6:	08 f0       	brcs	.+2      	; 0x2bda <RNDIS_Device_ProcessControlRequest+0x30a>
    2bd8:	5a c0       	rjmp	.+180    	; 0x2c8e <RNDIS_Device_ProcessControlRequest+0x3be>
    2bda:	30 c0       	rjmp	.+96     	; 0x2c3c <RNDIS_Device_ProcessControlRequest+0x36c>
    2bdc:	21 50       	subi	r18, 0x01	; 1
    2bde:	31 40       	sbci	r19, 0x01	; 1
    2be0:	42 40       	sbci	r20, 0x02	; 2
    2be2:	51 40       	sbci	r21, 0x01	; 1
    2be4:	23 30       	cpi	r18, 0x03	; 3
    2be6:	31 05       	cpc	r19, r1
    2be8:	41 05       	cpc	r20, r1
    2bea:	51 05       	cpc	r21, r1
    2bec:	08 f0       	brcs	.+2      	; 0x2bf0 <RNDIS_Device_ProcessControlRequest+0x320>
    2bee:	4f c0       	rjmp	.+158    	; 0x2c8e <RNDIS_Device_ProcessControlRequest+0x3be>
    2bf0:	3e c0       	rjmp	.+124    	; 0x2c6e <RNDIS_Device_ProcessControlRequest+0x39e>
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);

			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
    2bf2:	c7 01       	movw	r24, r14
    2bf4:	66 eb       	ldi	r22, 0xB6	; 182
    2bf6:	73 e0       	ldi	r23, 0x03	; 3
    2bf8:	4c e6       	ldi	r20, 0x6C	; 108
    2bfa:	50 e0       	ldi	r21, 0x00	; 0
    2bfc:	52 d1       	rcall	.+676    	; 0x2ea2 <memcpy_P>
    2bfe:	cc e6       	ldi	r28, 0x6C	; 108
    2c00:	d0 e0       	ldi	r29, 0x00	; 0
    2c02:	0a c1       	rjmp	.+532    	; 0x2e18 <RNDIS_Device_ProcessControlRequest+0x548>
			return true;
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = 0x00FFFFFF;
    2c04:	8f ef       	ldi	r24, 0xFF	; 255
    2c06:	9f ef       	ldi	r25, 0xFF	; 255
    2c08:	af ef       	ldi	r26, 0xFF	; 255
    2c0a:	b0 e0       	ldi	r27, 0x00	; 0
    2c0c:	39 c0       	rjmp	.+114    	; 0x2c80 <RNDIS_Device_ProcessControlRequest+0x3b0>
		case OID_GEN_MAXIMUM_FRAME_SIZE:
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = ETHERNET_FRAME_SIZE_MAX;
    2c0e:	8c ed       	ldi	r24, 0xDC	; 220
    2c10:	95 e0       	ldi	r25, 0x05	; 5
    2c12:	a0 e0       	ldi	r26, 0x00	; 0
    2c14:	b0 e0       	ldi	r27, 0x00	; 0
    2c16:	34 c0       	rjmp	.+104    	; 0x2c80 <RNDIS_Device_ProcessControlRequest+0x3b0>

			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = (strlen(RNDISInterfaceInfo->Config.AdapterVendorDescription) + 1);
    2c18:	6d 85       	ldd	r22, Y+13	; 0x0d
    2c1a:	7e 85       	ldd	r23, Y+14	; 0x0e
    2c1c:	fb 01       	movw	r30, r22
    2c1e:	ef 01       	movw	r28, r30
    2c20:	09 90       	ld	r0, Y+
    2c22:	00 20       	and	r0, r0
    2c24:	e9 f7       	brne	.-6      	; 0x2c20 <RNDIS_Device_ProcessControlRequest+0x350>
    2c26:	ce 1b       	sub	r28, r30
    2c28:	df 0b       	sbc	r29, r31

			memcpy(ResponseData, RNDISInterfaceInfo->Config.AdapterVendorDescription, *ResponseSize);
    2c2a:	c7 01       	movw	r24, r14
    2c2c:	ae 01       	movw	r20, r28
    2c2e:	6e d1       	rcall	.+732    	; 0x2f0c <memcpy>
    2c30:	f3 c0       	rjmp	.+486    	; 0x2e18 <RNDIS_Device_ProcessControlRequest+0x548>
			return true;
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = 100000;
    2c32:	80 ea       	ldi	r24, 0xA0	; 160
    2c34:	96 e8       	ldi	r25, 0x86	; 134
    2c36:	a1 e0       	ldi	r26, 0x01	; 1
    2c38:	b0 e0       	ldi	r27, 0x00	; 0
    2c3a:	22 c0       	rjmp	.+68     	; 0x2c80 <RNDIS_Device_ProcessControlRequest+0x3b0>
			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);

			memcpy(ResponseData, &RNDISInterfaceInfo->Config.AdapterMACAddress, sizeof(MAC_Address_t));
    2c3c:	d7 01       	movw	r26, r14
    2c3e:	fe 01       	movw	r30, r28
    2c40:	3f 96       	adiw	r30, 0x0f	; 15
    2c42:	86 e0       	ldi	r24, 0x06	; 6
    2c44:	01 90       	ld	r0, Z+
    2c46:	0d 92       	st	X+, r0
    2c48:	81 50       	subi	r24, 0x01	; 1
    2c4a:	e1 f7       	brne	.-8      	; 0x2c44 <RNDIS_Device_ProcessControlRequest+0x374>
    2c4c:	c6 e0       	ldi	r28, 0x06	; 6
    2c4e:	d0 e0       	ldi	r29, 0x00	; 0
    2c50:	e3 c0       	rjmp	.+454    	; 0x2e18 <RNDIS_Device_ProcessControlRequest+0x548>
			return true;
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = 1;
    2c52:	81 e0       	ldi	r24, 0x01	; 1
    2c54:	90 e0       	ldi	r25, 0x00	; 0
    2c56:	a0 e0       	ldi	r26, 0x00	; 0
    2c58:	b0 e0       	ldi	r27, 0x00	; 0
    2c5a:	12 c0       	rjmp	.+36     	; 0x2c80 <RNDIS_Device_ProcessControlRequest+0x3b0>

			return true;
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = RNDISInterfaceInfo->State.CurrPacketFilter;
    2c5c:	c9 56       	subi	r28, 0x69	; 105
    2c5e:	df 4f       	sbci	r29, 0xFF	; 255
    2c60:	88 81       	ld	r24, Y
    2c62:	99 81       	ldd	r25, Y+1	; 0x01
    2c64:	aa 81       	ldd	r26, Y+2	; 0x02
    2c66:	bb 81       	ldd	r27, Y+3	; 0x03
    2c68:	c7 59       	subi	r28, 0x97	; 151
    2c6a:	d0 40       	sbci	r29, 0x00	; 0
    2c6c:	09 c0       	rjmp	.+18     	; 0x2c80 <RNDIS_Device_ProcessControlRequest+0x3b0>
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = 0;
    2c6e:	1d a6       	std	Y+45, r1	; 0x2d
    2c70:	1e a6       	std	Y+46, r1	; 0x2e
    2c72:	1f a6       	std	Y+47, r1	; 0x2f
    2c74:	18 aa       	std	Y+48, r1	; 0x30
    2c76:	08 c0       	rjmp	.+16     	; 0x2c88 <RNDIS_Device_ProcessControlRequest+0x3b8>
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = (RNDIS_MESSAGE_BUFFER_SIZE + ETHERNET_FRAME_SIZE_MAX);
    2c78:	8c e5       	ldi	r24, 0x5C	; 92
    2c7a:	96 e0       	ldi	r25, 0x06	; 6
    2c7c:	a0 e0       	ldi	r26, 0x00	; 0
    2c7e:	b0 e0       	ldi	r27, 0x00	; 0
    2c80:	8d a7       	std	Y+45, r24	; 0x2d
    2c82:	9e a7       	std	Y+46, r25	; 0x2e
    2c84:	af a7       	std	Y+47, r26	; 0x2f
    2c86:	b8 ab       	std	Y+48, r27	; 0x30
    2c88:	c4 e0       	ldi	r28, 0x04	; 4
    2c8a:	d0 e0       	ldi	r29, 0x00	; 0
    2c8c:	c5 c0       	rjmp	.+394    	; 0x2e18 <RNDIS_Device_ProcessControlRequest+0x548>
				QUERY_Response->InformationBufferLength = ResponseSize;
				QUERY_Response->InformationBufferOffset = (sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
			}
			else
			{
				QUERY_Response->Status                  = REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    2c8e:	8b eb       	ldi	r24, 0xBB	; 187
    2c90:	90 e0       	ldi	r25, 0x00	; 0
    2c92:	a0 e0       	ldi	r26, 0x00	; 0
    2c94:	b0 ec       	ldi	r27, 0xC0	; 192
    2c96:	f8 01       	movw	r30, r16
    2c98:	84 87       	std	Z+12, r24	; 0x0c
    2c9a:	95 87       	std	Z+13, r25	; 0x0d
    2c9c:	a6 87       	std	Z+14, r26	; 0x0e
    2c9e:	b7 87       	std	Z+15, r27	; 0x0f

				QUERY_Response->InformationBufferLength = 0;
    2ca0:	10 8a       	std	Z+16, r1	; 0x10
    2ca2:	11 8a       	std	Z+17, r1	; 0x11
    2ca4:	12 8a       	std	Z+18, r1	; 0x12
    2ca6:	13 8a       	std	Z+19, r1	; 0x13
				QUERY_Response->InformationBufferOffset = 0;
    2ca8:	14 8a       	std	Z+20, r1	; 0x14
    2caa:	15 8a       	std	Z+21, r1	; 0x15
    2cac:	16 8a       	std	Z+22, r1	; 0x16
    2cae:	17 8a       	std	Z+23, r1	; 0x17
    2cb0:	d3 c0       	rjmp	.+422    	; 0x2e58 <RNDIS_Device_ProcessControlRequest+0x588>
			}

			break;
		case REMOTE_NDIS_SET_MSG:
			RNDISInterfaceInfo->State.ResponseReady = true;
    2cb2:	cb 56       	subi	r28, 0x6B	; 107
    2cb4:	df 4f       	sbci	r29, 0xFF	; 255
    2cb6:	81 e0       	ldi	r24, 0x01	; 1
    2cb8:	88 83       	st	Y, r24
    2cba:	c5 59       	subi	r28, 0x95	; 149
    2cbc:	d0 40       	sbci	r29, 0x00	; 0

			RNDIS_Set_Message_t*  SET_Message  = (RNDIS_Set_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Set_Complete_t* SET_Response = (RNDIS_Set_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t              SET_Oid      = SET_Message->Oid;
    2cbe:	f8 01       	movw	r30, r16
    2cc0:	24 85       	ldd	r18, Z+12	; 0x0c
    2cc2:	35 85       	ldd	r19, Z+13	; 0x0d
    2cc4:	46 85       	ldd	r20, Z+14	; 0x0e
    2cc6:	57 85       	ldd	r21, Z+15	; 0x0f

			SET_Response->MessageType   = REMOTE_NDIS_SET_CMPLT;
    2cc8:	85 e0       	ldi	r24, 0x05	; 5
    2cca:	90 e0       	ldi	r25, 0x00	; 0
    2ccc:	a0 e0       	ldi	r26, 0x00	; 0
    2cce:	b0 e8       	ldi	r27, 0x80	; 128
    2cd0:	8d 8b       	std	Y+21, r24	; 0x15
    2cd2:	9e 8b       	std	Y+22, r25	; 0x16
    2cd4:	af 8b       	std	Y+23, r26	; 0x17
    2cd6:	b8 8f       	std	Y+24, r27	; 0x18
			SET_Response->MessageLength = sizeof(RNDIS_Set_Complete_t);
    2cd8:	80 e1       	ldi	r24, 0x10	; 16
    2cda:	90 e0       	ldi	r25, 0x00	; 0
    2cdc:	a0 e0       	ldi	r26, 0x00	; 0
    2cde:	b0 e0       	ldi	r27, 0x00	; 0
    2ce0:	84 83       	std	Z+4, r24	; 0x04
    2ce2:	95 83       	std	Z+5, r25	; 0x05
    2ce4:	a6 83       	std	Z+6, r26	; 0x06
    2ce6:	b7 83       	std	Z+7, r27	; 0x07
			SET_Response->RequestId     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              SET_Message->InformationBufferOffset];
    2ce8:	84 89       	ldd	r24, Z+20	; 0x14
    2cea:	95 89       	ldd	r25, Z+21	; 0x15
    2cec:	a6 89       	ldd	r26, Z+22	; 0x16
    2cee:	b7 89       	ldd	r27, Z+23	; 0x17
                                        const void* SetData,
                                        const uint16_t SetSize)
{
	(void)SetSize;

	switch (OId)
    2cf0:	2e 30       	cpi	r18, 0x0E	; 14
    2cf2:	f1 e0       	ldi	r31, 0x01	; 1
    2cf4:	3f 07       	cpc	r19, r31
    2cf6:	f1 e0       	ldi	r31, 0x01	; 1
    2cf8:	4f 07       	cpc	r20, r31
    2cfa:	f0 e0       	ldi	r31, 0x00	; 0
    2cfc:	5f 07       	cpc	r21, r31
    2cfe:	51 f0       	breq	.+20     	; 0x2d14 <RNDIS_Device_ProcessControlRequest+0x444>
    2d00:	23 50       	subi	r18, 0x03	; 3
    2d02:	31 40       	sbci	r19, 0x01	; 1
    2d04:	41 40       	sbci	r20, 0x01	; 1
    2d06:	51 40       	sbci	r21, 0x01	; 1
    2d08:	a9 f0       	breq	.+42     	; 0x2d34 <RNDIS_Device_ProcessControlRequest+0x464>
    2d0a:	8b eb       	ldi	r24, 0xBB	; 187
    2d0c:	90 e0       	ldi	r25, 0x00	; 0
    2d0e:	a0 e0       	ldi	r26, 0x00	; 0
    2d10:	b0 ec       	ldi	r27, 0xC0	; 192
    2d12:	14 c0       	rjmp	.+40     	; 0x2d3c <RNDIS_Device_ProcessControlRequest+0x46c>
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			RNDISInterfaceInfo->State.CurrPacketFilter = *((uint32_t*)SetData);
    2d14:	fe 01       	movw	r30, r28
    2d16:	e8 0f       	add	r30, r24
    2d18:	f9 1f       	adc	r31, r25
    2d1a:	85 8d       	ldd	r24, Z+29	; 0x1d
    2d1c:	96 8d       	ldd	r25, Z+30	; 0x1e
    2d1e:	a7 8d       	ldd	r26, Z+31	; 0x1f
    2d20:	b0 a1       	ldd	r27, Z+32	; 0x20
    2d22:	c9 56       	subi	r28, 0x69	; 105
    2d24:	df 4f       	sbci	r29, 0xFF	; 255
    2d26:	88 83       	st	Y, r24
    2d28:	99 83       	std	Y+1, r25	; 0x01
    2d2a:	aa 83       	std	Y+2, r26	; 0x02
    2d2c:	bb 83       	std	Y+3, r27	; 0x03
			RNDISInterfaceInfo->State.CurrRNDISState = ((RNDISInterfaceInfo->State.CurrPacketFilter) ?
    2d2e:	fe 01       	movw	r30, r28
    2d30:	82 e0       	ldi	r24, 0x02	; 2
    2d32:	82 93       	st	-Z, r24
    2d34:	80 e0       	ldi	r24, 0x00	; 0
    2d36:	90 e0       	ldi	r25, 0x00	; 0
    2d38:	a0 e0       	ldi	r26, 0x00	; 0
    2d3a:	b0 e0       	ldi	r27, 0x00	; 0
			SET_Response->RequestId     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              SET_Message->InformationBufferOffset];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
    2d3c:	f8 01       	movw	r30, r16
    2d3e:	84 87       	std	Z+12, r24	; 0x0c
    2d40:	95 87       	std	Z+13, r25	; 0x0d
    2d42:	a6 87       	std	Z+14, r26	; 0x0e
    2d44:	b7 87       	std	Z+15, r27	; 0x0f
    2d46:	88 c0       	rjmp	.+272    	; 0x2e58 <RNDIS_Device_ProcessControlRequest+0x588>
			                                                   SET_Message->InformationBufferLength) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
			break;
		case REMOTE_NDIS_RESET_MSG:
			RNDISInterfaceInfo->State.ResponseReady = true;
    2d48:	cb 56       	subi	r28, 0x6B	; 107
    2d4a:	df 4f       	sbci	r29, 0xFF	; 255
    2d4c:	81 e0       	ldi	r24, 0x01	; 1
    2d4e:	88 83       	st	Y, r24
    2d50:	c5 59       	subi	r28, 0x95	; 149
    2d52:	d0 40       	sbci	r29, 0x00	; 0

			RNDIS_Reset_Complete_t* RESET_Response = (RNDIS_Reset_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			RESET_Response->MessageType     = REMOTE_NDIS_RESET_CMPLT;
    2d54:	86 e0       	ldi	r24, 0x06	; 6
    2d56:	90 e0       	ldi	r25, 0x00	; 0
    2d58:	a0 e0       	ldi	r26, 0x00	; 0
    2d5a:	b0 e8       	ldi	r27, 0x80	; 128
    2d5c:	8d 8b       	std	Y+21, r24	; 0x15
    2d5e:	9e 8b       	std	Y+22, r25	; 0x16
    2d60:	af 8b       	std	Y+23, r26	; 0x17
    2d62:	b8 8f       	std	Y+24, r27	; 0x18
			RESET_Response->MessageLength   = sizeof(RNDIS_Reset_Complete_t);
    2d64:	80 e1       	ldi	r24, 0x10	; 16
    2d66:	90 e0       	ldi	r25, 0x00	; 0
    2d68:	a0 e0       	ldi	r26, 0x00	; 0
    2d6a:	b0 e0       	ldi	r27, 0x00	; 0
    2d6c:	f8 01       	movw	r30, r16
    2d6e:	84 83       	std	Z+4, r24	; 0x04
    2d70:	95 83       	std	Z+5, r25	; 0x05
    2d72:	a6 83       	std	Z+6, r26	; 0x06
    2d74:	b7 83       	std	Z+7, r27	; 0x07
			RESET_Response->Status          = REMOTE_NDIS_STATUS_SUCCESS;
    2d76:	10 86       	std	Z+8, r1	; 0x08
    2d78:	11 86       	std	Z+9, r1	; 0x09
    2d7a:	12 86       	std	Z+10, r1	; 0x0a
    2d7c:	13 86       	std	Z+11, r1	; 0x0b
    2d7e:	17 c0       	rjmp	.+46     	; 0x2dae <RNDIS_Device_ProcessControlRequest+0x4de>
			RESET_Response->AddressingReset = 0;

			break;
		case REMOTE_NDIS_KEEPALIVE_MSG:
			RNDISInterfaceInfo->State.ResponseReady = true;
    2d80:	cb 56       	subi	r28, 0x6B	; 107
    2d82:	df 4f       	sbci	r29, 0xFF	; 255
    2d84:	81 e0       	ldi	r24, 0x01	; 1
    2d86:	88 83       	st	Y, r24
    2d88:	c5 59       	subi	r28, 0x95	; 149
    2d8a:	d0 40       	sbci	r29, 0x00	; 0
			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  =
			                (RNDIS_KeepAlive_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response =
			                (RNDIS_KeepAlive_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			KEEPALIVE_Response->MessageType   = REMOTE_NDIS_KEEPALIVE_CMPLT;
    2d8c:	88 e0       	ldi	r24, 0x08	; 8
    2d8e:	90 e0       	ldi	r25, 0x00	; 0
    2d90:	a0 e0       	ldi	r26, 0x00	; 0
    2d92:	b0 e8       	ldi	r27, 0x80	; 128
    2d94:	8d 8b       	std	Y+21, r24	; 0x15
    2d96:	9e 8b       	std	Y+22, r25	; 0x16
    2d98:	af 8b       	std	Y+23, r26	; 0x17
    2d9a:	b8 8f       	std	Y+24, r27	; 0x18
			KEEPALIVE_Response->MessageLength = sizeof(RNDIS_KeepAlive_Complete_t);
    2d9c:	80 e1       	ldi	r24, 0x10	; 16
    2d9e:	90 e0       	ldi	r25, 0x00	; 0
    2da0:	a0 e0       	ldi	r26, 0x00	; 0
    2da2:	b0 e0       	ldi	r27, 0x00	; 0
    2da4:	f8 01       	movw	r30, r16
    2da6:	84 83       	std	Z+4, r24	; 0x04
    2da8:	95 83       	std	Z+5, r25	; 0x05
    2daa:	a6 83       	std	Z+6, r26	; 0x06
    2dac:	b7 83       	std	Z+7, r27	; 0x07
			KEEPALIVE_Response->RequestId     = KEEPALIVE_Message->RequestId;
			KEEPALIVE_Response->Status        = REMOTE_NDIS_STATUS_SUCCESS;
    2dae:	14 86       	std	Z+12, r1	; 0x0c
    2db0:	15 86       	std	Z+13, r1	; 0x0d
    2db2:	16 86       	std	Z+14, r1	; 0x0e
    2db4:	17 86       	std	Z+15, r1	; 0x0f
    2db6:	50 c0       	rjmp	.+160    	; 0x2e58 <RNDIS_Device_ProcessControlRequest+0x588>
				RNDIS_Device_ProcessRNDISControlMessage(RNDISInterfaceInfo);
			}

			break;
		case RNDIS_REQ_GetEncapsulatedResponse:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    2db8:	80 91 01 14 	lds	r24, 0x1401
    2dbc:	81 3a       	cpi	r24, 0xA1	; 161
    2dbe:	09 f0       	breq	.+2      	; 0x2dc2 <RNDIS_Device_ProcessControlRequest+0x4f2>
    2dc0:	4b c0       	rjmp	.+150    	; 0x2e58 <RNDIS_Device_ProcessControlRequest+0x588>
			{
				RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
    2dc2:	8e 01       	movw	r16, r28
    2dc4:	0b 5e       	subi	r16, 0xEB	; 235
    2dc6:	1f 4f       	sbci	r17, 0xFF	; 255

				if (!(MessageHeader->MessageLength))
    2dc8:	f8 01       	movw	r30, r16
    2dca:	84 81       	ldd	r24, Z+4	; 0x04
    2dcc:	95 81       	ldd	r25, Z+5	; 0x05
    2dce:	a6 81       	ldd	r26, Z+6	; 0x06
    2dd0:	b7 81       	ldd	r27, Z+7	; 0x07
    2dd2:	00 97       	sbiw	r24, 0x00	; 0
    2dd4:	a1 05       	cpc	r26, r1
    2dd6:	b1 05       	cpc	r27, r1
    2dd8:	49 f4       	brne	.+18     	; 0x2dec <RNDIS_Device_ProcessControlRequest+0x51c>
				{
					RNDISInterfaceInfo->State.RNDISMessageBuffer[0] = 0;
    2dda:	1d 8a       	std	Y+21, r1	; 0x15
					MessageHeader->MessageLength = 1;
    2ddc:	81 e0       	ldi	r24, 0x01	; 1
    2dde:	90 e0       	ldi	r25, 0x00	; 0
    2de0:	a0 e0       	ldi	r26, 0x00	; 0
    2de2:	b0 e0       	ldi	r27, 0x00	; 0
    2de4:	84 83       	std	Z+4, r24	; 0x04
    2de6:	95 83       	std	Z+5, r25	; 0x05
    2de8:	a6 83       	std	Z+6, r26	; 0x06
    2dea:	b7 83       	std	Z+7, r27	; 0x07
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2dec:	80 91 e8 00 	lds	r24, 0x00E8
    2df0:	87 7f       	andi	r24, 0xF7	; 247
    2df2:	80 93 e8 00 	sts	0x00E8, r24
				}

				Endpoint_ClearSETUP();
				Endpoint_Write_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, MessageHeader->MessageLength);
    2df6:	f8 01       	movw	r30, r16
    2df8:	64 81       	ldd	r22, Z+4	; 0x04
    2dfa:	75 81       	ldd	r23, Z+5	; 0x05
    2dfc:	ce 01       	movw	r24, r28
    2dfe:	45 96       	adiw	r24, 0x15	; 21
    2e00:	39 da       	rcall	.-2958   	; 0x2274 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2e02:	80 91 e8 00 	lds	r24, 0x00E8
    2e06:	8b 77       	andi	r24, 0x7B	; 123
    2e08:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearOUT();

				MessageHeader->MessageLength = 0;
    2e0c:	f8 01       	movw	r30, r16
    2e0e:	14 82       	std	Z+4, r1	; 0x04
    2e10:	15 82       	std	Z+5, r1	; 0x05
    2e12:	16 82       	std	Z+6, r1	; 0x06
    2e14:	17 82       	std	Z+7, r1	; 0x07
    2e16:	20 c0       	rjmp	.+64     	; 0x2e58 <RNDIS_Device_ProcessControlRequest+0x588>
			QUERY_Response->MessageLength = sizeof(RNDIS_Query_Complete_t);

			if (RNDIS_Device_ProcessNDISQuery(RNDISInterfaceInfo, Query_Oid, QueryData, QUERY_Message->InformationBufferLength,
			                                  ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = REMOTE_NDIS_STATUS_SUCCESS;
    2e18:	f8 01       	movw	r30, r16
    2e1a:	14 86       	std	Z+12, r1	; 0x0c
    2e1c:	15 86       	std	Z+13, r1	; 0x0d
    2e1e:	16 86       	std	Z+14, r1	; 0x0e
    2e20:	17 86       	std	Z+15, r1	; 0x0f
				QUERY_Response->MessageLength          += ResponseSize;
    2e22:	ce 01       	movw	r24, r28
    2e24:	a0 e0       	ldi	r26, 0x00	; 0
    2e26:	b0 e0       	ldi	r27, 0x00	; 0
    2e28:	24 81       	ldd	r18, Z+4	; 0x04
    2e2a:	35 81       	ldd	r19, Z+5	; 0x05
    2e2c:	46 81       	ldd	r20, Z+6	; 0x06
    2e2e:	57 81       	ldd	r21, Z+7	; 0x07
    2e30:	28 0f       	add	r18, r24
    2e32:	39 1f       	adc	r19, r25
    2e34:	4a 1f       	adc	r20, r26
    2e36:	5b 1f       	adc	r21, r27
    2e38:	24 83       	std	Z+4, r18	; 0x04
    2e3a:	35 83       	std	Z+5, r19	; 0x05
    2e3c:	46 83       	std	Z+6, r20	; 0x06
    2e3e:	57 83       	std	Z+7, r21	; 0x07

				QUERY_Response->InformationBufferLength = ResponseSize;
    2e40:	80 8b       	std	Z+16, r24	; 0x10
    2e42:	91 8b       	std	Z+17, r25	; 0x11
    2e44:	a2 8b       	std	Z+18, r26	; 0x12
    2e46:	b3 8b       	std	Z+19, r27	; 0x13
				QUERY_Response->InformationBufferOffset = (sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
    2e48:	80 e1       	ldi	r24, 0x10	; 16
    2e4a:	90 e0       	ldi	r25, 0x00	; 0
    2e4c:	a0 e0       	ldi	r26, 0x00	; 0
    2e4e:	b0 e0       	ldi	r27, 0x00	; 0
    2e50:	84 8b       	std	Z+20, r24	; 0x14
    2e52:	95 8b       	std	Z+21, r25	; 0x15
    2e54:	a6 8b       	std	Z+22, r26	; 0x16
    2e56:	b7 8b       	std	Z+23, r27	; 0x17
				MessageHeader->MessageLength = 0;
			}

			break;
	}
}
    2e58:	df 91       	pop	r29
    2e5a:	cf 91       	pop	r28
    2e5c:	1f 91       	pop	r17
    2e5e:	0f 91       	pop	r16
    2e60:	ff 90       	pop	r15
    2e62:	ef 90       	pop	r14
    2e64:	08 95       	ret

00002e66 <Serial_putchar>:

FILE USARTSerialStream;

int Serial_putchar(char DataByte,
                   FILE *Stream)
{
    2e66:	98 2f       	mov	r25, r24
			 *  \param[in] DataByte  Byte to transmit through the USART.
			 */
			static inline void Serial_SendByte(const char DataByte) ATTR_ALWAYS_INLINE;
			static inline void Serial_SendByte(const char DataByte)
			{
				while (!(UCSR1A & (1 << UDRE1)));
    2e68:	80 91 c8 00 	lds	r24, 0x00C8
    2e6c:	85 ff       	sbrs	r24, 5
    2e6e:	fc cf       	rjmp	.-8      	; 0x2e68 <Serial_putchar+0x2>
				UDR1 = DataByte;
    2e70:	90 93 ce 00 	sts	0x00CE, r25
	(void)Stream;

	Serial_SendByte(DataByte);
	return 0;
}
    2e74:	80 e0       	ldi	r24, 0x00	; 0
    2e76:	90 e0       	ldi	r25, 0x00	; 0
    2e78:	08 95       	ret

00002e7a <Serial_getchar>:
			 *  \return Boolean \c true if a character has been received, \c false otherwise.
			 */
			static inline bool Serial_IsCharReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Serial_IsCharReceived(void)
			{
				return ((UCSR1A & (1 << RXC1)) ? true : false);
    2e7a:	80 91 c8 00 	lds	r24, 0x00C8

int Serial_getchar(FILE *Stream)
{
	(void)Stream;

	if (!(Serial_IsCharReceived()))
    2e7e:	87 fd       	sbrc	r24, 7
    2e80:	03 c0       	rjmp	.+6      	; 0x2e88 <Serial_getchar+0xe>
    2e82:	2e ef       	ldi	r18, 0xFE	; 254
    2e84:	3f ef       	ldi	r19, 0xFF	; 255
    2e86:	0b c0       	rjmp	.+22     	; 0x2e9e <Serial_getchar+0x24>
    2e88:	80 91 c8 00 	lds	r24, 0x00C8
			 *  \return Next byte received from the USART, or a negative value if no byte has been received.
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
    2e8c:	87 fd       	sbrc	r24, 7
    2e8e:	03 c0       	rjmp	.+6      	; 0x2e96 <Serial_getchar+0x1c>
    2e90:	2f ef       	ldi	r18, 0xFF	; 255
    2e92:	3f ef       	ldi	r19, 0xFF	; 255
    2e94:	04 c0       	rjmp	.+8      	; 0x2e9e <Serial_getchar+0x24>
				  return -1;
				
				return UDR1;
    2e96:	80 91 ce 00 	lds	r24, 0x00CE
    2e9a:	28 2f       	mov	r18, r24
    2e9c:	30 e0       	ldi	r19, 0x00	; 0
	  return _FDEV_EOF;

	return Serial_ReceiveByte();
}
    2e9e:	c9 01       	movw	r24, r18
    2ea0:	08 95       	ret

00002ea2 <memcpy_P>:
    2ea2:	fb 01       	movw	r30, r22
    2ea4:	dc 01       	movw	r26, r24
    2ea6:	02 c0       	rjmp	.+4      	; 0x2eac <memcpy_P+0xa>
    2ea8:	05 90       	lpm	r0, Z+
    2eaa:	0d 92       	st	X+, r0
    2eac:	41 50       	subi	r20, 0x01	; 1
    2eae:	50 40       	sbci	r21, 0x00	; 0
    2eb0:	d8 f7       	brcc	.-10     	; 0x2ea8 <memcpy_P+0x6>
    2eb2:	08 95       	ret

00002eb4 <strcpy_P>:
    2eb4:	fb 01       	movw	r30, r22
    2eb6:	dc 01       	movw	r26, r24
    2eb8:	05 90       	lpm	r0, Z+
    2eba:	0d 92       	st	X+, r0
    2ebc:	00 20       	and	r0, r0
    2ebe:	e1 f7       	brne	.-8      	; 0x2eb8 <strcpy_P+0x4>
    2ec0:	08 95       	ret

00002ec2 <strlen_P>:
    2ec2:	fc 01       	movw	r30, r24
    2ec4:	05 90       	lpm	r0, Z+
    2ec6:	00 20       	and	r0, r0
    2ec8:	e9 f7       	brne	.-6      	; 0x2ec4 <strlen_P+0x2>
    2eca:	80 95       	com	r24
    2ecc:	90 95       	com	r25
    2ece:	8e 0f       	add	r24, r30
    2ed0:	9f 1f       	adc	r25, r31
    2ed2:	08 95       	ret

00002ed4 <strncpy_P>:
    2ed4:	fb 01       	movw	r30, r22
    2ed6:	dc 01       	movw	r26, r24
    2ed8:	41 50       	subi	r20, 0x01	; 1
    2eda:	50 40       	sbci	r21, 0x00	; 0
    2edc:	48 f0       	brcs	.+18     	; 0x2ef0 <strncpy_P+0x1c>
    2ede:	05 90       	lpm	r0, Z+
    2ee0:	0d 92       	st	X+, r0
    2ee2:	00 20       	and	r0, r0
    2ee4:	c9 f7       	brne	.-14     	; 0x2ed8 <strncpy_P+0x4>
    2ee6:	01 c0       	rjmp	.+2      	; 0x2eea <strncpy_P+0x16>
    2ee8:	1d 92       	st	X+, r1
    2eea:	41 50       	subi	r20, 0x01	; 1
    2eec:	50 40       	sbci	r21, 0x00	; 0
    2eee:	e0 f7       	brcc	.-8      	; 0x2ee8 <strncpy_P+0x14>
    2ef0:	08 95       	ret

00002ef2 <memcmp>:
    2ef2:	fb 01       	movw	r30, r22
    2ef4:	dc 01       	movw	r26, r24
    2ef6:	04 c0       	rjmp	.+8      	; 0x2f00 <memcmp+0xe>
    2ef8:	8d 91       	ld	r24, X+
    2efa:	01 90       	ld	r0, Z+
    2efc:	80 19       	sub	r24, r0
    2efe:	21 f4       	brne	.+8      	; 0x2f08 <memcmp+0x16>
    2f00:	41 50       	subi	r20, 0x01	; 1
    2f02:	50 40       	sbci	r21, 0x00	; 0
    2f04:	c8 f7       	brcc	.-14     	; 0x2ef8 <memcmp+0x6>
    2f06:	88 1b       	sub	r24, r24
    2f08:	99 0b       	sbc	r25, r25
    2f0a:	08 95       	ret

00002f0c <memcpy>:
    2f0c:	fb 01       	movw	r30, r22
    2f0e:	dc 01       	movw	r26, r24
    2f10:	02 c0       	rjmp	.+4      	; 0x2f16 <memcpy+0xa>
    2f12:	01 90       	ld	r0, Z+
    2f14:	0d 92       	st	X+, r0
    2f16:	41 50       	subi	r20, 0x01	; 1
    2f18:	50 40       	sbci	r21, 0x00	; 0
    2f1a:	d8 f7       	brcc	.-10     	; 0x2f12 <memcpy+0x6>
    2f1c:	08 95       	ret

00002f1e <memmove>:
    2f1e:	68 17       	cp	r22, r24
    2f20:	79 07       	cpc	r23, r25
    2f22:	68 f4       	brcc	.+26     	; 0x2f3e <memmove+0x20>
    2f24:	fb 01       	movw	r30, r22
    2f26:	dc 01       	movw	r26, r24
    2f28:	e4 0f       	add	r30, r20
    2f2a:	f5 1f       	adc	r31, r21
    2f2c:	a4 0f       	add	r26, r20
    2f2e:	b5 1f       	adc	r27, r21
    2f30:	02 c0       	rjmp	.+4      	; 0x2f36 <memmove+0x18>
    2f32:	02 90       	ld	r0, -Z
    2f34:	0e 92       	st	-X, r0
    2f36:	41 50       	subi	r20, 0x01	; 1
    2f38:	50 40       	sbci	r21, 0x00	; 0
    2f3a:	d8 f7       	brcc	.-10     	; 0x2f32 <memmove+0x14>
    2f3c:	08 95       	ret
    2f3e:	e6 cf       	rjmp	.-52     	; 0x2f0c <memcpy>

00002f40 <strncmp>:
    2f40:	fb 01       	movw	r30, r22
    2f42:	dc 01       	movw	r26, r24
    2f44:	41 50       	subi	r20, 0x01	; 1
    2f46:	50 40       	sbci	r21, 0x00	; 0
    2f48:	30 f0       	brcs	.+12     	; 0x2f56 <strncmp+0x16>
    2f4a:	8d 91       	ld	r24, X+
    2f4c:	01 90       	ld	r0, Z+
    2f4e:	80 19       	sub	r24, r0
    2f50:	19 f4       	brne	.+6      	; 0x2f58 <strncmp+0x18>
    2f52:	00 20       	and	r0, r0
    2f54:	b9 f7       	brne	.-18     	; 0x2f44 <strncmp+0x4>
    2f56:	88 1b       	sub	r24, r24
    2f58:	99 0b       	sbc	r25, r25
    2f5a:	08 95       	ret

00002f5c <_exit>:
    2f5c:	f8 94       	cli

00002f5e <__stop_program>:
    2f5e:	ff cf       	rjmp	.-2      	; 0x2f5e <__stop_program>
